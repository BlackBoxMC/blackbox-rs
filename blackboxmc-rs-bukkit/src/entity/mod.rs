#![allow(deprecated)]
use blackboxmc_general::JNIRaw;
use blackboxmc_general::JNIInstantiatable;
use color_eyre::eyre::Result;
pub enum FishHookHookState<'mc> {
	Unhooked {inner: FishHookHookStateStruct<'mc>},
	HookedEntity {inner: FishHookHookStateStruct<'mc>},
	Bobbing {inner: FishHookHookStateStruct<'mc>},
}
impl<'mc> std::fmt::Display for FishHookHookState<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           FishHookHookState::Unhooked { .. } => f.write_str("UNHOOKED"),
           FishHookHookState::HookedEntity { .. } => f.write_str("HOOKED_ENTITY"),
           FishHookHookState::Bobbing { .. } => f.write_str("BOBBING"),
       }
   }
}

        impl<'mc> FishHookHookState<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<FishHookHookState<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/FishHook/HookState");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/FishHook/HookState;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"UNHOOKED" => Ok(FishHookHookState::Unhooked { inner: FishHookHookStateStruct::from_raw(env,obj)?}),
"HOOKED_ENTITY" => Ok(FishHookHookState::HookedEntity { inner: FishHookHookStateStruct::from_raw(env,obj)?}),
"BOBBING" => Ok(FishHookHookState::Bobbing { inner: FishHookHookStateStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct FishHookHookStateStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for FishHookHookState<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Unhooked { inner } => inner.0.clone(),
Self::HookedEntity { inner } => inner.0.clone(),
Self::Bobbing { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Unhooked { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::HookedEntity { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Bobbing { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for FishHookHookState<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate FishHookHookState from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/FishHook/HookState")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a FishHookHookState object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "UNHOOKED" => Ok(FishHookHookState::Unhooked { inner: FishHookHookStateStruct::from_raw(env,obj)?}),"HOOKED_ENTITY" => Ok(FishHookHookState::HookedEntity { inner: FishHookHookStateStruct::from_raw(env,obj)?}),"BOBBING" => Ok(FishHookHookState::Bobbing { inner: FishHookHookStateStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for FishHookHookStateStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for FishHookHookStateStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate FishHookHookStateStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/FishHook/HookState")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a FishHookHookStateStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> FishHookHookStateStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::FishHookHookState<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::FishHookHookState;");
let cls = jni.find_class("org/bukkit/entity/FishHook/HookState"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::FishHookHookState::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct AnimalTamer<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for AnimalTamer<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for AnimalTamer<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate AnimalTamer from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AnimalTamer")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a AnimalTamer object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> AnimalTamer<'mc> {
	pub fn name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Painting<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Painting<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Painting<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Painting from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Painting")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Painting object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Painting<'mc> {
	pub fn art(&self) 
-> Result<crate::Art<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Art;");
let res = self.jni_ref().call_method(&self.jni_object(),"getArt",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Art::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_art_with_art(&self,art: impl Into<crate::Art<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Art;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(art.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setArt",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_facing_direction(&self,face: impl Into<crate::block::BlockFace<'mc>>,force: bool) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/block/BlockFace;Z)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(face.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Bool(force.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setFacingDirection",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Hanging<'mc>> for Painting<'mc>{

fn into(self) -> crate::entity::Hanging<'mc> {

crate::entity::Hanging::from_raw(&self.jni_ref(), self.1).expect("Error converting Painting into crate::entity::Hanging")

   }
}
#[repr(C)]
pub struct Stray<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Stray<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Stray<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Stray from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Stray")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Stray object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Stray<'mc> {
#[deprecated]

	pub fn skeleton_type(&self) 
-> Result<crate::entity::SkeletonSkeletonType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SkeletonSkeletonType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSkeletonType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SkeletonSkeletonType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_skeleton_type(&self,val_type: impl Into<crate::entity::SkeletonSkeletonType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Skeleton/SkeletonType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setSkeletonType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::AbstractSkeleton<'mc>> for Stray<'mc>{

fn into(self) -> crate::entity::AbstractSkeleton<'mc> {

crate::entity::AbstractSkeleton::from_raw(&self.jni_ref(), self.1).expect("Error converting Stray into crate::entity::AbstractSkeleton")

   }
}
pub enum SkeletonSkeletonType<'mc> {
	Normal {inner: SkeletonSkeletonTypeStruct<'mc>},
	Wither {inner: SkeletonSkeletonTypeStruct<'mc>},
	Stray {inner: SkeletonSkeletonTypeStruct<'mc>},
}
impl<'mc> std::fmt::Display for SkeletonSkeletonType<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           SkeletonSkeletonType::Normal { .. } => f.write_str("NORMAL"),
           SkeletonSkeletonType::Wither { .. } => f.write_str("WITHER"),
           SkeletonSkeletonType::Stray { .. } => f.write_str("STRAY"),
       }
   }
}

        impl<'mc> SkeletonSkeletonType<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<SkeletonSkeletonType<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Skeleton/SkeletonType");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Skeleton/SkeletonType;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"NORMAL" => Ok(SkeletonSkeletonType::Normal { inner: SkeletonSkeletonTypeStruct::from_raw(env,obj)?}),
"WITHER" => Ok(SkeletonSkeletonType::Wither { inner: SkeletonSkeletonTypeStruct::from_raw(env,obj)?}),
"STRAY" => Ok(SkeletonSkeletonType::Stray { inner: SkeletonSkeletonTypeStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct SkeletonSkeletonTypeStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for SkeletonSkeletonType<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Normal { inner } => inner.0.clone(),
Self::Wither { inner } => inner.0.clone(),
Self::Stray { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Normal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Wither { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Stray { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for SkeletonSkeletonType<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate SkeletonSkeletonType from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Skeleton/SkeletonType")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a SkeletonSkeletonType object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "NORMAL" => Ok(SkeletonSkeletonType::Normal { inner: SkeletonSkeletonTypeStruct::from_raw(env,obj)?}),"WITHER" => Ok(SkeletonSkeletonType::Wither { inner: SkeletonSkeletonTypeStruct::from_raw(env,obj)?}),"STRAY" => Ok(SkeletonSkeletonType::Stray { inner: SkeletonSkeletonTypeStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for SkeletonSkeletonTypeStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for SkeletonSkeletonTypeStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate SkeletonSkeletonTypeStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Skeleton/SkeletonType")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a SkeletonSkeletonTypeStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> SkeletonSkeletonTypeStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::SkeletonSkeletonType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SkeletonSkeletonType;");
let cls = jni.find_class("org/bukkit/entity/Skeleton/SkeletonType"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::SkeletonSkeletonType::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Goat<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Goat<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Goat<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Goat from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Goat")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Goat object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Goat<'mc> {
	pub fn has_left_horn(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasLeftHorn",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_left_horn(&self,has_horn: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(has_horn.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setLeftHorn",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_right_horn(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasRightHorn",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_right_horn(&self,has_horn: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(has_horn.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setRightHorn",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_screaming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isScreaming",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_screaming(&self,screaming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(screaming.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setScreaming",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Goat<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Goat into crate::entity::Animals")

   }
}
#[repr(C)]
pub struct Dolphin<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Dolphin<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Dolphin<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Dolphin from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Dolphin")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Dolphin object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Dolphin<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::WaterMob<'mc>> for Dolphin<'mc>{

fn into(self) -> crate::entity::WaterMob<'mc> {

crate::entity::WaterMob::from_raw(&self.jni_ref(), self.1).expect("Error converting Dolphin into crate::entity::WaterMob")

   }
}
#[repr(C)]
pub struct HumanEntity<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for HumanEntity<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for HumanEntity<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate HumanEntity from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/HumanEntity")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a HumanEntity object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> HumanEntity<'mc> {
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::PlayerInventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::PlayerInventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::PlayerInventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ender_chest(&self) 
-> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::Inventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEnderChest",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::Inventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn main_hand(&self) 
-> Result<crate::inventory::MainHand<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::MainHand;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMainHand",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::MainHand::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_window_property(&self,prop: impl Into<crate::inventory::InventoryViewProperty<'mc>>,value: i32) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/InventoryView/Property;I)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(prop.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setWindowProperty",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn enchantment_seed(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEnchantmentSeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_enchantment_seed(&self,seed: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(seed);
let res = self.jni_ref().call_method(&self.jni_object(),"setEnchantmentSeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn open_inventory_with_inventory(&self,inventory: std::option::Option<impl Into<crate::inventory::InventoryView<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = inventory {
sig += "Lorg/bukkit/inventory/InventoryView;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"openInventory",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn open_workbench(&self,location: impl Into<crate::Location<'mc>>,force: bool) 
-> Result<Option<crate::inventory::InventoryView<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;Z)Lcrate::inventory::InventoryView;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Bool(force.into());
let res = self.jni_ref().call_method(&self.jni_object(),"openWorkbench",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::InventoryView::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn open_enchanting(&self,location: impl Into<crate::Location<'mc>>,force: bool) 
-> Result<Option<crate::inventory::InventoryView<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;Z)Lcrate::inventory::InventoryView;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Bool(force.into());
let res = self.jni_ref().call_method(&self.jni_object(),"openEnchanting",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::InventoryView::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn open_merchant_with_merchant(&self,merchant: impl Into<crate::inventory::Merchant<'mc>>,force: bool) 
-> Result<Option<crate::inventory::InventoryView<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/Merchant;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(merchant.into().jni_object().clone())});
args.push(val_1);
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(force.into());
args.push(val_2);
sig += ")Lorg/bukkit/inventory/InventoryView;";
let res = self.jni_ref().call_method(&self.jni_object(),"openMerchant",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::InventoryView::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn close_inventory(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"closeInventory",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn item_in_hand(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInHand",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_item_in_hand(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInHand",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_on_cursor(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemOnCursor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item_on_cursor(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setItemOnCursor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_cooldown(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Material;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_cooldown(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Material;)Li32;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_cooldown(&self,material: impl Into<crate::Material<'mc>>,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Material;I)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn sleep_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSleepTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn sleep(&self,location: impl Into<crate::Location<'mc>>,force: bool) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;Z)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Bool(force.into());
let res = self.jni_ref().call_method(&self.jni_object(),"sleep",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn wakeup(&self,set_spawn_location: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(set_spawn_location.into());
let res = self.jni_ref().call_method(&self.jni_object(),"wakeup",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn bed_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBedLocation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn game_mode(&self) 
-> Result<crate::GameMode<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::GameMode;");
let res = self.jni_ref().call_method(&self.jni_object(),"getGameMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::GameMode::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_game_mode(&self,mode: impl Into<crate::GameMode<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/GameMode;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(mode.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setGameMode",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_blocking(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isBlocking",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_hand_raised(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isHandRaised",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn exp_to_level(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getExpToLevel",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn attack_cooldown(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAttackCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn discover_recipe(&self,recipe: impl Into<crate::NamespacedKey<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(recipe.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"discoverRecipe",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn undiscover_recipe(&self,recipe: impl Into<crate::NamespacedKey<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(recipe.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"undiscoverRecipe",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_discovered_recipe(&self,recipe: impl Into<crate::NamespacedKey<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(recipe.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasDiscoveredRecipe",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn discovered_recipes(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDiscoveredRecipes",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn shoulder_entity_left(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShoulderEntityLeft",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_shoulder_entity_left(&self,entity: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShoulderEntityLeft",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn shoulder_entity_right(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShoulderEntityRight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_shoulder_entity_right(&self,entity: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShoulderEntityRight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn drop_item(&self,drop_all: bool) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Z)Lbool;");
let val_1 = jni::objects::JValueGen::Bool(drop_all.into());
let res = self.jni_ref().call_method(&self.jni_object(),"dropItem",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn exhaustion(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getExhaustion",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_exhaustion(&self,value: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setExhaustion",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn saturation(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSaturation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_saturation(&self,value: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setSaturation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn food_level(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFoodLevel",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_food_level(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setFoodLevel",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn saturated_regen_rate(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSaturatedRegenRate",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_saturated_regen_rate(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setSaturatedRegenRate",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn unsaturated_regen_rate(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUnsaturatedRegenRate",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_unsaturated_regen_rate(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setUnsaturatedRegenRate",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn starvation_rate(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getStarvationRate",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_starvation_rate(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setStarvationRate",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_death_location(&self) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDeathLocation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_last_death_location(&self,location: impl Into<crate::Location<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDeathLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn firework_boost(&self,firework_item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<Option<crate::entity::Firework<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lcrate::entity::Firework;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(firework_item_stack.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"fireworkBoost",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Firework::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("(Z)Lf64;");
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)LVec;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)Lcrate::block::Block;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)LVec;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(count);
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(damage);
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Player;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lcrate::potion::PotionEffect;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(remove.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::EntityEquipment;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(ai.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/memory/MemoryKey;)Ljni::objects::JObject;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/memory/MemoryKey;Ljava/lang/Object;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(memory_value);
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(I)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Int(fall_height);
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::LivingEntity<'mc>> for HumanEntity<'mc>{

fn into(self) -> crate::entity::LivingEntity<'mc> {

crate::entity::LivingEntity::from_raw(&self.jni_ref(), self.1).expect("Error converting HumanEntity into crate::entity::LivingEntity")

   }
}
impl<'mc> Into<crate::entity::AnimalTamer<'mc>> for HumanEntity<'mc>{

fn into(self) -> crate::entity::AnimalTamer<'mc> {

crate::entity::AnimalTamer::from_raw(&self.jni_ref(), self.1).expect("Error converting HumanEntity into crate::entity::AnimalTamer")

   }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for HumanEntity<'mc>{

fn into(self) -> crate::inventory::InventoryHolder<'mc> {

crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1).expect("Error converting HumanEntity into crate::inventory::InventoryHolder")

   }
}
#[repr(C)]
pub struct Spellcaster<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Spellcaster<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Spellcaster<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Spellcaster from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Spellcaster")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Spellcaster object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Spellcaster<'mc> {
	pub fn spell(&self) 
-> Result<crate::entity::SpellcasterSpell<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpellcasterSpell;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpell",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpellcasterSpell::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_spell(&self,spell: impl Into<crate::entity::SpellcasterSpell<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Spellcaster/Spell;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(spell.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setSpell",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Illager<'mc>> for Spellcaster<'mc>{

fn into(self) -> crate::entity::Illager<'mc> {

crate::entity::Illager::from_raw(&self.jni_ref(), self.1).expect("Error converting Spellcaster into crate::entity::Illager")

   }
}
#[repr(C)]
pub struct LargeFireball<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for LargeFireball<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for LargeFireball<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate LargeFireball from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LargeFireball")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a LargeFireball object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> LargeFireball<'mc> {
	pub fn display_item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayItem",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_display_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayItem",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::SizedFireball<'mc>> for LargeFireball<'mc>{

fn into(self) -> crate::entity::SizedFireball<'mc> {

crate::entity::SizedFireball::from_raw(&self.jni_ref(), self.1).expect("Error converting LargeFireball into crate::entity::SizedFireball")

   }
}
#[repr(C)]
pub struct Donkey<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Donkey<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Donkey<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Donkey from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Donkey")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Donkey object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Donkey<'mc> {
	pub fn is_carrying_chest(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCarryingChest",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_carrying_chest(&self,chest: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(chest.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCarryingChest",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::ChestedHorse<'mc>> for Donkey<'mc>{

fn into(self) -> crate::entity::ChestedHorse<'mc> {

crate::entity::ChestedHorse::from_raw(&self.jni_ref(), self.1).expect("Error converting Donkey into crate::entity::ChestedHorse")

   }
}
#[repr(C)]
pub struct InteractionPreviousInteraction<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for InteractionPreviousInteraction<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for InteractionPreviousInteraction<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate InteractionPreviousInteraction from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Interaction/PreviousInteraction")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a InteractionPreviousInteraction object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> InteractionPreviousInteraction<'mc> {
	pub fn player(&self) 
-> Result<crate::OfflinePlayer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::OfflinePlayer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPlayer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::OfflinePlayer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn timestamp(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTimestamp",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Strider<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Strider<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Strider<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Strider from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Strider")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Strider object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Strider<'mc> {
	pub fn is_shivering(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isShivering",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_shivering(&self,shivering: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(shivering.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setShivering",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_saddle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasSaddle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_saddle(&self,saddled: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(saddled.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSaddle",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn boost_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoostTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_boost_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setBoostTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn current_boost_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCurrentBoostTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_current_boost_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setCurrentBoostTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn steer_material(&self) 
-> Result<crate::Material<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Material;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSteerMaterial",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Material::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_velocity(&self,vel: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(vel.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Steerable<'mc>> for Strider<'mc>{

fn into(self) -> crate::entity::Steerable<'mc> {

crate::entity::Steerable::from_raw(&self.jni_ref(), self.1).expect("Error converting Strider into crate::entity::Steerable")

   }
}
impl<'mc> Into<crate::entity::Vehicle<'mc>> for Strider<'mc>{

fn into(self) -> crate::entity::Vehicle<'mc> {

crate::entity::Vehicle::from_raw(&self.jni_ref(), self.1).expect("Error converting Strider into crate::entity::Vehicle")

   }
}
#[repr(C)]
pub struct Steerable<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Steerable<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Steerable<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Steerable from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Steerable")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Steerable object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Steerable<'mc> {
	pub fn has_saddle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasSaddle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_saddle(&self,saddled: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(saddled.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSaddle",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn boost_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoostTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_boost_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setBoostTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn current_boost_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCurrentBoostTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_current_boost_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setCurrentBoostTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn steer_material(&self) 
-> Result<crate::Material<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Material;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSteerMaterial",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Material::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Steerable<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Steerable into crate::entity::Animals")

   }
}
#[repr(C)]
pub struct ComplexEntityPart<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ComplexEntityPart<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ComplexEntityPart<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ComplexEntityPart from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ComplexEntityPart")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ComplexEntityPart object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ComplexEntityPart<'mc> {
	pub fn parent(&self) 
-> Result<crate::entity::ComplexLivingEntity<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::ComplexLivingEntity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getParent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::ComplexLivingEntity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::BlockFace;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for ComplexEntityPart<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting ComplexEntityPart into crate::entity::Entity")

   }
}
pub enum EvokerSpell<'mc> {
	None {inner: EvokerSpellStruct<'mc>},
	Summon {inner: EvokerSpellStruct<'mc>},
	Fangs {inner: EvokerSpellStruct<'mc>},
	Wololo {inner: EvokerSpellStruct<'mc>},
	Disappear {inner: EvokerSpellStruct<'mc>},
	Blindness {inner: EvokerSpellStruct<'mc>},
}
impl<'mc> std::fmt::Display for EvokerSpell<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           EvokerSpell::None { .. } => f.write_str("NONE"),
           EvokerSpell::Summon { .. } => f.write_str("SUMMON"),
           EvokerSpell::Fangs { .. } => f.write_str("FANGS"),
           EvokerSpell::Wololo { .. } => f.write_str("WOLOLO"),
           EvokerSpell::Disappear { .. } => f.write_str("DISAPPEAR"),
           EvokerSpell::Blindness { .. } => f.write_str("BLINDNESS"),
       }
   }
}

        impl<'mc> EvokerSpell<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<EvokerSpell<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Evoker/Spell");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Evoker/Spell;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"NONE" => Ok(EvokerSpell::None { inner: EvokerSpellStruct::from_raw(env,obj)?}),
"SUMMON" => Ok(EvokerSpell::Summon { inner: EvokerSpellStruct::from_raw(env,obj)?}),
"FANGS" => Ok(EvokerSpell::Fangs { inner: EvokerSpellStruct::from_raw(env,obj)?}),
"WOLOLO" => Ok(EvokerSpell::Wololo { inner: EvokerSpellStruct::from_raw(env,obj)?}),
"DISAPPEAR" => Ok(EvokerSpell::Disappear { inner: EvokerSpellStruct::from_raw(env,obj)?}),
"BLINDNESS" => Ok(EvokerSpell::Blindness { inner: EvokerSpellStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct EvokerSpellStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for EvokerSpell<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::None { inner } => inner.0.clone(),
Self::Summon { inner } => inner.0.clone(),
Self::Fangs { inner } => inner.0.clone(),
Self::Wololo { inner } => inner.0.clone(),
Self::Disappear { inner } => inner.0.clone(),
Self::Blindness { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Summon { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Fangs { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Wololo { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Disappear { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Blindness { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for EvokerSpell<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EvokerSpell from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Evoker/Spell")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EvokerSpell object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "NONE" => Ok(EvokerSpell::None { inner: EvokerSpellStruct::from_raw(env,obj)?}),"SUMMON" => Ok(EvokerSpell::Summon { inner: EvokerSpellStruct::from_raw(env,obj)?}),"FANGS" => Ok(EvokerSpell::Fangs { inner: EvokerSpellStruct::from_raw(env,obj)?}),"WOLOLO" => Ok(EvokerSpell::Wololo { inner: EvokerSpellStruct::from_raw(env,obj)?}),"DISAPPEAR" => Ok(EvokerSpell::Disappear { inner: EvokerSpellStruct::from_raw(env,obj)?}),"BLINDNESS" => Ok(EvokerSpell::Blindness { inner: EvokerSpellStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for EvokerSpellStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for EvokerSpellStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EvokerSpellStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Evoker/Spell")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EvokerSpellStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> EvokerSpellStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::EvokerSpell<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EvokerSpell;");
let cls = jni.find_class("org/bukkit/entity/Evoker/Spell"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::EvokerSpell::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct TippedArrow<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for TippedArrow<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for TippedArrow<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate TippedArrow from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TippedArrow")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a TippedArrow object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> TippedArrow<'mc> {
#[deprecated]

	pub fn set_base_potion_data(&self,data: impl Into<crate::potion::PotionData<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionData;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(data.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBasePotionData",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn base_potion_data(&self) 
-> Result<crate::potion::PotionData<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::potion::PotionData;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBasePotionData",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::potion::PotionData::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_base_potion_type(&self,val_type: impl Into<crate::potion::PotionType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBasePotionType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn base_potion_type(&self) 
-> Result<crate::potion::PotionType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::potion::PotionType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBasePotionType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::potion::PotionType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn color(&self) 
-> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Color;");
let res = self.jni_ref().call_method(&self.jni_object(),"getColor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Color::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_color(&self,color: impl Into<crate::Color<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Color;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setColor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_custom_effects(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasCustomEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn custom_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_custom_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,overwrite: bool) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffect;Z)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Bool(overwrite.into());
let res = self.jni_ref().call_method(&self.jni_object(),"addCustomEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_custom_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeCustomEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_custom_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasCustomEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn clear_custom_effects(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"clearCustomEffects",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Arrow<'mc>> for TippedArrow<'mc>{

fn into(self) -> crate::entity::Arrow<'mc> {

crate::entity::Arrow::from_raw(&self.jni_ref(), self.1).expect("Error converting TippedArrow into crate::entity::Arrow")

   }
}
#[repr(C)]
pub struct Projectile<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Projectile<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Projectile<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Projectile from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Projectile")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Projectile object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Projectile<'mc> {
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::BlockFace;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Projectile<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting Projectile into crate::entity::Entity")

   }
}
pub enum AbstractArrowPickupStatus<'mc> {
	Disallowed {inner: AbstractArrowPickupStatusStruct<'mc>},
	Allowed {inner: AbstractArrowPickupStatusStruct<'mc>},
	CreativeOnly {inner: AbstractArrowPickupStatusStruct<'mc>},
}
impl<'mc> std::fmt::Display for AbstractArrowPickupStatus<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           AbstractArrowPickupStatus::Disallowed { .. } => f.write_str("DISALLOWED"),
           AbstractArrowPickupStatus::Allowed { .. } => f.write_str("ALLOWED"),
           AbstractArrowPickupStatus::CreativeOnly { .. } => f.write_str("CREATIVE_ONLY"),
       }
   }
}

        impl<'mc> AbstractArrowPickupStatus<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<AbstractArrowPickupStatus<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/AbstractArrow/PickupStatus");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/AbstractArrow/PickupStatus;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"DISALLOWED" => Ok(AbstractArrowPickupStatus::Disallowed { inner: AbstractArrowPickupStatusStruct::from_raw(env,obj)?}),
"ALLOWED" => Ok(AbstractArrowPickupStatus::Allowed { inner: AbstractArrowPickupStatusStruct::from_raw(env,obj)?}),
"CREATIVE_ONLY" => Ok(AbstractArrowPickupStatus::CreativeOnly { inner: AbstractArrowPickupStatusStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct AbstractArrowPickupStatusStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for AbstractArrowPickupStatus<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Disallowed { inner } => inner.0.clone(),
Self::Allowed { inner } => inner.0.clone(),
Self::CreativeOnly { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Disallowed { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Allowed { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::CreativeOnly { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for AbstractArrowPickupStatus<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate AbstractArrowPickupStatus from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AbstractArrow/PickupStatus")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a AbstractArrowPickupStatus object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "DISALLOWED" => Ok(AbstractArrowPickupStatus::Disallowed { inner: AbstractArrowPickupStatusStruct::from_raw(env,obj)?}),"ALLOWED" => Ok(AbstractArrowPickupStatus::Allowed { inner: AbstractArrowPickupStatusStruct::from_raw(env,obj)?}),"CREATIVE_ONLY" => Ok(AbstractArrowPickupStatus::CreativeOnly { inner: AbstractArrowPickupStatusStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for AbstractArrowPickupStatusStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for AbstractArrowPickupStatusStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate AbstractArrowPickupStatusStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AbstractArrow/PickupStatus")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a AbstractArrowPickupStatusStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> AbstractArrowPickupStatusStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::AbstractArrowPickupStatus<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AbstractArrowPickupStatus;");
let cls = jni.find_class("org/bukkit/entity/AbstractArrow/PickupStatus"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::AbstractArrowPickupStatus::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct ThrowableProjectile<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ThrowableProjectile<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ThrowableProjectile<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ThrowableProjectile from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ThrowableProjectile")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ThrowableProjectile object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ThrowableProjectile<'mc> {
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::BlockFace;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for ThrowableProjectile<'mc>{

fn into(self) -> crate::entity::Projectile<'mc> {

crate::entity::Projectile::from_raw(&self.jni_ref(), self.1).expect("Error converting ThrowableProjectile into crate::entity::Projectile")

   }
}
#[repr(C)]
pub struct Hanging<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Hanging<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Hanging<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Hanging from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Hanging")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Hanging object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Hanging<'mc> {
	pub fn set_facing_direction_with_face(&self,face: impl Into<crate::block::BlockFace<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/block/BlockFace;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(face.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setFacingDirection",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn attached_face(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::BlockFace;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAttachedFace",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Hanging<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting Hanging into crate::entity::Entity")

   }
}
impl<'mc> Into<crate::material::Attachable<'mc>> for Hanging<'mc>{

fn into(self) -> crate::material::Attachable<'mc> {

crate::material::Attachable::from_raw(&self.jni_ref(), self.1).expect("Error converting Hanging into crate::material::Attachable")

   }
}
#[repr(C)]
pub struct LlamaSpit<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for LlamaSpit<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for LlamaSpit<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate LlamaSpit from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LlamaSpit")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a LlamaSpit object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> LlamaSpit<'mc> {
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for LlamaSpit<'mc>{

fn into(self) -> crate::entity::Projectile<'mc> {

crate::entity::Projectile::from_raw(&self.jni_ref(), self.1).expect("Error converting LlamaSpit into crate::entity::Projectile")

   }
}
#[repr(C)]
pub struct Ravager<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Ravager<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Ravager<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Ravager from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ravager")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Ravager object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Ravager<'mc> {
	pub fn set_raid(&self,raid: impl Into<crate::Raid<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Raid;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(raid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn raid(&self) 
-> Result<Option<crate::Raid<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Raid;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Raid::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn wave(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWave",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_wave(&self,wave: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(wave);
let res = self.jni_ref().call_method(&self.jni_object(),"setWave",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn patrol_target(&self) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::Block;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPatrolTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_patrol_target(&self,block: impl Into<crate::block::Block<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/block/Block;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(block.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPatrolTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_patrol_leader(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPatrolLeader",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_patrol_leader(&self,leader: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(leader.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPatrolLeader",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_can_join_raid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCanJoinRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_can_join_raid(&self,join: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(join.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanJoinRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn ticks_outside_raid(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksOutsideRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_outside_raid(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksOutsideRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_celebrating(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCelebrating",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_celebrating(&self,celebrating: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(celebrating.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCelebrating",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn celebration_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCelebrationSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Raider<'mc>> for Ravager<'mc>{

fn into(self) -> crate::entity::Raider<'mc> {

crate::entity::Raider::from_raw(&self.jni_ref(), self.1).expect("Error converting Ravager into crate::entity::Raider")

   }
}
#[repr(C)]
pub struct WaterMob<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for WaterMob<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for WaterMob<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate WaterMob from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/WaterMob")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a WaterMob object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> WaterMob<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Creature<'mc>> for WaterMob<'mc>{

fn into(self) -> crate::entity::Creature<'mc> {

crate::entity::Creature::from_raw(&self.jni_ref(), self.1).expect("Error converting WaterMob into crate::entity::Creature")

   }
}
#[repr(C)]
pub struct PiglinBrute<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for PiglinBrute<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for PiglinBrute<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate PiglinBrute from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/PiglinBrute")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a PiglinBrute object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> PiglinBrute<'mc> {
	pub fn is_immune_to_zombification(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isImmuneToZombification",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_immune_to_zombification(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setImmuneToZombification",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn conversion_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getConversionTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_conversion_time(&self,time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(time);
let res = self.jni_ref().call_method(&self.jni_object(),"setConversionTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_converting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isConverting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn is_baby(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isBaby",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_baby(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::PiglinAbstract<'mc>> for PiglinBrute<'mc>{

fn into(self) -> crate::entity::PiglinAbstract<'mc> {

crate::entity::PiglinAbstract::from_raw(&self.jni_ref(), self.1).expect("Error converting PiglinBrute into crate::entity::PiglinAbstract")

   }
}
#[repr(C)]
pub struct Vex<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Vex<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Vex<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Vex from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Vex")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Vex object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Vex<'mc> {
	pub fn is_charging(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCharging",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_charging(&self,charging: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(charging.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCharging",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn bound(&self) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_bound(&self,location: impl Into<crate::Location<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn life_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLifeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_life_ticks(&self,life_ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(life_ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLifeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_limited_life(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasLimitedLife",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Vex<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Vex into crate::entity::Monster")

   }
}
#[repr(C)]
pub struct Entity<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Entity<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Entity<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Entity from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Entity")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Entity object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Entity<'mc> {
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::metadata::Metadatable<'mc>> for Entity<'mc>{

fn into(self) -> crate::metadata::Metadatable<'mc> {

crate::metadata::Metadatable::from_raw(&self.jni_ref(), self.1).expect("Error converting Entity into crate::metadata::Metadatable")

   }
}
impl<'mc> Into<crate::command::CommandSender<'mc>> for Entity<'mc>{

fn into(self) -> crate::command::CommandSender<'mc> {

crate::command::CommandSender::from_raw(&self.jni_ref(), self.1).expect("Error converting Entity into crate::command::CommandSender")

   }
}
impl<'mc> Into<crate::Nameable<'mc>> for Entity<'mc>{

fn into(self) -> crate::Nameable<'mc> {

crate::Nameable::from_raw(&self.jni_ref(), self.1).expect("Error converting Entity into crate::Nameable")

   }
}
impl<'mc> Into<crate::persistence::PersistentDataHolder<'mc>> for Entity<'mc>{

fn into(self) -> crate::persistence::PersistentDataHolder<'mc> {

crate::persistence::PersistentDataHolder::from_raw(&self.jni_ref(), self.1).expect("Error converting Entity into crate::persistence::PersistentDataHolder")

   }
}
#[repr(C)]
pub struct LightningStrike<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for LightningStrike<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for LightningStrike<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate LightningStrike from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LightningStrike")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a LightningStrike object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> LightningStrike<'mc> {
	pub fn is_effect(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEffect",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn flashes(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFlashes",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_flashes(&self,flashes: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(flashes);
let res = self.jni_ref().call_method(&self.jni_object(),"setFlashes",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn life_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLifeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_life_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLifeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn causing_player(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Player;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCausingPlayer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_causing_player(&self,player: impl Into<crate::entity::Player<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Player;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(player.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setCausingPlayer",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for LightningStrike<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting LightningStrike into crate::entity::Entity")

   }
}
#[repr(C)]
pub struct LeashHitch<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for LeashHitch<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for LeashHitch<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate LeashHitch from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LeashHitch")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a LeashHitch object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> LeashHitch<'mc> {
	pub fn set_facing_direction_with_face(&self,face: impl Into<crate::block::BlockFace<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/block/BlockFace;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(face.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setFacingDirection",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn attached_face(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::BlockFace;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAttachedFace",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Hanging<'mc>> for LeashHitch<'mc>{

fn into(self) -> crate::entity::Hanging<'mc> {

crate::entity::Hanging::from_raw(&self.jni_ref(), self.1).expect("Error converting LeashHitch into crate::entity::Hanging")

   }
}
#[repr(C)]
pub struct AbstractHorse<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for AbstractHorse<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for AbstractHorse<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate AbstractHorse from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AbstractHorse")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a AbstractHorse object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> AbstractHorse<'mc> {
#[deprecated]

	pub fn variant(&self) 
-> Result<crate::entity::HorseVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::HorseVariant;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVariant",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::HorseVariant::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_variant(&self,variant: impl Into<crate::entity::HorseVariant<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Horse/Variant;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(variant.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVariant",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn max_domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_max_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn jump_strength(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getJumpStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_jump_strength(&self,strength: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setJumpStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_eating_haystack(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEatingHaystack",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_eating_haystack(&self,eating_haystack: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(eating_haystack.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setEatingHaystack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::AbstractHorseInventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::AbstractHorseInventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::AbstractHorseInventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_velocity(&self,vel: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(vel.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_tamed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTamed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_tamed(&self,tame: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(tame.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setTamed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn owner(&self) 
-> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AnimalTamer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOwner",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::AnimalTamer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_owner(&self,tamer: impl Into<crate::entity::AnimalTamer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(tamer.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setOwner",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Vehicle<'mc>> for AbstractHorse<'mc>{

fn into(self) -> crate::entity::Vehicle<'mc> {

crate::entity::Vehicle::from_raw(&self.jni_ref(), self.1).expect("Error converting AbstractHorse into crate::entity::Vehicle")

   }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for AbstractHorse<'mc>{

fn into(self) -> crate::inventory::InventoryHolder<'mc> {

crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1).expect("Error converting AbstractHorse into crate::inventory::InventoryHolder")

   }
}
impl<'mc> Into<crate::entity::Tameable<'mc>> for AbstractHorse<'mc>{

fn into(self) -> crate::entity::Tameable<'mc> {

crate::entity::Tameable::from_raw(&self.jni_ref(), self.1).expect("Error converting AbstractHorse into crate::entity::Tameable")

   }
}
#[repr(C)]
pub struct Boss<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Boss<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Boss<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Boss from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Boss")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Boss object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Boss<'mc> {
	pub fn boss_bar(&self) 
-> Result<Option<crate::boss::BossBar<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::boss::BossBar;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBossBar",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::boss::BossBar::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Boss<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting Boss into crate::entity::Entity")

   }
}
#[repr(C)]
pub struct Spider<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Spider<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Spider<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Spider from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Spider")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Spider object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Spider<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Spider<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Spider into crate::entity::Monster")

   }
}
#[repr(C)]
pub struct Zoglin<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Zoglin<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Zoglin<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Zoglin from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Zoglin")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Zoglin object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Zoglin<'mc> {
#[deprecated]

	pub fn is_baby(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isBaby",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_baby_with_flag(&self,flag: std::option::Option<bool>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = flag {
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(a.into());
args.push(val_1);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn age(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAge",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_age(&self,age: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(age);
let res = self.jni_ref().call_method(&self.jni_object(),"setAge",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_age_lock(&self,lock: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(lock.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAgeLock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn age_lock(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAgeLock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_adult(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"setAdult",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_adult(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAdult",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn can_breed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canBreed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_breed(&self,breed: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(breed.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBreed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Zoglin<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Zoglin into crate::entity::Monster")

   }
}
impl<'mc> Into<crate::entity::Ageable<'mc>> for Zoglin<'mc>{

fn into(self) -> crate::entity::Ageable<'mc> {

crate::entity::Ageable::from_raw(&self.jni_ref(), self.1).expect("Error converting Zoglin into crate::entity::Ageable")

   }
}
#[repr(C)]
pub struct Rabbit<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Rabbit<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Rabbit<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Rabbit from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Rabbit")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Rabbit object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Rabbit<'mc> {
	pub fn rabbit_type(&self) 
-> Result<crate::entity::RabbitType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::RabbitType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRabbitType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::RabbitType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rabbit_type(&self,val_type: impl Into<crate::entity::RabbitType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Rabbit/Type;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setRabbitType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Rabbit<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Rabbit into crate::entity::Animals")

   }
}
#[repr(C)]
pub struct Endermite<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Endermite<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Endermite<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Endermite from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Endermite")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Endermite object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Endermite<'mc> {
#[deprecated]

	pub fn is_player_spawned(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPlayerSpawned",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_player_spawned(&self,player_spawned: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(player_spawned.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPlayerSpawned",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Endermite<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Endermite into crate::entity::Monster")

   }
}
pub enum TropicalFishPattern<'mc> {
	Kob {inner: TropicalFishPatternStruct<'mc>},
	Sunstreak {inner: TropicalFishPatternStruct<'mc>},
	Snooper {inner: TropicalFishPatternStruct<'mc>},
	Dasher {inner: TropicalFishPatternStruct<'mc>},
	Brinely {inner: TropicalFishPatternStruct<'mc>},
	Spotty {inner: TropicalFishPatternStruct<'mc>},
	Flopper {inner: TropicalFishPatternStruct<'mc>},
	Stripey {inner: TropicalFishPatternStruct<'mc>},
	Glitter {inner: TropicalFishPatternStruct<'mc>},
	Blockfish {inner: TropicalFishPatternStruct<'mc>},
	Betty {inner: TropicalFishPatternStruct<'mc>},
	Clayfish {inner: TropicalFishPatternStruct<'mc>},
}
impl<'mc> std::fmt::Display for TropicalFishPattern<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           TropicalFishPattern::Kob { .. } => f.write_str("KOB"),
           TropicalFishPattern::Sunstreak { .. } => f.write_str("SUNSTREAK"),
           TropicalFishPattern::Snooper { .. } => f.write_str("SNOOPER"),
           TropicalFishPattern::Dasher { .. } => f.write_str("DASHER"),
           TropicalFishPattern::Brinely { .. } => f.write_str("BRINELY"),
           TropicalFishPattern::Spotty { .. } => f.write_str("SPOTTY"),
           TropicalFishPattern::Flopper { .. } => f.write_str("FLOPPER"),
           TropicalFishPattern::Stripey { .. } => f.write_str("STRIPEY"),
           TropicalFishPattern::Glitter { .. } => f.write_str("GLITTER"),
           TropicalFishPattern::Blockfish { .. } => f.write_str("BLOCKFISH"),
           TropicalFishPattern::Betty { .. } => f.write_str("BETTY"),
           TropicalFishPattern::Clayfish { .. } => f.write_str("CLAYFISH"),
       }
   }
}

        impl<'mc> TropicalFishPattern<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<TropicalFishPattern<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/TropicalFish/Pattern");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/TropicalFish/Pattern;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"KOB" => Ok(TropicalFishPattern::Kob { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),
"SUNSTREAK" => Ok(TropicalFishPattern::Sunstreak { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),
"SNOOPER" => Ok(TropicalFishPattern::Snooper { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),
"DASHER" => Ok(TropicalFishPattern::Dasher { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),
"BRINELY" => Ok(TropicalFishPattern::Brinely { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),
"SPOTTY" => Ok(TropicalFishPattern::Spotty { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),
"FLOPPER" => Ok(TropicalFishPattern::Flopper { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),
"STRIPEY" => Ok(TropicalFishPattern::Stripey { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),
"GLITTER" => Ok(TropicalFishPattern::Glitter { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),
"BLOCKFISH" => Ok(TropicalFishPattern::Blockfish { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),
"BETTY" => Ok(TropicalFishPattern::Betty { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),
"CLAYFISH" => Ok(TropicalFishPattern::Clayfish { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct TropicalFishPatternStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for TropicalFishPattern<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Kob { inner } => inner.0.clone(),
Self::Sunstreak { inner } => inner.0.clone(),
Self::Snooper { inner } => inner.0.clone(),
Self::Dasher { inner } => inner.0.clone(),
Self::Brinely { inner } => inner.0.clone(),
Self::Spotty { inner } => inner.0.clone(),
Self::Flopper { inner } => inner.0.clone(),
Self::Stripey { inner } => inner.0.clone(),
Self::Glitter { inner } => inner.0.clone(),
Self::Blockfish { inner } => inner.0.clone(),
Self::Betty { inner } => inner.0.clone(),
Self::Clayfish { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Kob { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Sunstreak { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Snooper { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Dasher { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Brinely { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Spotty { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Flopper { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Stripey { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Glitter { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Blockfish { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Betty { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Clayfish { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for TropicalFishPattern<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate TropicalFishPattern from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TropicalFish/Pattern")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a TropicalFishPattern object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "KOB" => Ok(TropicalFishPattern::Kob { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),"SUNSTREAK" => Ok(TropicalFishPattern::Sunstreak { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),"SNOOPER" => Ok(TropicalFishPattern::Snooper { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),"DASHER" => Ok(TropicalFishPattern::Dasher { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),"BRINELY" => Ok(TropicalFishPattern::Brinely { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),"SPOTTY" => Ok(TropicalFishPattern::Spotty { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),"FLOPPER" => Ok(TropicalFishPattern::Flopper { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),"STRIPEY" => Ok(TropicalFishPattern::Stripey { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),"GLITTER" => Ok(TropicalFishPattern::Glitter { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),"BLOCKFISH" => Ok(TropicalFishPattern::Blockfish { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),"BETTY" => Ok(TropicalFishPattern::Betty { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),"CLAYFISH" => Ok(TropicalFishPattern::Clayfish { inner: TropicalFishPatternStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for TropicalFishPatternStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for TropicalFishPatternStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate TropicalFishPatternStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TropicalFish/Pattern")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a TropicalFishPatternStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> TropicalFishPatternStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::TropicalFishPattern<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::TropicalFishPattern;");
let cls = jni.find_class("org/bukkit/entity/TropicalFish/Pattern"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::TropicalFishPattern::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Item<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Item<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Item<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Item from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Item")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Item object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Item<'mc> {
	pub fn item_stack(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemStack",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item_stack(&self,stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(stack.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setItemStack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn pickup_delay(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPickupDelay",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_pickup_delay(&self,delay: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(delay);
let res = self.jni_ref().call_method(&self.jni_object(),"setPickupDelay",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_unlimited_lifetime(&self,unlimited: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(unlimited.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setUnlimitedLifetime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_unlimited_lifetime(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isUnlimitedLifetime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_owner(&self,owner: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owner.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setOwner",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn owner(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOwner",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_thrower(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setThrower",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn thrower(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getThrower",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Item<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting Item into crate::entity::Entity")

   }
}
#[repr(C)]
pub struct TextDisplay<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for TextDisplay<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for TextDisplay<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate TextDisplay from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TextDisplay")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a TextDisplay object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> TextDisplay<'mc> {
	pub fn text(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getText",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_text(&self,text: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(text.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setText",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn line_width(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLineWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_line_width(&self,width: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(width);
let res = self.jni_ref().call_method(&self.jni_object(),"setLineWidth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn background_color(&self) 
-> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Color;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBackgroundColor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Color::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_background_color(&self,color: impl Into<crate::Color<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Color;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBackgroundColor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn text_opacity(&self) 
-> Result<i8, Box<dyn std::error::Error>>

{let sig = String::from("()Li8;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTextOpacity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.b()?
)}
	pub fn set_text_opacity(&self,opacity: i8) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(B)L();");
let val_1 = jni::objects::JValueGen::Byte(opacity);
let res = self.jni_ref().call_method(&self.jni_object(),"setTextOpacity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_shadowed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isShadowed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_shadowed(&self,shadow: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(shadow.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setShadowed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_see_through(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSeeThrough",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_see_through(&self,see_through: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(see_through.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSeeThrough",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_default_background(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDefaultBackground",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_default_background(&self,default_background: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(default_background.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setDefaultBackground",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn alignment(&self) 
-> Result<crate::entity::TextDisplayTextAlignment<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::TextDisplayTextAlignment;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAlignment",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::TextDisplayTextAlignment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_alignment(&self,alignment: impl Into<crate::entity::TextDisplayTextAlignment<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/TextDisplay/TextAlignment;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(alignment.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setAlignment",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn transformation(&self) 
-> Result<crate::util::Transformation<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Transformation;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTransformation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Transformation::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_transformation(&self,transformation: impl Into<crate::util::Transformation<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Transformation;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transformation.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTransformation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_transformation_matrix(&self,transformation_matrix: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/joml/Matrix4f;)L();");
let val_1 = jni::objects::JValueGen::Object(transformation_matrix);
let res = self.jni_ref().call_method(&self.jni_object(),"setTransformationMatrix",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn interpolation_duration(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInterpolationDuration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_interpolation_duration(&self,duration: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(duration);
let res = self.jni_ref().call_method(&self.jni_object(),"setInterpolationDuration",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_duration(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTeleportDuration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_teleport_duration(&self,duration: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(duration);
let res = self.jni_ref().call_method(&self.jni_object(),"setTeleportDuration",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn view_range(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getViewRange",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_view_range(&self,range: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(range);
let res = self.jni_ref().call_method(&self.jni_object(),"setViewRange",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shadow_radius(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShadowRadius",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_shadow_radius(&self,radius: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(radius);
let res = self.jni_ref().call_method(&self.jni_object(),"setShadowRadius",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shadow_strength(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShadowStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_shadow_strength(&self,strength: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setShadowStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn display_width(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_display_width(&self,width: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(width);
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayWidth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn display_height(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_display_height(&self,height: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(height);
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayHeight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn interpolation_delay(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInterpolationDelay",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_interpolation_delay(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setInterpolationDelay",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn billboard(&self) 
-> Result<crate::entity::DisplayBillboard<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::DisplayBillboard;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBillboard",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::DisplayBillboard::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_billboard(&self,billboard: impl Into<crate::entity::DisplayBillboard<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Display/Billboard;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(billboard.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBillboard",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn glow_color_override(&self) 
-> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Color;");
let res = self.jni_ref().call_method(&self.jni_object(),"getGlowColorOverride",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Color::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_glow_color_override(&self,color: impl Into<crate::Color<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Color;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowColorOverride",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn brightness(&self) 
-> Result<Option<crate::entity::DisplayBrightness<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::DisplayBrightness;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBrightness",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::DisplayBrightness::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_brightness(&self,brightness: impl Into<crate::entity::DisplayBrightness<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Display/Brightness;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(brightness.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBrightness",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Display<'mc>> for TextDisplay<'mc>{

fn into(self) -> crate::entity::Display<'mc> {

crate::entity::Display::from_raw(&self.jni_ref(), self.1).expect("Error converting TextDisplay into crate::entity::Display")

   }
}
#[repr(C)]
pub struct Fish<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Fish<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Fish<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Fish from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Fish")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Fish object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Fish<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::WaterMob<'mc>> for Fish<'mc>{

fn into(self) -> crate::entity::WaterMob<'mc> {

crate::entity::WaterMob::from_raw(&self.jni_ref(), self.1).expect("Error converting Fish into crate::entity::WaterMob")

   }
}
pub enum SnifferState<'mc> {
	Idling {inner: SnifferStateStruct<'mc>},
	FeelingHappy {inner: SnifferStateStruct<'mc>},
	Scenting {inner: SnifferStateStruct<'mc>},
	Sniffing {inner: SnifferStateStruct<'mc>},
	Searching {inner: SnifferStateStruct<'mc>},
	Digging {inner: SnifferStateStruct<'mc>},
	Rising {inner: SnifferStateStruct<'mc>},
}
impl<'mc> std::fmt::Display for SnifferState<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           SnifferState::Idling { .. } => f.write_str("IDLING"),
           SnifferState::FeelingHappy { .. } => f.write_str("FEELING_HAPPY"),
           SnifferState::Scenting { .. } => f.write_str("SCENTING"),
           SnifferState::Sniffing { .. } => f.write_str("SNIFFING"),
           SnifferState::Searching { .. } => f.write_str("SEARCHING"),
           SnifferState::Digging { .. } => f.write_str("DIGGING"),
           SnifferState::Rising { .. } => f.write_str("RISING"),
       }
   }
}

        impl<'mc> SnifferState<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<SnifferState<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Sniffer/State");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Sniffer/State;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"IDLING" => Ok(SnifferState::Idling { inner: SnifferStateStruct::from_raw(env,obj)?}),
"FEELING_HAPPY" => Ok(SnifferState::FeelingHappy { inner: SnifferStateStruct::from_raw(env,obj)?}),
"SCENTING" => Ok(SnifferState::Scenting { inner: SnifferStateStruct::from_raw(env,obj)?}),
"SNIFFING" => Ok(SnifferState::Sniffing { inner: SnifferStateStruct::from_raw(env,obj)?}),
"SEARCHING" => Ok(SnifferState::Searching { inner: SnifferStateStruct::from_raw(env,obj)?}),
"DIGGING" => Ok(SnifferState::Digging { inner: SnifferStateStruct::from_raw(env,obj)?}),
"RISING" => Ok(SnifferState::Rising { inner: SnifferStateStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct SnifferStateStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for SnifferState<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Idling { inner } => inner.0.clone(),
Self::FeelingHappy { inner } => inner.0.clone(),
Self::Scenting { inner } => inner.0.clone(),
Self::Sniffing { inner } => inner.0.clone(),
Self::Searching { inner } => inner.0.clone(),
Self::Digging { inner } => inner.0.clone(),
Self::Rising { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Idling { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::FeelingHappy { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Scenting { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Sniffing { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Searching { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Digging { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Rising { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for SnifferState<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate SnifferState from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Sniffer/State")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a SnifferState object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "IDLING" => Ok(SnifferState::Idling { inner: SnifferStateStruct::from_raw(env,obj)?}),"FEELING_HAPPY" => Ok(SnifferState::FeelingHappy { inner: SnifferStateStruct::from_raw(env,obj)?}),"SCENTING" => Ok(SnifferState::Scenting { inner: SnifferStateStruct::from_raw(env,obj)?}),"SNIFFING" => Ok(SnifferState::Sniffing { inner: SnifferStateStruct::from_raw(env,obj)?}),"SEARCHING" => Ok(SnifferState::Searching { inner: SnifferStateStruct::from_raw(env,obj)?}),"DIGGING" => Ok(SnifferState::Digging { inner: SnifferStateStruct::from_raw(env,obj)?}),"RISING" => Ok(SnifferState::Rising { inner: SnifferStateStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for SnifferStateStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for SnifferStateStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate SnifferStateStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Sniffer/State")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a SnifferStateStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> SnifferStateStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::SnifferState<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SnifferState;");
let cls = jni.find_class("org/bukkit/entity/Sniffer/State"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::SnifferState::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Giant<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Giant<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Giant<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Giant from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Giant")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Giant object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Giant<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Giant<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Giant into crate::entity::Monster")

   }
}
#[repr(C)]
pub struct Mob<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Mob<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Mob<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Mob from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Mob")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Mob object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Mob<'mc> {
	pub fn set_target(&self,target: impl Into<crate::entity::LivingEntity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/LivingEntity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn target(&self) 
-> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::LivingEntity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::LivingEntity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_aware(&self,aware: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(aware.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAware",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_aware(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAware",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn ambient_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAmbientSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("(Z)Lf64;");
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)LVec;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)Lcrate::block::Block;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)LVec;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(count);
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(damage);
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Player;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lcrate::potion::PotionEffect;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(remove.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::EntityEquipment;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(ai.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/memory/MemoryKey;)Ljni::objects::JObject;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/memory/MemoryKey;Ljava/lang/Object;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(memory_value);
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(I)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Int(fall_height);
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_loot_table(&self,table: impl Into<crate::loot::LootTable<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/loot/LootTable;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(table.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLootTable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn loot_table(&self) 
-> Result<Option<crate::loot::LootTable<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::loot::LootTable;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLootTable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::loot::LootTable::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_seed(&self,seed: i64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(J)L();");
let val_1 = jni::objects::JValueGen::Long(seed);
let res = self.jni_ref().call_method(&self.jni_object(),"setSeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn seed(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::LivingEntity<'mc>> for Mob<'mc>{

fn into(self) -> crate::entity::LivingEntity<'mc> {

crate::entity::LivingEntity::from_raw(&self.jni_ref(), self.1).expect("Error converting Mob into crate::entity::LivingEntity")

   }
}
impl<'mc> Into<crate::loot::Lootable<'mc>> for Mob<'mc>{

fn into(self) -> crate::loot::Lootable<'mc> {

crate::loot::Lootable::from_raw(&self.jni_ref(), self.1).expect("Error converting Mob into crate::loot::Lootable")

   }
}
#[repr(C)]
pub struct Bat<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Bat<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Bat<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Bat from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Bat")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Bat object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Bat<'mc> {
	pub fn is_awake(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAwake",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_awake(&self,state: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(state.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAwake",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Ambient<'mc>> for Bat<'mc>{

fn into(self) -> crate::entity::Ambient<'mc> {

crate::entity::Ambient::from_raw(&self.jni_ref(), self.1).expect("Error converting Bat into crate::entity::Ambient")

   }
}
#[repr(C)]
pub struct Allay<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Allay<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Allay<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Allay from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Allay")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Allay object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Allay<'mc> {
	pub fn can_duplicate(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canDuplicate",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_can_duplicate(&self,can_duplicate: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(can_duplicate.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanDuplicate",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn duplication_cooldown(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDuplicationCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}
	pub fn set_duplication_cooldown(&self,cooldown: i64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(J)L();");
let val_1 = jni::objects::JValueGen::Long(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setDuplicationCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn reset_duplication_cooldown(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetDuplicationCooldown",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dancing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDancing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn start_dancing_with_location(&self,location: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = location {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"startDancing",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn stop_dancing(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"stopDancing",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn duplicate_allay(&self) 
-> Result<Option<crate::entity::Allay<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Allay;");
let res = self.jni_ref().call_method(&self.jni_object(),"duplicateAllay",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Allay::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn jukebox(&self) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getJukebox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::Inventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::Inventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Creature<'mc>> for Allay<'mc>{

fn into(self) -> crate::entity::Creature<'mc> {

crate::entity::Creature::from_raw(&self.jni_ref(), self.1).expect("Error converting Allay into crate::entity::Creature")

   }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for Allay<'mc>{

fn into(self) -> crate::inventory::InventoryHolder<'mc> {

crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1).expect("Error converting Allay into crate::inventory::InventoryHolder")

   }
}
#[repr(C)]
pub struct ThrownPotion<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ThrownPotion<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ThrownPotion<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ThrownPotion from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ThrownPotion")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ThrownPotion object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ThrownPotion<'mc> {
	pub fn effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item_with_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::ThrowableProjectile<'mc>> for ThrownPotion<'mc>{

fn into(self) -> crate::entity::ThrowableProjectile<'mc> {

crate::entity::ThrowableProjectile::from_raw(&self.jni_ref(), self.1).expect("Error converting ThrownPotion into crate::entity::ThrowableProjectile")

   }
}
pub enum BoatStatus<'mc> {
	InWater {inner: BoatStatusStruct<'mc>},
	UnderWater {inner: BoatStatusStruct<'mc>},
	UnderFlowingWater {inner: BoatStatusStruct<'mc>},
	OnLand {inner: BoatStatusStruct<'mc>},
	InAir {inner: BoatStatusStruct<'mc>},
}
impl<'mc> std::fmt::Display for BoatStatus<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           BoatStatus::InWater { .. } => f.write_str("IN_WATER"),
           BoatStatus::UnderWater { .. } => f.write_str("UNDER_WATER"),
           BoatStatus::UnderFlowingWater { .. } => f.write_str("UNDER_FLOWING_WATER"),
           BoatStatus::OnLand { .. } => f.write_str("ON_LAND"),
           BoatStatus::InAir { .. } => f.write_str("IN_AIR"),
       }
   }
}

        impl<'mc> BoatStatus<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<BoatStatus<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Boat/Status");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Boat/Status;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"IN_WATER" => Ok(BoatStatus::InWater { inner: BoatStatusStruct::from_raw(env,obj)?}),
"UNDER_WATER" => Ok(BoatStatus::UnderWater { inner: BoatStatusStruct::from_raw(env,obj)?}),
"UNDER_FLOWING_WATER" => Ok(BoatStatus::UnderFlowingWater { inner: BoatStatusStruct::from_raw(env,obj)?}),
"ON_LAND" => Ok(BoatStatus::OnLand { inner: BoatStatusStruct::from_raw(env,obj)?}),
"IN_AIR" => Ok(BoatStatus::InAir { inner: BoatStatusStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct BoatStatusStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for BoatStatus<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::InWater { inner } => inner.0.clone(),
Self::UnderWater { inner } => inner.0.clone(),
Self::UnderFlowingWater { inner } => inner.0.clone(),
Self::OnLand { inner } => inner.0.clone(),
Self::InAir { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::InWater { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::UnderWater { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::UnderFlowingWater { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::OnLand { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::InAir { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for BoatStatus<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate BoatStatus from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Boat/Status")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a BoatStatus object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "IN_WATER" => Ok(BoatStatus::InWater { inner: BoatStatusStruct::from_raw(env,obj)?}),"UNDER_WATER" => Ok(BoatStatus::UnderWater { inner: BoatStatusStruct::from_raw(env,obj)?}),"UNDER_FLOWING_WATER" => Ok(BoatStatus::UnderFlowingWater { inner: BoatStatusStruct::from_raw(env,obj)?}),"ON_LAND" => Ok(BoatStatus::OnLand { inner: BoatStatusStruct::from_raw(env,obj)?}),"IN_AIR" => Ok(BoatStatus::InAir { inner: BoatStatusStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for BoatStatusStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for BoatStatusStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate BoatStatusStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Boat/Status")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a BoatStatusStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> BoatStatusStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::BoatStatus<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::BoatStatus;");
let cls = jni.find_class("org/bukkit/entity/Boat/Status"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::BoatStatus::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct PigZombie<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for PigZombie<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for PigZombie<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate PigZombie from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/PigZombie")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a PigZombie object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> PigZombie<'mc> {
	pub fn anger(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAnger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_anger(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setAnger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_angry(&self,angry: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(angry.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAngry",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_angry(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAngry",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_converting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isConverting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn conversion_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getConversionTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_conversion_time(&self,time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(time);
let res = self.jni_ref().call_method(&self.jni_object(),"setConversionTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn is_baby(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isBaby",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_baby(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn is_villager(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVillager",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_villager(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVillager",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_villager_profession(&self,profession: impl Into<crate::entity::VillagerProfession<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Villager/Profession;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(profession.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVillagerProfession",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn villager_profession(&self) 
-> Result<Option<crate::entity::VillagerProfession<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::VillagerProfession;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVillagerProfession",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::VillagerProfession::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn can_break_doors(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canBreakDoors",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_can_break_doors(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanBreakDoors",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Zombie<'mc>> for PigZombie<'mc>{

fn into(self) -> crate::entity::Zombie<'mc> {

crate::entity::Zombie::from_raw(&self.jni_ref(), self.1).expect("Error converting PigZombie into crate::entity::Zombie")

   }
}
#[repr(C)]
pub struct Frog<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Frog<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Frog<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Frog from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Frog")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Frog object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Frog<'mc> {
	pub fn tongue_target(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTongueTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_tongue_target(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTongueTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn variant(&self) 
-> Result<crate::entity::FrogVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::FrogVariant;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVariant",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::FrogVariant::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_variant(&self,variant: impl Into<crate::entity::FrogVariant<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Frog/Variant;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(variant.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVariant",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Frog<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Frog into crate::entity::Animals")

   }
}
#[repr(C)]
pub struct ElderGuardian<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ElderGuardian<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ElderGuardian<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ElderGuardian from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ElderGuardian")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ElderGuardian object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ElderGuardian<'mc> {
	pub fn set_laser(&self,activated: bool) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Z)Lbool;");
let val_1 = jni::objects::JValueGen::Bool(activated.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setLaser",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_laser(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasLaser",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn laser_duration(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLaserDuration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_laser_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLaserTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn laser_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLaserTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
#[deprecated]

	pub fn is_elder(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isElder",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_elder(&self,should_be_elder: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(should_be_elder.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setElder",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_moving(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isMoving",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Guardian<'mc>> for ElderGuardian<'mc>{

fn into(self) -> crate::entity::Guardian<'mc> {

crate::entity::Guardian::from_raw(&self.jni_ref(), self.1).expect("Error converting ElderGuardian into crate::entity::Guardian")

   }
}
#[repr(C)]
pub struct PiglinAbstract<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for PiglinAbstract<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for PiglinAbstract<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate PiglinAbstract from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/PiglinAbstract")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a PiglinAbstract object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> PiglinAbstract<'mc> {
	pub fn is_immune_to_zombification(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isImmuneToZombification",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_immune_to_zombification(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setImmuneToZombification",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn conversion_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getConversionTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_conversion_time(&self,time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(time);
let res = self.jni_ref().call_method(&self.jni_object(),"setConversionTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_converting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isConverting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn is_baby(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isBaby",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_baby_with_flag(&self,flag: std::option::Option<bool>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = flag {
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(a.into());
args.push(val_1);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn age(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAge",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_age(&self,age: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(age);
let res = self.jni_ref().call_method(&self.jni_object(),"setAge",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_age_lock(&self,lock: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(lock.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAgeLock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn age_lock(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAgeLock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_adult(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"setAdult",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_adult(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAdult",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn can_breed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canBreed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_breed(&self,breed: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(breed.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBreed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for PiglinAbstract<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting PiglinAbstract into crate::entity::Monster")

   }
}
impl<'mc> Into<crate::entity::Ageable<'mc>> for PiglinAbstract<'mc>{

fn into(self) -> crate::entity::Ageable<'mc> {

crate::entity::Ageable::from_raw(&self.jni_ref(), self.1).expect("Error converting PiglinAbstract into crate::entity::Ageable")

   }
}
#[repr(C)]
pub struct MagmaCube<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for MagmaCube<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for MagmaCube<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate MagmaCube from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/MagmaCube")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a MagmaCube object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> MagmaCube<'mc> {
	pub fn size(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSize",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_size(&self,sz: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(sz);
let res = self.jni_ref().call_method(&self.jni_object(),"setSize",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Slime<'mc>> for MagmaCube<'mc>{

fn into(self) -> crate::entity::Slime<'mc> {

crate::entity::Slime::from_raw(&self.jni_ref(), self.1).expect("Error converting MagmaCube into crate::entity::Slime")

   }
}
#[repr(C)]
pub struct Arrow<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Arrow<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Arrow<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Arrow from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Arrow")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Arrow object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Arrow<'mc> {
#[deprecated]

	pub fn set_base_potion_data(&self,data: impl Into<crate::potion::PotionData<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionData;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(data.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBasePotionData",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn base_potion_data(&self) 
-> Result<crate::potion::PotionData<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::potion::PotionData;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBasePotionData",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::potion::PotionData::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_base_potion_type(&self,val_type: impl Into<crate::potion::PotionType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBasePotionType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn base_potion_type(&self) 
-> Result<crate::potion::PotionType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::potion::PotionType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBasePotionType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::potion::PotionType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn color(&self) 
-> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Color;");
let res = self.jni_ref().call_method(&self.jni_object(),"getColor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Color::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_color(&self,color: impl Into<crate::Color<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Color;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setColor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_custom_effects(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasCustomEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn custom_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_custom_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,overwrite: bool) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffect;Z)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Bool(overwrite.into());
let res = self.jni_ref().call_method(&self.jni_object(),"addCustomEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_custom_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeCustomEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_custom_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasCustomEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn clear_custom_effects(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"clearCustomEffects",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn knockback_strength(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKnockbackStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_knockback_strength(&self,knockback_strength: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(knockback_strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setKnockbackStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDamage",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(damage);
let res = self.jni_ref().call_method(&self.jni_object(),"setDamage",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn pierce_level(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPierceLevel",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_pierce_level(&self,pierce_level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(pierce_level);
let res = self.jni_ref().call_method(&self.jni_object(),"setPierceLevel",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_critical(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCritical",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_critical(&self,critical: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(critical.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCritical",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_in_block(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInBlock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attached_block(&self) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::Block;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAttachedBlock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn pickup_status(&self) 
-> Result<crate::entity::AbstractArrowPickupStatus<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AbstractArrowPickupStatus;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPickupStatus",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::AbstractArrowPickupStatus::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_pickup_status(&self,status: impl Into<crate::entity::AbstractArrowPickupStatus<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AbstractArrow/PickupStatus;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(status.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPickupStatus",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_shot_from_crossbow(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isShotFromCrossbow",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_shot_from_crossbow(&self,shot_from_crossbow: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(shot_from_crossbow.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setShotFromCrossbow",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::AbstractArrow<'mc>> for Arrow<'mc>{

fn into(self) -> crate::entity::AbstractArrow<'mc> {

crate::entity::AbstractArrow::from_raw(&self.jni_ref(), self.1).expect("Error converting Arrow into crate::entity::AbstractArrow")

   }
}
#[repr(C)]
pub struct Raider<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Raider<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Raider<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Raider from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Raider")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Raider object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Raider<'mc> {
	pub fn set_raid(&self,raid: impl Into<crate::Raid<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Raid;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(raid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn raid(&self) 
-> Result<Option<crate::Raid<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Raid;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Raid::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn wave(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWave",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_wave(&self,wave: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(wave);
let res = self.jni_ref().call_method(&self.jni_object(),"setWave",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn patrol_target(&self) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::Block;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPatrolTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_patrol_target(&self,block: impl Into<crate::block::Block<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/block/Block;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(block.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPatrolTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_patrol_leader(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPatrolLeader",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_patrol_leader(&self,leader: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(leader.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPatrolLeader",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_can_join_raid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCanJoinRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_can_join_raid(&self,join: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(join.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanJoinRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn ticks_outside_raid(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksOutsideRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_outside_raid(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksOutsideRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_celebrating(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCelebrating",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_celebrating(&self,celebrating: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(celebrating.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCelebrating",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn celebration_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCelebrationSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Raider<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Raider into crate::entity::Monster")

   }
}
pub enum Pose<'mc> {
	Standing {inner: PoseStruct<'mc>},
	FallFlying {inner: PoseStruct<'mc>},
	Sleeping {inner: PoseStruct<'mc>},
	Swimming {inner: PoseStruct<'mc>},
	SpinAttack {inner: PoseStruct<'mc>},
	Sneaking {inner: PoseStruct<'mc>},
	LongJumping {inner: PoseStruct<'mc>},
	Dying {inner: PoseStruct<'mc>},
	Croaking {inner: PoseStruct<'mc>},
	UsingTongue {inner: PoseStruct<'mc>},
	Sitting {inner: PoseStruct<'mc>},
	Roaring {inner: PoseStruct<'mc>},
	Sniffing {inner: PoseStruct<'mc>},
	Emerging {inner: PoseStruct<'mc>},
	Digging {inner: PoseStruct<'mc>},
	Sliding {inner: PoseStruct<'mc>},
	Shooting {inner: PoseStruct<'mc>},
	Inhaling {inner: PoseStruct<'mc>},
}
impl<'mc> std::fmt::Display for Pose<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           Pose::Standing { .. } => f.write_str("STANDING"),
           Pose::FallFlying { .. } => f.write_str("FALL_FLYING"),
           Pose::Sleeping { .. } => f.write_str("SLEEPING"),
           Pose::Swimming { .. } => f.write_str("SWIMMING"),
           Pose::SpinAttack { .. } => f.write_str("SPIN_ATTACK"),
           Pose::Sneaking { .. } => f.write_str("SNEAKING"),
           Pose::LongJumping { .. } => f.write_str("LONG_JUMPING"),
           Pose::Dying { .. } => f.write_str("DYING"),
           Pose::Croaking { .. } => f.write_str("CROAKING"),
           Pose::UsingTongue { .. } => f.write_str("USING_TONGUE"),
           Pose::Sitting { .. } => f.write_str("SITTING"),
           Pose::Roaring { .. } => f.write_str("ROARING"),
           Pose::Sniffing { .. } => f.write_str("SNIFFING"),
           Pose::Emerging { .. } => f.write_str("EMERGING"),
           Pose::Digging { .. } => f.write_str("DIGGING"),
           Pose::Sliding { .. } => f.write_str("SLIDING"),
           Pose::Shooting { .. } => f.write_str("SHOOTING"),
           Pose::Inhaling { .. } => f.write_str("INHALING"),
       }
   }
}

        impl<'mc> Pose<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<Pose<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Pose");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Pose;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"STANDING" => Ok(Pose::Standing { inner: PoseStruct::from_raw(env,obj)?}),
"FALL_FLYING" => Ok(Pose::FallFlying { inner: PoseStruct::from_raw(env,obj)?}),
"SLEEPING" => Ok(Pose::Sleeping { inner: PoseStruct::from_raw(env,obj)?}),
"SWIMMING" => Ok(Pose::Swimming { inner: PoseStruct::from_raw(env,obj)?}),
"SPIN_ATTACK" => Ok(Pose::SpinAttack { inner: PoseStruct::from_raw(env,obj)?}),
"SNEAKING" => Ok(Pose::Sneaking { inner: PoseStruct::from_raw(env,obj)?}),
"LONG_JUMPING" => Ok(Pose::LongJumping { inner: PoseStruct::from_raw(env,obj)?}),
"DYING" => Ok(Pose::Dying { inner: PoseStruct::from_raw(env,obj)?}),
"CROAKING" => Ok(Pose::Croaking { inner: PoseStruct::from_raw(env,obj)?}),
"USING_TONGUE" => Ok(Pose::UsingTongue { inner: PoseStruct::from_raw(env,obj)?}),
"SITTING" => Ok(Pose::Sitting { inner: PoseStruct::from_raw(env,obj)?}),
"ROARING" => Ok(Pose::Roaring { inner: PoseStruct::from_raw(env,obj)?}),
"SNIFFING" => Ok(Pose::Sniffing { inner: PoseStruct::from_raw(env,obj)?}),
"EMERGING" => Ok(Pose::Emerging { inner: PoseStruct::from_raw(env,obj)?}),
"DIGGING" => Ok(Pose::Digging { inner: PoseStruct::from_raw(env,obj)?}),
"SLIDING" => Ok(Pose::Sliding { inner: PoseStruct::from_raw(env,obj)?}),
"SHOOTING" => Ok(Pose::Shooting { inner: PoseStruct::from_raw(env,obj)?}),
"INHALING" => Ok(Pose::Inhaling { inner: PoseStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct PoseStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Pose<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Standing { inner } => inner.0.clone(),
Self::FallFlying { inner } => inner.0.clone(),
Self::Sleeping { inner } => inner.0.clone(),
Self::Swimming { inner } => inner.0.clone(),
Self::SpinAttack { inner } => inner.0.clone(),
Self::Sneaking { inner } => inner.0.clone(),
Self::LongJumping { inner } => inner.0.clone(),
Self::Dying { inner } => inner.0.clone(),
Self::Croaking { inner } => inner.0.clone(),
Self::UsingTongue { inner } => inner.0.clone(),
Self::Sitting { inner } => inner.0.clone(),
Self::Roaring { inner } => inner.0.clone(),
Self::Sniffing { inner } => inner.0.clone(),
Self::Emerging { inner } => inner.0.clone(),
Self::Digging { inner } => inner.0.clone(),
Self::Sliding { inner } => inner.0.clone(),
Self::Shooting { inner } => inner.0.clone(),
Self::Inhaling { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Standing { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::FallFlying { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Sleeping { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Swimming { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::SpinAttack { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Sneaking { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::LongJumping { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Dying { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Croaking { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::UsingTongue { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Sitting { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Roaring { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Sniffing { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Emerging { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Digging { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Sliding { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Shooting { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Inhaling { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for Pose<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Pose from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Pose")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Pose object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "STANDING" => Ok(Pose::Standing { inner: PoseStruct::from_raw(env,obj)?}),"FALL_FLYING" => Ok(Pose::FallFlying { inner: PoseStruct::from_raw(env,obj)?}),"SLEEPING" => Ok(Pose::Sleeping { inner: PoseStruct::from_raw(env,obj)?}),"SWIMMING" => Ok(Pose::Swimming { inner: PoseStruct::from_raw(env,obj)?}),"SPIN_ATTACK" => Ok(Pose::SpinAttack { inner: PoseStruct::from_raw(env,obj)?}),"SNEAKING" => Ok(Pose::Sneaking { inner: PoseStruct::from_raw(env,obj)?}),"LONG_JUMPING" => Ok(Pose::LongJumping { inner: PoseStruct::from_raw(env,obj)?}),"DYING" => Ok(Pose::Dying { inner: PoseStruct::from_raw(env,obj)?}),"CROAKING" => Ok(Pose::Croaking { inner: PoseStruct::from_raw(env,obj)?}),"USING_TONGUE" => Ok(Pose::UsingTongue { inner: PoseStruct::from_raw(env,obj)?}),"SITTING" => Ok(Pose::Sitting { inner: PoseStruct::from_raw(env,obj)?}),"ROARING" => Ok(Pose::Roaring { inner: PoseStruct::from_raw(env,obj)?}),"SNIFFING" => Ok(Pose::Sniffing { inner: PoseStruct::from_raw(env,obj)?}),"EMERGING" => Ok(Pose::Emerging { inner: PoseStruct::from_raw(env,obj)?}),"DIGGING" => Ok(Pose::Digging { inner: PoseStruct::from_raw(env,obj)?}),"SLIDING" => Ok(Pose::Sliding { inner: PoseStruct::from_raw(env,obj)?}),"SHOOTING" => Ok(Pose::Shooting { inner: PoseStruct::from_raw(env,obj)?}),"INHALING" => Ok(Pose::Inhaling { inner: PoseStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for PoseStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for PoseStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate PoseStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Pose")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a PoseStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> PoseStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let cls = jni.find_class("org/bukkit/entity/Pose"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::Pose::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Cow<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Cow<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Cow<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Cow from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Cow")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Cow object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Cow<'mc> {
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Cow<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Cow into crate::entity::Animals")

   }
}
#[repr(C)]
pub struct EvokerFangs<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for EvokerFangs<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for EvokerFangs<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EvokerFangs from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EvokerFangs")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EvokerFangs object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> EvokerFangs<'mc> {
	pub fn owner(&self) 
-> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::LivingEntity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOwner",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::LivingEntity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_owner(&self,owner: impl Into<crate::entity::LivingEntity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/LivingEntity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owner.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setOwner",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn attack_delay(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAttackDelay",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_attack_delay(&self,delay: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(delay);
let res = self.jni_ref().call_method(&self.jni_object(),"setAttackDelay",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for EvokerFangs<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting EvokerFangs into crate::entity::Entity")

   }
}
#[repr(C)]
pub struct MushroomCow<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for MushroomCow<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for MushroomCow<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate MushroomCow from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/MushroomCow")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a MushroomCow object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> MushroomCow<'mc> {
	pub fn has_effects_for_next_stew(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasEffectsForNextStew",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn effects_for_next_stew(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEffectsForNextStew",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_effect_to_next_stew(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,overwrite: bool) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffect;Z)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Bool(overwrite.into());
let res = self.jni_ref().call_method(&self.jni_object(),"addEffectToNextStew",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_effect_from_next_stew(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeEffectFromNextStew",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_effect_for_next_stew(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasEffectForNextStew",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn clear_effects_for_next_stew(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"clearEffectsForNextStew",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn variant(&self) 
-> Result<crate::entity::MushroomCowVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::MushroomCowVariant;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVariant",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::MushroomCowVariant::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_variant(&self,variant: impl Into<crate::entity::MushroomCowVariant<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/MushroomCow/Variant;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(variant.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVariant",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Cow<'mc>> for MushroomCow<'mc>{

fn into(self) -> crate::entity::Cow<'mc> {

crate::entity::Cow::from_raw(&self.jni_ref(), self.1).expect("Error converting MushroomCow into crate::entity::Cow")

   }
}
#[repr(C)]
pub struct Cod<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Cod<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Cod<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Cod from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Cod")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Cod object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Cod<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Fish<'mc>> for Cod<'mc>{

fn into(self) -> crate::entity::Fish<'mc> {

crate::entity::Fish::from_raw(&self.jni_ref(), self.1).expect("Error converting Cod into crate::entity::Fish")

   }
}
#[repr(C)]
pub struct SpectralArrow<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for SpectralArrow<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for SpectralArrow<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate SpectralArrow from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SpectralArrow")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a SpectralArrow object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> SpectralArrow<'mc> {
	pub fn glowing_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getGlowingTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_glowing_ticks(&self,duration: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(duration);
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowingTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn knockback_strength(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKnockbackStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_knockback_strength(&self,knockback_strength: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(knockback_strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setKnockbackStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDamage",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(damage);
let res = self.jni_ref().call_method(&self.jni_object(),"setDamage",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn pierce_level(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPierceLevel",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_pierce_level(&self,pierce_level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(pierce_level);
let res = self.jni_ref().call_method(&self.jni_object(),"setPierceLevel",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_critical(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCritical",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_critical(&self,critical: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(critical.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCritical",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_in_block(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInBlock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attached_block(&self) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::Block;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAttachedBlock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn pickup_status(&self) 
-> Result<crate::entity::AbstractArrowPickupStatus<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AbstractArrowPickupStatus;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPickupStatus",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::AbstractArrowPickupStatus::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_pickup_status(&self,status: impl Into<crate::entity::AbstractArrowPickupStatus<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AbstractArrow/PickupStatus;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(status.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPickupStatus",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_shot_from_crossbow(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isShotFromCrossbow",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_shot_from_crossbow(&self,shot_from_crossbow: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(shot_from_crossbow.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setShotFromCrossbow",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::AbstractArrow<'mc>> for SpectralArrow<'mc>{

fn into(self) -> crate::entity::AbstractArrow<'mc> {

crate::entity::AbstractArrow::from_raw(&self.jni_ref(), self.1).expect("Error converting SpectralArrow into crate::entity::AbstractArrow")

   }
}
#[repr(C)]
pub struct TraderLlama<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for TraderLlama<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for TraderLlama<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate TraderLlama from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TraderLlama")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a TraderLlama object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> TraderLlama<'mc> {
	pub fn color(&self) 
-> Result<crate::entity::LlamaColor<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::LlamaColor;");
let res = self.jni_ref().call_method(&self.jni_object(),"getColor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::LlamaColor::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_color(&self,color: impl Into<crate::entity::LlamaColor<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Llama/Color;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setColor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn strength(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_strength(&self,strength: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::LlamaInventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::LlamaInventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::LlamaInventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Llama<'mc>> for TraderLlama<'mc>{

fn into(self) -> crate::entity::Llama<'mc> {

crate::entity::Llama::from_raw(&self.jni_ref(), self.1).expect("Error converting TraderLlama into crate::entity::Llama")

   }
}
pub enum MushroomCowVariant<'mc> {
	Red {inner: MushroomCowVariantStruct<'mc>},
	Brown {inner: MushroomCowVariantStruct<'mc>},
}
impl<'mc> std::fmt::Display for MushroomCowVariant<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           MushroomCowVariant::Red { .. } => f.write_str("RED"),
           MushroomCowVariant::Brown { .. } => f.write_str("BROWN"),
       }
   }
}

        impl<'mc> MushroomCowVariant<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<MushroomCowVariant<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/MushroomCow/Variant");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/MushroomCow/Variant;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"RED" => Ok(MushroomCowVariant::Red { inner: MushroomCowVariantStruct::from_raw(env,obj)?}),
"BROWN" => Ok(MushroomCowVariant::Brown { inner: MushroomCowVariantStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct MushroomCowVariantStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for MushroomCowVariant<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Red { inner } => inner.0.clone(),
Self::Brown { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Red { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Brown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for MushroomCowVariant<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate MushroomCowVariant from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/MushroomCow/Variant")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a MushroomCowVariant object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "RED" => Ok(MushroomCowVariant::Red { inner: MushroomCowVariantStruct::from_raw(env,obj)?}),"BROWN" => Ok(MushroomCowVariant::Brown { inner: MushroomCowVariantStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for MushroomCowVariantStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for MushroomCowVariantStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate MushroomCowVariantStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/MushroomCow/Variant")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a MushroomCowVariantStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> MushroomCowVariantStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::MushroomCowVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::MushroomCowVariant;");
let cls = jni.find_class("org/bukkit/entity/MushroomCow/Variant"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::MushroomCowVariant::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct DisplayBrightness<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for DisplayBrightness<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for DisplayBrightness<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate DisplayBrightness from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Display/Brightness")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a DisplayBrightness object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> DisplayBrightness<'mc> {
	pub fn new(jni: &blackboxmc_general::SharedJNIEnv<'mc>,block_light: i32,sky_light: i32) 
-> Result<crate::entity::DisplayBrightness<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(II)V");
let val_1 = jni::objects::JValueGen::Int(block_light);
let val_2 = jni::objects::JValueGen::Int(sky_light);
let cls = jni.find_class("org/bukkit/entity/Display/Brightness"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.new_object(cls,
sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
jni.translate_error_no_gen(res)?;
crate::entity::DisplayBrightness::from_raw(&jni,res
)}
	pub fn block_light(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBlockLight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn sky_light(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSkyLight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn hash_code(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"hashCode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn equals(&self,obj: jni::objects::JObject<'mc>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/Object;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(obj);
let res = self.jni_ref().call_method(&self.jni_object(),"equals",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[doc(hidden)]
	pub fn internal_to_string(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"toString",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
// SUPER CLASS: Object

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}

        impl<'mc> std::string::ToString for DisplayBrightness<'mc> {
            fn to_string(&self) -> String {
                match &self.internal_to_string() {
                    Ok(a) => a.clone(),
                    Err(err) => format!(
                        "Error calling DisplayBrightness.toString: {}",
                        err
                    ),
                }
            }
        }
        
#[repr(C)]
pub struct Chicken<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Chicken<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Chicken<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Chicken from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Chicken")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Chicken object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Chicken<'mc> {
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Chicken<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Chicken into crate::entity::Animals")

   }
}
#[repr(C)]
pub struct Sniffer<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Sniffer<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Sniffer<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Sniffer from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Sniffer")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Sniffer object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Sniffer<'mc> {
	pub fn explored_locations(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getExploredLocations",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn remove_explored_location(&self,location: impl Into<crate::Location<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeExploredLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn add_explored_location(&self,location: impl Into<crate::Location<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addExploredLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn state(&self) 
-> Result<crate::entity::SnifferState<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SnifferState;");
let res = self.jni_ref().call_method(&self.jni_object(),"getState",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SnifferState::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_state(&self,state: impl Into<crate::entity::SnifferState<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Sniffer/State;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(state.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setState",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn find_possible_dig_location(&self) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"findPossibleDigLocation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn can_dig(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canDig",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Sniffer<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Sniffer into crate::entity::Animals")

   }
}
#[repr(C)]
pub struct Ghast<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Ghast<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Ghast<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Ghast from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ghast")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Ghast object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Ghast<'mc> {
	pub fn is_charging(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCharging",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_charging(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCharging",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Flying<'mc>> for Ghast<'mc>{

fn into(self) -> crate::entity::Flying<'mc> {

crate::entity::Flying::from_raw(&self.jni_ref(), self.1).expect("Error converting Ghast into crate::entity::Flying")

   }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for Ghast<'mc>{

fn into(self) -> crate::entity::Enemy<'mc> {

crate::entity::Enemy::from_raw(&self.jni_ref(), self.1).expect("Error converting Ghast into crate::entity::Enemy")

   }
}
pub enum EntityType<'mc> {
	DroppedItem {inner: EntityTypeStruct<'mc>},
	ExperienceOrb {inner: EntityTypeStruct<'mc>},
	AreaEffectCloud {inner: EntityTypeStruct<'mc>},
	ElderGuardian {inner: EntityTypeStruct<'mc>},
	WitherSkeleton {inner: EntityTypeStruct<'mc>},
	Stray {inner: EntityTypeStruct<'mc>},
	Egg {inner: EntityTypeStruct<'mc>},
	LeashHitch {inner: EntityTypeStruct<'mc>},
	Painting {inner: EntityTypeStruct<'mc>},
	Arrow {inner: EntityTypeStruct<'mc>},
	Snowball {inner: EntityTypeStruct<'mc>},
	Fireball {inner: EntityTypeStruct<'mc>},
	SmallFireball {inner: EntityTypeStruct<'mc>},
	EnderPearl {inner: EntityTypeStruct<'mc>},
	EnderSignal {inner: EntityTypeStruct<'mc>},
	SplashPotion {inner: EntityTypeStruct<'mc>},
	ThrownExpBottle {inner: EntityTypeStruct<'mc>},
	ItemFrame {inner: EntityTypeStruct<'mc>},
	WitherSkull {inner: EntityTypeStruct<'mc>},
	PrimedTnt {inner: EntityTypeStruct<'mc>},
	FallingBlock {inner: EntityTypeStruct<'mc>},
	Firework {inner: EntityTypeStruct<'mc>},
	Husk {inner: EntityTypeStruct<'mc>},
	SpectralArrow {inner: EntityTypeStruct<'mc>},
	ShulkerBullet {inner: EntityTypeStruct<'mc>},
	DragonFireball {inner: EntityTypeStruct<'mc>},
	ZombieVillager {inner: EntityTypeStruct<'mc>},
	SkeletonHorse {inner: EntityTypeStruct<'mc>},
	ZombieHorse {inner: EntityTypeStruct<'mc>},
	ArmorStand {inner: EntityTypeStruct<'mc>},
	Donkey {inner: EntityTypeStruct<'mc>},
	Mule {inner: EntityTypeStruct<'mc>},
	EvokerFangs {inner: EntityTypeStruct<'mc>},
	Evoker {inner: EntityTypeStruct<'mc>},
	Vex {inner: EntityTypeStruct<'mc>},
	Vindicator {inner: EntityTypeStruct<'mc>},
	Illusioner {inner: EntityTypeStruct<'mc>},
	MinecartCommand {inner: EntityTypeStruct<'mc>},
	Boat {inner: EntityTypeStruct<'mc>},
	Minecart {inner: EntityTypeStruct<'mc>},
	MinecartChest {inner: EntityTypeStruct<'mc>},
	MinecartFurnace {inner: EntityTypeStruct<'mc>},
	MinecartTnt {inner: EntityTypeStruct<'mc>},
	MinecartHopper {inner: EntityTypeStruct<'mc>},
	MinecartMobSpawner {inner: EntityTypeStruct<'mc>},
	Creeper {inner: EntityTypeStruct<'mc>},
	Skeleton {inner: EntityTypeStruct<'mc>},
	Spider {inner: EntityTypeStruct<'mc>},
	Giant {inner: EntityTypeStruct<'mc>},
	Zombie {inner: EntityTypeStruct<'mc>},
	Slime {inner: EntityTypeStruct<'mc>},
	Ghast {inner: EntityTypeStruct<'mc>},
	ZombifiedPiglin {inner: EntityTypeStruct<'mc>},
	Enderman {inner: EntityTypeStruct<'mc>},
	CaveSpider {inner: EntityTypeStruct<'mc>},
	Silverfish {inner: EntityTypeStruct<'mc>},
	Blaze {inner: EntityTypeStruct<'mc>},
	MagmaCube {inner: EntityTypeStruct<'mc>},
	EnderDragon {inner: EntityTypeStruct<'mc>},
	Wither {inner: EntityTypeStruct<'mc>},
	Bat {inner: EntityTypeStruct<'mc>},
	Witch {inner: EntityTypeStruct<'mc>},
	Endermite {inner: EntityTypeStruct<'mc>},
	Guardian {inner: EntityTypeStruct<'mc>},
	Shulker {inner: EntityTypeStruct<'mc>},
	Pig {inner: EntityTypeStruct<'mc>},
	Sheep {inner: EntityTypeStruct<'mc>},
	Cow {inner: EntityTypeStruct<'mc>},
	Chicken {inner: EntityTypeStruct<'mc>},
	Squid {inner: EntityTypeStruct<'mc>},
	Wolf {inner: EntityTypeStruct<'mc>},
	MushroomCow {inner: EntityTypeStruct<'mc>},
	Snowman {inner: EntityTypeStruct<'mc>},
	Ocelot {inner: EntityTypeStruct<'mc>},
	IronGolem {inner: EntityTypeStruct<'mc>},
	Horse {inner: EntityTypeStruct<'mc>},
	Rabbit {inner: EntityTypeStruct<'mc>},
	PolarBear {inner: EntityTypeStruct<'mc>},
	Llama {inner: EntityTypeStruct<'mc>},
	LlamaSpit {inner: EntityTypeStruct<'mc>},
	Parrot {inner: EntityTypeStruct<'mc>},
	Villager {inner: EntityTypeStruct<'mc>},
	EnderCrystal {inner: EntityTypeStruct<'mc>},
	Turtle {inner: EntityTypeStruct<'mc>},
	Phantom {inner: EntityTypeStruct<'mc>},
	Trident {inner: EntityTypeStruct<'mc>},
	Cod {inner: EntityTypeStruct<'mc>},
	Salmon {inner: EntityTypeStruct<'mc>},
	Pufferfish {inner: EntityTypeStruct<'mc>},
	TropicalFish {inner: EntityTypeStruct<'mc>},
	Drowned {inner: EntityTypeStruct<'mc>},
	Dolphin {inner: EntityTypeStruct<'mc>},
	Cat {inner: EntityTypeStruct<'mc>},
	Panda {inner: EntityTypeStruct<'mc>},
	Pillager {inner: EntityTypeStruct<'mc>},
	Ravager {inner: EntityTypeStruct<'mc>},
	TraderLlama {inner: EntityTypeStruct<'mc>},
	WanderingTrader {inner: EntityTypeStruct<'mc>},
	Fox {inner: EntityTypeStruct<'mc>},
	Bee {inner: EntityTypeStruct<'mc>},
	Hoglin {inner: EntityTypeStruct<'mc>},
	Piglin {inner: EntityTypeStruct<'mc>},
	Strider {inner: EntityTypeStruct<'mc>},
	Zoglin {inner: EntityTypeStruct<'mc>},
	PiglinBrute {inner: EntityTypeStruct<'mc>},
	Axolotl {inner: EntityTypeStruct<'mc>},
	GlowItemFrame {inner: EntityTypeStruct<'mc>},
	GlowSquid {inner: EntityTypeStruct<'mc>},
	Goat {inner: EntityTypeStruct<'mc>},
	Marker {inner: EntityTypeStruct<'mc>},
	Allay {inner: EntityTypeStruct<'mc>},
	ChestBoat {inner: EntityTypeStruct<'mc>},
	Frog {inner: EntityTypeStruct<'mc>},
	Tadpole {inner: EntityTypeStruct<'mc>},
	Warden {inner: EntityTypeStruct<'mc>},
	Camel {inner: EntityTypeStruct<'mc>},
	BlockDisplay {inner: EntityTypeStruct<'mc>},
	Interaction {inner: EntityTypeStruct<'mc>},
	ItemDisplay {inner: EntityTypeStruct<'mc>},
	Sniffer {inner: EntityTypeStruct<'mc>},
	TextDisplay {inner: EntityTypeStruct<'mc>},
	Breeze {inner: EntityTypeStruct<'mc>},
	WindCharge {inner: EntityTypeStruct<'mc>},
	FishingHook {inner: EntityTypeStruct<'mc>},
	Lightning {inner: EntityTypeStruct<'mc>},
	Player {inner: EntityTypeStruct<'mc>},
	Unknown {inner: EntityTypeStruct<'mc>},
}
impl<'mc> std::fmt::Display for EntityType<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           EntityType::DroppedItem { .. } => f.write_str("DROPPED_ITEM"),
           EntityType::ExperienceOrb { .. } => f.write_str("EXPERIENCE_ORB"),
           EntityType::AreaEffectCloud { .. } => f.write_str("AREA_EFFECT_CLOUD"),
           EntityType::ElderGuardian { .. } => f.write_str("ELDER_GUARDIAN"),
           EntityType::WitherSkeleton { .. } => f.write_str("WITHER_SKELETON"),
           EntityType::Stray { .. } => f.write_str("STRAY"),
           EntityType::Egg { .. } => f.write_str("EGG"),
           EntityType::LeashHitch { .. } => f.write_str("LEASH_HITCH"),
           EntityType::Painting { .. } => f.write_str("PAINTING"),
           EntityType::Arrow { .. } => f.write_str("ARROW"),
           EntityType::Snowball { .. } => f.write_str("SNOWBALL"),
           EntityType::Fireball { .. } => f.write_str("FIREBALL"),
           EntityType::SmallFireball { .. } => f.write_str("SMALL_FIREBALL"),
           EntityType::EnderPearl { .. } => f.write_str("ENDER_PEARL"),
           EntityType::EnderSignal { .. } => f.write_str("ENDER_SIGNAL"),
           EntityType::SplashPotion { .. } => f.write_str("SPLASH_POTION"),
           EntityType::ThrownExpBottle { .. } => f.write_str("THROWN_EXP_BOTTLE"),
           EntityType::ItemFrame { .. } => f.write_str("ITEM_FRAME"),
           EntityType::WitherSkull { .. } => f.write_str("WITHER_SKULL"),
           EntityType::PrimedTnt { .. } => f.write_str("PRIMED_TNT"),
           EntityType::FallingBlock { .. } => f.write_str("FALLING_BLOCK"),
           EntityType::Firework { .. } => f.write_str("FIREWORK"),
           EntityType::Husk { .. } => f.write_str("HUSK"),
           EntityType::SpectralArrow { .. } => f.write_str("SPECTRAL_ARROW"),
           EntityType::ShulkerBullet { .. } => f.write_str("SHULKER_BULLET"),
           EntityType::DragonFireball { .. } => f.write_str("DRAGON_FIREBALL"),
           EntityType::ZombieVillager { .. } => f.write_str("ZOMBIE_VILLAGER"),
           EntityType::SkeletonHorse { .. } => f.write_str("SKELETON_HORSE"),
           EntityType::ZombieHorse { .. } => f.write_str("ZOMBIE_HORSE"),
           EntityType::ArmorStand { .. } => f.write_str("ARMOR_STAND"),
           EntityType::Donkey { .. } => f.write_str("DONKEY"),
           EntityType::Mule { .. } => f.write_str("MULE"),
           EntityType::EvokerFangs { .. } => f.write_str("EVOKER_FANGS"),
           EntityType::Evoker { .. } => f.write_str("EVOKER"),
           EntityType::Vex { .. } => f.write_str("VEX"),
           EntityType::Vindicator { .. } => f.write_str("VINDICATOR"),
           EntityType::Illusioner { .. } => f.write_str("ILLUSIONER"),
           EntityType::MinecartCommand { .. } => f.write_str("MINECART_COMMAND"),
           EntityType::Boat { .. } => f.write_str("BOAT"),
           EntityType::Minecart { .. } => f.write_str("MINECART"),
           EntityType::MinecartChest { .. } => f.write_str("MINECART_CHEST"),
           EntityType::MinecartFurnace { .. } => f.write_str("MINECART_FURNACE"),
           EntityType::MinecartTnt { .. } => f.write_str("MINECART_TNT"),
           EntityType::MinecartHopper { .. } => f.write_str("MINECART_HOPPER"),
           EntityType::MinecartMobSpawner { .. } => f.write_str("MINECART_MOB_SPAWNER"),
           EntityType::Creeper { .. } => f.write_str("CREEPER"),
           EntityType::Skeleton { .. } => f.write_str("SKELETON"),
           EntityType::Spider { .. } => f.write_str("SPIDER"),
           EntityType::Giant { .. } => f.write_str("GIANT"),
           EntityType::Zombie { .. } => f.write_str("ZOMBIE"),
           EntityType::Slime { .. } => f.write_str("SLIME"),
           EntityType::Ghast { .. } => f.write_str("GHAST"),
           EntityType::ZombifiedPiglin { .. } => f.write_str("ZOMBIFIED_PIGLIN"),
           EntityType::Enderman { .. } => f.write_str("ENDERMAN"),
           EntityType::CaveSpider { .. } => f.write_str("CAVE_SPIDER"),
           EntityType::Silverfish { .. } => f.write_str("SILVERFISH"),
           EntityType::Blaze { .. } => f.write_str("BLAZE"),
           EntityType::MagmaCube { .. } => f.write_str("MAGMA_CUBE"),
           EntityType::EnderDragon { .. } => f.write_str("ENDER_DRAGON"),
           EntityType::Wither { .. } => f.write_str("WITHER"),
           EntityType::Bat { .. } => f.write_str("BAT"),
           EntityType::Witch { .. } => f.write_str("WITCH"),
           EntityType::Endermite { .. } => f.write_str("ENDERMITE"),
           EntityType::Guardian { .. } => f.write_str("GUARDIAN"),
           EntityType::Shulker { .. } => f.write_str("SHULKER"),
           EntityType::Pig { .. } => f.write_str("PIG"),
           EntityType::Sheep { .. } => f.write_str("SHEEP"),
           EntityType::Cow { .. } => f.write_str("COW"),
           EntityType::Chicken { .. } => f.write_str("CHICKEN"),
           EntityType::Squid { .. } => f.write_str("SQUID"),
           EntityType::Wolf { .. } => f.write_str("WOLF"),
           EntityType::MushroomCow { .. } => f.write_str("MUSHROOM_COW"),
           EntityType::Snowman { .. } => f.write_str("SNOWMAN"),
           EntityType::Ocelot { .. } => f.write_str("OCELOT"),
           EntityType::IronGolem { .. } => f.write_str("IRON_GOLEM"),
           EntityType::Horse { .. } => f.write_str("HORSE"),
           EntityType::Rabbit { .. } => f.write_str("RABBIT"),
           EntityType::PolarBear { .. } => f.write_str("POLAR_BEAR"),
           EntityType::Llama { .. } => f.write_str("LLAMA"),
           EntityType::LlamaSpit { .. } => f.write_str("LLAMA_SPIT"),
           EntityType::Parrot { .. } => f.write_str("PARROT"),
           EntityType::Villager { .. } => f.write_str("VILLAGER"),
           EntityType::EnderCrystal { .. } => f.write_str("ENDER_CRYSTAL"),
           EntityType::Turtle { .. } => f.write_str("TURTLE"),
           EntityType::Phantom { .. } => f.write_str("PHANTOM"),
           EntityType::Trident { .. } => f.write_str("TRIDENT"),
           EntityType::Cod { .. } => f.write_str("COD"),
           EntityType::Salmon { .. } => f.write_str("SALMON"),
           EntityType::Pufferfish { .. } => f.write_str("PUFFERFISH"),
           EntityType::TropicalFish { .. } => f.write_str("TROPICAL_FISH"),
           EntityType::Drowned { .. } => f.write_str("DROWNED"),
           EntityType::Dolphin { .. } => f.write_str("DOLPHIN"),
           EntityType::Cat { .. } => f.write_str("CAT"),
           EntityType::Panda { .. } => f.write_str("PANDA"),
           EntityType::Pillager { .. } => f.write_str("PILLAGER"),
           EntityType::Ravager { .. } => f.write_str("RAVAGER"),
           EntityType::TraderLlama { .. } => f.write_str("TRADER_LLAMA"),
           EntityType::WanderingTrader { .. } => f.write_str("WANDERING_TRADER"),
           EntityType::Fox { .. } => f.write_str("FOX"),
           EntityType::Bee { .. } => f.write_str("BEE"),
           EntityType::Hoglin { .. } => f.write_str("HOGLIN"),
           EntityType::Piglin { .. } => f.write_str("PIGLIN"),
           EntityType::Strider { .. } => f.write_str("STRIDER"),
           EntityType::Zoglin { .. } => f.write_str("ZOGLIN"),
           EntityType::PiglinBrute { .. } => f.write_str("PIGLIN_BRUTE"),
           EntityType::Axolotl { .. } => f.write_str("AXOLOTL"),
           EntityType::GlowItemFrame { .. } => f.write_str("GLOW_ITEM_FRAME"),
           EntityType::GlowSquid { .. } => f.write_str("GLOW_SQUID"),
           EntityType::Goat { .. } => f.write_str("GOAT"),
           EntityType::Marker { .. } => f.write_str("MARKER"),
           EntityType::Allay { .. } => f.write_str("ALLAY"),
           EntityType::ChestBoat { .. } => f.write_str("CHEST_BOAT"),
           EntityType::Frog { .. } => f.write_str("FROG"),
           EntityType::Tadpole { .. } => f.write_str("TADPOLE"),
           EntityType::Warden { .. } => f.write_str("WARDEN"),
           EntityType::Camel { .. } => f.write_str("CAMEL"),
           EntityType::BlockDisplay { .. } => f.write_str("BLOCK_DISPLAY"),
           EntityType::Interaction { .. } => f.write_str("INTERACTION"),
           EntityType::ItemDisplay { .. } => f.write_str("ITEM_DISPLAY"),
           EntityType::Sniffer { .. } => f.write_str("SNIFFER"),
           EntityType::TextDisplay { .. } => f.write_str("TEXT_DISPLAY"),
           EntityType::Breeze { .. } => f.write_str("BREEZE"),
           EntityType::WindCharge { .. } => f.write_str("WIND_CHARGE"),
           EntityType::FishingHook { .. } => f.write_str("FISHING_HOOK"),
           EntityType::Lightning { .. } => f.write_str("LIGHTNING"),
           EntityType::Player { .. } => f.write_str("PLAYER"),
           EntityType::Unknown { .. } => f.write_str("UNKNOWN"),
       }
   }
}

        impl<'mc> EntityType<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<EntityType<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/EntityType");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/EntityType;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"DROPPED_ITEM" => Ok(EntityType::DroppedItem { inner: EntityTypeStruct::from_raw(env,obj)?}),
"EXPERIENCE_ORB" => Ok(EntityType::ExperienceOrb { inner: EntityTypeStruct::from_raw(env,obj)?}),
"AREA_EFFECT_CLOUD" => Ok(EntityType::AreaEffectCloud { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ELDER_GUARDIAN" => Ok(EntityType::ElderGuardian { inner: EntityTypeStruct::from_raw(env,obj)?}),
"WITHER_SKELETON" => Ok(EntityType::WitherSkeleton { inner: EntityTypeStruct::from_raw(env,obj)?}),
"STRAY" => Ok(EntityType::Stray { inner: EntityTypeStruct::from_raw(env,obj)?}),
"EGG" => Ok(EntityType::Egg { inner: EntityTypeStruct::from_raw(env,obj)?}),
"LEASH_HITCH" => Ok(EntityType::LeashHitch { inner: EntityTypeStruct::from_raw(env,obj)?}),
"PAINTING" => Ok(EntityType::Painting { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ARROW" => Ok(EntityType::Arrow { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SNOWBALL" => Ok(EntityType::Snowball { inner: EntityTypeStruct::from_raw(env,obj)?}),
"FIREBALL" => Ok(EntityType::Fireball { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SMALL_FIREBALL" => Ok(EntityType::SmallFireball { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ENDER_PEARL" => Ok(EntityType::EnderPearl { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ENDER_SIGNAL" => Ok(EntityType::EnderSignal { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SPLASH_POTION" => Ok(EntityType::SplashPotion { inner: EntityTypeStruct::from_raw(env,obj)?}),
"THROWN_EXP_BOTTLE" => Ok(EntityType::ThrownExpBottle { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ITEM_FRAME" => Ok(EntityType::ItemFrame { inner: EntityTypeStruct::from_raw(env,obj)?}),
"WITHER_SKULL" => Ok(EntityType::WitherSkull { inner: EntityTypeStruct::from_raw(env,obj)?}),
"PRIMED_TNT" => Ok(EntityType::PrimedTnt { inner: EntityTypeStruct::from_raw(env,obj)?}),
"FALLING_BLOCK" => Ok(EntityType::FallingBlock { inner: EntityTypeStruct::from_raw(env,obj)?}),
"FIREWORK" => Ok(EntityType::Firework { inner: EntityTypeStruct::from_raw(env,obj)?}),
"HUSK" => Ok(EntityType::Husk { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SPECTRAL_ARROW" => Ok(EntityType::SpectralArrow { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SHULKER_BULLET" => Ok(EntityType::ShulkerBullet { inner: EntityTypeStruct::from_raw(env,obj)?}),
"DRAGON_FIREBALL" => Ok(EntityType::DragonFireball { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ZOMBIE_VILLAGER" => Ok(EntityType::ZombieVillager { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SKELETON_HORSE" => Ok(EntityType::SkeletonHorse { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ZOMBIE_HORSE" => Ok(EntityType::ZombieHorse { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ARMOR_STAND" => Ok(EntityType::ArmorStand { inner: EntityTypeStruct::from_raw(env,obj)?}),
"DONKEY" => Ok(EntityType::Donkey { inner: EntityTypeStruct::from_raw(env,obj)?}),
"MULE" => Ok(EntityType::Mule { inner: EntityTypeStruct::from_raw(env,obj)?}),
"EVOKER_FANGS" => Ok(EntityType::EvokerFangs { inner: EntityTypeStruct::from_raw(env,obj)?}),
"EVOKER" => Ok(EntityType::Evoker { inner: EntityTypeStruct::from_raw(env,obj)?}),
"VEX" => Ok(EntityType::Vex { inner: EntityTypeStruct::from_raw(env,obj)?}),
"VINDICATOR" => Ok(EntityType::Vindicator { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ILLUSIONER" => Ok(EntityType::Illusioner { inner: EntityTypeStruct::from_raw(env,obj)?}),
"MINECART_COMMAND" => Ok(EntityType::MinecartCommand { inner: EntityTypeStruct::from_raw(env,obj)?}),
"BOAT" => Ok(EntityType::Boat { inner: EntityTypeStruct::from_raw(env,obj)?}),
"MINECART" => Ok(EntityType::Minecart { inner: EntityTypeStruct::from_raw(env,obj)?}),
"MINECART_CHEST" => Ok(EntityType::MinecartChest { inner: EntityTypeStruct::from_raw(env,obj)?}),
"MINECART_FURNACE" => Ok(EntityType::MinecartFurnace { inner: EntityTypeStruct::from_raw(env,obj)?}),
"MINECART_TNT" => Ok(EntityType::MinecartTnt { inner: EntityTypeStruct::from_raw(env,obj)?}),
"MINECART_HOPPER" => Ok(EntityType::MinecartHopper { inner: EntityTypeStruct::from_raw(env,obj)?}),
"MINECART_MOB_SPAWNER" => Ok(EntityType::MinecartMobSpawner { inner: EntityTypeStruct::from_raw(env,obj)?}),
"CREEPER" => Ok(EntityType::Creeper { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SKELETON" => Ok(EntityType::Skeleton { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SPIDER" => Ok(EntityType::Spider { inner: EntityTypeStruct::from_raw(env,obj)?}),
"GIANT" => Ok(EntityType::Giant { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ZOMBIE" => Ok(EntityType::Zombie { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SLIME" => Ok(EntityType::Slime { inner: EntityTypeStruct::from_raw(env,obj)?}),
"GHAST" => Ok(EntityType::Ghast { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ZOMBIFIED_PIGLIN" => Ok(EntityType::ZombifiedPiglin { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ENDERMAN" => Ok(EntityType::Enderman { inner: EntityTypeStruct::from_raw(env,obj)?}),
"CAVE_SPIDER" => Ok(EntityType::CaveSpider { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SILVERFISH" => Ok(EntityType::Silverfish { inner: EntityTypeStruct::from_raw(env,obj)?}),
"BLAZE" => Ok(EntityType::Blaze { inner: EntityTypeStruct::from_raw(env,obj)?}),
"MAGMA_CUBE" => Ok(EntityType::MagmaCube { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ENDER_DRAGON" => Ok(EntityType::EnderDragon { inner: EntityTypeStruct::from_raw(env,obj)?}),
"WITHER" => Ok(EntityType::Wither { inner: EntityTypeStruct::from_raw(env,obj)?}),
"BAT" => Ok(EntityType::Bat { inner: EntityTypeStruct::from_raw(env,obj)?}),
"WITCH" => Ok(EntityType::Witch { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ENDERMITE" => Ok(EntityType::Endermite { inner: EntityTypeStruct::from_raw(env,obj)?}),
"GUARDIAN" => Ok(EntityType::Guardian { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SHULKER" => Ok(EntityType::Shulker { inner: EntityTypeStruct::from_raw(env,obj)?}),
"PIG" => Ok(EntityType::Pig { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SHEEP" => Ok(EntityType::Sheep { inner: EntityTypeStruct::from_raw(env,obj)?}),
"COW" => Ok(EntityType::Cow { inner: EntityTypeStruct::from_raw(env,obj)?}),
"CHICKEN" => Ok(EntityType::Chicken { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SQUID" => Ok(EntityType::Squid { inner: EntityTypeStruct::from_raw(env,obj)?}),
"WOLF" => Ok(EntityType::Wolf { inner: EntityTypeStruct::from_raw(env,obj)?}),
"MUSHROOM_COW" => Ok(EntityType::MushroomCow { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SNOWMAN" => Ok(EntityType::Snowman { inner: EntityTypeStruct::from_raw(env,obj)?}),
"OCELOT" => Ok(EntityType::Ocelot { inner: EntityTypeStruct::from_raw(env,obj)?}),
"IRON_GOLEM" => Ok(EntityType::IronGolem { inner: EntityTypeStruct::from_raw(env,obj)?}),
"HORSE" => Ok(EntityType::Horse { inner: EntityTypeStruct::from_raw(env,obj)?}),
"RABBIT" => Ok(EntityType::Rabbit { inner: EntityTypeStruct::from_raw(env,obj)?}),
"POLAR_BEAR" => Ok(EntityType::PolarBear { inner: EntityTypeStruct::from_raw(env,obj)?}),
"LLAMA" => Ok(EntityType::Llama { inner: EntityTypeStruct::from_raw(env,obj)?}),
"LLAMA_SPIT" => Ok(EntityType::LlamaSpit { inner: EntityTypeStruct::from_raw(env,obj)?}),
"PARROT" => Ok(EntityType::Parrot { inner: EntityTypeStruct::from_raw(env,obj)?}),
"VILLAGER" => Ok(EntityType::Villager { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ENDER_CRYSTAL" => Ok(EntityType::EnderCrystal { inner: EntityTypeStruct::from_raw(env,obj)?}),
"TURTLE" => Ok(EntityType::Turtle { inner: EntityTypeStruct::from_raw(env,obj)?}),
"PHANTOM" => Ok(EntityType::Phantom { inner: EntityTypeStruct::from_raw(env,obj)?}),
"TRIDENT" => Ok(EntityType::Trident { inner: EntityTypeStruct::from_raw(env,obj)?}),
"COD" => Ok(EntityType::Cod { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SALMON" => Ok(EntityType::Salmon { inner: EntityTypeStruct::from_raw(env,obj)?}),
"PUFFERFISH" => Ok(EntityType::Pufferfish { inner: EntityTypeStruct::from_raw(env,obj)?}),
"TROPICAL_FISH" => Ok(EntityType::TropicalFish { inner: EntityTypeStruct::from_raw(env,obj)?}),
"DROWNED" => Ok(EntityType::Drowned { inner: EntityTypeStruct::from_raw(env,obj)?}),
"DOLPHIN" => Ok(EntityType::Dolphin { inner: EntityTypeStruct::from_raw(env,obj)?}),
"CAT" => Ok(EntityType::Cat { inner: EntityTypeStruct::from_raw(env,obj)?}),
"PANDA" => Ok(EntityType::Panda { inner: EntityTypeStruct::from_raw(env,obj)?}),
"PILLAGER" => Ok(EntityType::Pillager { inner: EntityTypeStruct::from_raw(env,obj)?}),
"RAVAGER" => Ok(EntityType::Ravager { inner: EntityTypeStruct::from_raw(env,obj)?}),
"TRADER_LLAMA" => Ok(EntityType::TraderLlama { inner: EntityTypeStruct::from_raw(env,obj)?}),
"WANDERING_TRADER" => Ok(EntityType::WanderingTrader { inner: EntityTypeStruct::from_raw(env,obj)?}),
"FOX" => Ok(EntityType::Fox { inner: EntityTypeStruct::from_raw(env,obj)?}),
"BEE" => Ok(EntityType::Bee { inner: EntityTypeStruct::from_raw(env,obj)?}),
"HOGLIN" => Ok(EntityType::Hoglin { inner: EntityTypeStruct::from_raw(env,obj)?}),
"PIGLIN" => Ok(EntityType::Piglin { inner: EntityTypeStruct::from_raw(env,obj)?}),
"STRIDER" => Ok(EntityType::Strider { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ZOGLIN" => Ok(EntityType::Zoglin { inner: EntityTypeStruct::from_raw(env,obj)?}),
"PIGLIN_BRUTE" => Ok(EntityType::PiglinBrute { inner: EntityTypeStruct::from_raw(env,obj)?}),
"AXOLOTL" => Ok(EntityType::Axolotl { inner: EntityTypeStruct::from_raw(env,obj)?}),
"GLOW_ITEM_FRAME" => Ok(EntityType::GlowItemFrame { inner: EntityTypeStruct::from_raw(env,obj)?}),
"GLOW_SQUID" => Ok(EntityType::GlowSquid { inner: EntityTypeStruct::from_raw(env,obj)?}),
"GOAT" => Ok(EntityType::Goat { inner: EntityTypeStruct::from_raw(env,obj)?}),
"MARKER" => Ok(EntityType::Marker { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ALLAY" => Ok(EntityType::Allay { inner: EntityTypeStruct::from_raw(env,obj)?}),
"CHEST_BOAT" => Ok(EntityType::ChestBoat { inner: EntityTypeStruct::from_raw(env,obj)?}),
"FROG" => Ok(EntityType::Frog { inner: EntityTypeStruct::from_raw(env,obj)?}),
"TADPOLE" => Ok(EntityType::Tadpole { inner: EntityTypeStruct::from_raw(env,obj)?}),
"WARDEN" => Ok(EntityType::Warden { inner: EntityTypeStruct::from_raw(env,obj)?}),
"CAMEL" => Ok(EntityType::Camel { inner: EntityTypeStruct::from_raw(env,obj)?}),
"BLOCK_DISPLAY" => Ok(EntityType::BlockDisplay { inner: EntityTypeStruct::from_raw(env,obj)?}),
"INTERACTION" => Ok(EntityType::Interaction { inner: EntityTypeStruct::from_raw(env,obj)?}),
"ITEM_DISPLAY" => Ok(EntityType::ItemDisplay { inner: EntityTypeStruct::from_raw(env,obj)?}),
"SNIFFER" => Ok(EntityType::Sniffer { inner: EntityTypeStruct::from_raw(env,obj)?}),
"TEXT_DISPLAY" => Ok(EntityType::TextDisplay { inner: EntityTypeStruct::from_raw(env,obj)?}),
"BREEZE" => Ok(EntityType::Breeze { inner: EntityTypeStruct::from_raw(env,obj)?}),
"WIND_CHARGE" => Ok(EntityType::WindCharge { inner: EntityTypeStruct::from_raw(env,obj)?}),
"FISHING_HOOK" => Ok(EntityType::FishingHook { inner: EntityTypeStruct::from_raw(env,obj)?}),
"LIGHTNING" => Ok(EntityType::Lightning { inner: EntityTypeStruct::from_raw(env,obj)?}),
"PLAYER" => Ok(EntityType::Player { inner: EntityTypeStruct::from_raw(env,obj)?}),
"UNKNOWN" => Ok(EntityType::Unknown { inner: EntityTypeStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct EntityTypeStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for EntityType<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::DroppedItem { inner } => inner.0.clone(),
Self::ExperienceOrb { inner } => inner.0.clone(),
Self::AreaEffectCloud { inner } => inner.0.clone(),
Self::ElderGuardian { inner } => inner.0.clone(),
Self::WitherSkeleton { inner } => inner.0.clone(),
Self::Stray { inner } => inner.0.clone(),
Self::Egg { inner } => inner.0.clone(),
Self::LeashHitch { inner } => inner.0.clone(),
Self::Painting { inner } => inner.0.clone(),
Self::Arrow { inner } => inner.0.clone(),
Self::Snowball { inner } => inner.0.clone(),
Self::Fireball { inner } => inner.0.clone(),
Self::SmallFireball { inner } => inner.0.clone(),
Self::EnderPearl { inner } => inner.0.clone(),
Self::EnderSignal { inner } => inner.0.clone(),
Self::SplashPotion { inner } => inner.0.clone(),
Self::ThrownExpBottle { inner } => inner.0.clone(),
Self::ItemFrame { inner } => inner.0.clone(),
Self::WitherSkull { inner } => inner.0.clone(),
Self::PrimedTnt { inner } => inner.0.clone(),
Self::FallingBlock { inner } => inner.0.clone(),
Self::Firework { inner } => inner.0.clone(),
Self::Husk { inner } => inner.0.clone(),
Self::SpectralArrow { inner } => inner.0.clone(),
Self::ShulkerBullet { inner } => inner.0.clone(),
Self::DragonFireball { inner } => inner.0.clone(),
Self::ZombieVillager { inner } => inner.0.clone(),
Self::SkeletonHorse { inner } => inner.0.clone(),
Self::ZombieHorse { inner } => inner.0.clone(),
Self::ArmorStand { inner } => inner.0.clone(),
Self::Donkey { inner } => inner.0.clone(),
Self::Mule { inner } => inner.0.clone(),
Self::EvokerFangs { inner } => inner.0.clone(),
Self::Evoker { inner } => inner.0.clone(),
Self::Vex { inner } => inner.0.clone(),
Self::Vindicator { inner } => inner.0.clone(),
Self::Illusioner { inner } => inner.0.clone(),
Self::MinecartCommand { inner } => inner.0.clone(),
Self::Boat { inner } => inner.0.clone(),
Self::Minecart { inner } => inner.0.clone(),
Self::MinecartChest { inner } => inner.0.clone(),
Self::MinecartFurnace { inner } => inner.0.clone(),
Self::MinecartTnt { inner } => inner.0.clone(),
Self::MinecartHopper { inner } => inner.0.clone(),
Self::MinecartMobSpawner { inner } => inner.0.clone(),
Self::Creeper { inner } => inner.0.clone(),
Self::Skeleton { inner } => inner.0.clone(),
Self::Spider { inner } => inner.0.clone(),
Self::Giant { inner } => inner.0.clone(),
Self::Zombie { inner } => inner.0.clone(),
Self::Slime { inner } => inner.0.clone(),
Self::Ghast { inner } => inner.0.clone(),
Self::ZombifiedPiglin { inner } => inner.0.clone(),
Self::Enderman { inner } => inner.0.clone(),
Self::CaveSpider { inner } => inner.0.clone(),
Self::Silverfish { inner } => inner.0.clone(),
Self::Blaze { inner } => inner.0.clone(),
Self::MagmaCube { inner } => inner.0.clone(),
Self::EnderDragon { inner } => inner.0.clone(),
Self::Wither { inner } => inner.0.clone(),
Self::Bat { inner } => inner.0.clone(),
Self::Witch { inner } => inner.0.clone(),
Self::Endermite { inner } => inner.0.clone(),
Self::Guardian { inner } => inner.0.clone(),
Self::Shulker { inner } => inner.0.clone(),
Self::Pig { inner } => inner.0.clone(),
Self::Sheep { inner } => inner.0.clone(),
Self::Cow { inner } => inner.0.clone(),
Self::Chicken { inner } => inner.0.clone(),
Self::Squid { inner } => inner.0.clone(),
Self::Wolf { inner } => inner.0.clone(),
Self::MushroomCow { inner } => inner.0.clone(),
Self::Snowman { inner } => inner.0.clone(),
Self::Ocelot { inner } => inner.0.clone(),
Self::IronGolem { inner } => inner.0.clone(),
Self::Horse { inner } => inner.0.clone(),
Self::Rabbit { inner } => inner.0.clone(),
Self::PolarBear { inner } => inner.0.clone(),
Self::Llama { inner } => inner.0.clone(),
Self::LlamaSpit { inner } => inner.0.clone(),
Self::Parrot { inner } => inner.0.clone(),
Self::Villager { inner } => inner.0.clone(),
Self::EnderCrystal { inner } => inner.0.clone(),
Self::Turtle { inner } => inner.0.clone(),
Self::Phantom { inner } => inner.0.clone(),
Self::Trident { inner } => inner.0.clone(),
Self::Cod { inner } => inner.0.clone(),
Self::Salmon { inner } => inner.0.clone(),
Self::Pufferfish { inner } => inner.0.clone(),
Self::TropicalFish { inner } => inner.0.clone(),
Self::Drowned { inner } => inner.0.clone(),
Self::Dolphin { inner } => inner.0.clone(),
Self::Cat { inner } => inner.0.clone(),
Self::Panda { inner } => inner.0.clone(),
Self::Pillager { inner } => inner.0.clone(),
Self::Ravager { inner } => inner.0.clone(),
Self::TraderLlama { inner } => inner.0.clone(),
Self::WanderingTrader { inner } => inner.0.clone(),
Self::Fox { inner } => inner.0.clone(),
Self::Bee { inner } => inner.0.clone(),
Self::Hoglin { inner } => inner.0.clone(),
Self::Piglin { inner } => inner.0.clone(),
Self::Strider { inner } => inner.0.clone(),
Self::Zoglin { inner } => inner.0.clone(),
Self::PiglinBrute { inner } => inner.0.clone(),
Self::Axolotl { inner } => inner.0.clone(),
Self::GlowItemFrame { inner } => inner.0.clone(),
Self::GlowSquid { inner } => inner.0.clone(),
Self::Goat { inner } => inner.0.clone(),
Self::Marker { inner } => inner.0.clone(),
Self::Allay { inner } => inner.0.clone(),
Self::ChestBoat { inner } => inner.0.clone(),
Self::Frog { inner } => inner.0.clone(),
Self::Tadpole { inner } => inner.0.clone(),
Self::Warden { inner } => inner.0.clone(),
Self::Camel { inner } => inner.0.clone(),
Self::BlockDisplay { inner } => inner.0.clone(),
Self::Interaction { inner } => inner.0.clone(),
Self::ItemDisplay { inner } => inner.0.clone(),
Self::Sniffer { inner } => inner.0.clone(),
Self::TextDisplay { inner } => inner.0.clone(),
Self::Breeze { inner } => inner.0.clone(),
Self::WindCharge { inner } => inner.0.clone(),
Self::FishingHook { inner } => inner.0.clone(),
Self::Lightning { inner } => inner.0.clone(),
Self::Player { inner } => inner.0.clone(),
Self::Unknown { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::DroppedItem { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ExperienceOrb { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::AreaEffectCloud { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ElderGuardian { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::WitherSkeleton { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Stray { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Egg { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::LeashHitch { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Painting { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Arrow { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Snowball { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Fireball { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::SmallFireball { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::EnderPearl { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::EnderSignal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::SplashPotion { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ThrownExpBottle { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ItemFrame { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::WitherSkull { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::PrimedTnt { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::FallingBlock { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Firework { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Husk { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::SpectralArrow { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ShulkerBullet { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::DragonFireball { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ZombieVillager { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::SkeletonHorse { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ZombieHorse { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ArmorStand { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Donkey { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Mule { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::EvokerFangs { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Evoker { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Vex { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Vindicator { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Illusioner { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::MinecartCommand { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Boat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Minecart { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::MinecartChest { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::MinecartFurnace { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::MinecartTnt { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::MinecartHopper { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::MinecartMobSpawner { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Creeper { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Skeleton { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Spider { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Giant { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Zombie { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Slime { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Ghast { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ZombifiedPiglin { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Enderman { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::CaveSpider { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Silverfish { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Blaze { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::MagmaCube { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::EnderDragon { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Wither { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Bat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Witch { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Endermite { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Guardian { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Shulker { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Pig { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Sheep { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Cow { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Chicken { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Squid { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Wolf { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::MushroomCow { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Snowman { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Ocelot { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::IronGolem { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Horse { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Rabbit { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::PolarBear { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Llama { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::LlamaSpit { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Parrot { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Villager { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::EnderCrystal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Turtle { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Phantom { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Trident { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Cod { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Salmon { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Pufferfish { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::TropicalFish { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Drowned { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Dolphin { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Cat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Panda { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Pillager { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Ravager { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::TraderLlama { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::WanderingTrader { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Fox { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Bee { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Hoglin { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Piglin { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Strider { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Zoglin { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::PiglinBrute { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Axolotl { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::GlowItemFrame { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::GlowSquid { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Goat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Marker { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Allay { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ChestBoat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Frog { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Tadpole { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Warden { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Camel { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::BlockDisplay { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Interaction { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ItemDisplay { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Sniffer { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::TextDisplay { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Breeze { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::WindCharge { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::FishingHook { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Lightning { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Player { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Unknown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for EntityType<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EntityType from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EntityType")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EntityType object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "DROPPED_ITEM" => Ok(EntityType::DroppedItem { inner: EntityTypeStruct::from_raw(env,obj)?}),"EXPERIENCE_ORB" => Ok(EntityType::ExperienceOrb { inner: EntityTypeStruct::from_raw(env,obj)?}),"AREA_EFFECT_CLOUD" => Ok(EntityType::AreaEffectCloud { inner: EntityTypeStruct::from_raw(env,obj)?}),"ELDER_GUARDIAN" => Ok(EntityType::ElderGuardian { inner: EntityTypeStruct::from_raw(env,obj)?}),"WITHER_SKELETON" => Ok(EntityType::WitherSkeleton { inner: EntityTypeStruct::from_raw(env,obj)?}),"STRAY" => Ok(EntityType::Stray { inner: EntityTypeStruct::from_raw(env,obj)?}),"EGG" => Ok(EntityType::Egg { inner: EntityTypeStruct::from_raw(env,obj)?}),"LEASH_HITCH" => Ok(EntityType::LeashHitch { inner: EntityTypeStruct::from_raw(env,obj)?}),"PAINTING" => Ok(EntityType::Painting { inner: EntityTypeStruct::from_raw(env,obj)?}),"ARROW" => Ok(EntityType::Arrow { inner: EntityTypeStruct::from_raw(env,obj)?}),"SNOWBALL" => Ok(EntityType::Snowball { inner: EntityTypeStruct::from_raw(env,obj)?}),"FIREBALL" => Ok(EntityType::Fireball { inner: EntityTypeStruct::from_raw(env,obj)?}),"SMALL_FIREBALL" => Ok(EntityType::SmallFireball { inner: EntityTypeStruct::from_raw(env,obj)?}),"ENDER_PEARL" => Ok(EntityType::EnderPearl { inner: EntityTypeStruct::from_raw(env,obj)?}),"ENDER_SIGNAL" => Ok(EntityType::EnderSignal { inner: EntityTypeStruct::from_raw(env,obj)?}),"SPLASH_POTION" => Ok(EntityType::SplashPotion { inner: EntityTypeStruct::from_raw(env,obj)?}),"THROWN_EXP_BOTTLE" => Ok(EntityType::ThrownExpBottle { inner: EntityTypeStruct::from_raw(env,obj)?}),"ITEM_FRAME" => Ok(EntityType::ItemFrame { inner: EntityTypeStruct::from_raw(env,obj)?}),"WITHER_SKULL" => Ok(EntityType::WitherSkull { inner: EntityTypeStruct::from_raw(env,obj)?}),"PRIMED_TNT" => Ok(EntityType::PrimedTnt { inner: EntityTypeStruct::from_raw(env,obj)?}),"FALLING_BLOCK" => Ok(EntityType::FallingBlock { inner: EntityTypeStruct::from_raw(env,obj)?}),"FIREWORK" => Ok(EntityType::Firework { inner: EntityTypeStruct::from_raw(env,obj)?}),"HUSK" => Ok(EntityType::Husk { inner: EntityTypeStruct::from_raw(env,obj)?}),"SPECTRAL_ARROW" => Ok(EntityType::SpectralArrow { inner: EntityTypeStruct::from_raw(env,obj)?}),"SHULKER_BULLET" => Ok(EntityType::ShulkerBullet { inner: EntityTypeStruct::from_raw(env,obj)?}),"DRAGON_FIREBALL" => Ok(EntityType::DragonFireball { inner: EntityTypeStruct::from_raw(env,obj)?}),"ZOMBIE_VILLAGER" => Ok(EntityType::ZombieVillager { inner: EntityTypeStruct::from_raw(env,obj)?}),"SKELETON_HORSE" => Ok(EntityType::SkeletonHorse { inner: EntityTypeStruct::from_raw(env,obj)?}),"ZOMBIE_HORSE" => Ok(EntityType::ZombieHorse { inner: EntityTypeStruct::from_raw(env,obj)?}),"ARMOR_STAND" => Ok(EntityType::ArmorStand { inner: EntityTypeStruct::from_raw(env,obj)?}),"DONKEY" => Ok(EntityType::Donkey { inner: EntityTypeStruct::from_raw(env,obj)?}),"MULE" => Ok(EntityType::Mule { inner: EntityTypeStruct::from_raw(env,obj)?}),"EVOKER_FANGS" => Ok(EntityType::EvokerFangs { inner: EntityTypeStruct::from_raw(env,obj)?}),"EVOKER" => Ok(EntityType::Evoker { inner: EntityTypeStruct::from_raw(env,obj)?}),"VEX" => Ok(EntityType::Vex { inner: EntityTypeStruct::from_raw(env,obj)?}),"VINDICATOR" => Ok(EntityType::Vindicator { inner: EntityTypeStruct::from_raw(env,obj)?}),"ILLUSIONER" => Ok(EntityType::Illusioner { inner: EntityTypeStruct::from_raw(env,obj)?}),"MINECART_COMMAND" => Ok(EntityType::MinecartCommand { inner: EntityTypeStruct::from_raw(env,obj)?}),"BOAT" => Ok(EntityType::Boat { inner: EntityTypeStruct::from_raw(env,obj)?}),"MINECART" => Ok(EntityType::Minecart { inner: EntityTypeStruct::from_raw(env,obj)?}),"MINECART_CHEST" => Ok(EntityType::MinecartChest { inner: EntityTypeStruct::from_raw(env,obj)?}),"MINECART_FURNACE" => Ok(EntityType::MinecartFurnace { inner: EntityTypeStruct::from_raw(env,obj)?}),"MINECART_TNT" => Ok(EntityType::MinecartTnt { inner: EntityTypeStruct::from_raw(env,obj)?}),"MINECART_HOPPER" => Ok(EntityType::MinecartHopper { inner: EntityTypeStruct::from_raw(env,obj)?}),"MINECART_MOB_SPAWNER" => Ok(EntityType::MinecartMobSpawner { inner: EntityTypeStruct::from_raw(env,obj)?}),"CREEPER" => Ok(EntityType::Creeper { inner: EntityTypeStruct::from_raw(env,obj)?}),"SKELETON" => Ok(EntityType::Skeleton { inner: EntityTypeStruct::from_raw(env,obj)?}),"SPIDER" => Ok(EntityType::Spider { inner: EntityTypeStruct::from_raw(env,obj)?}),"GIANT" => Ok(EntityType::Giant { inner: EntityTypeStruct::from_raw(env,obj)?}),"ZOMBIE" => Ok(EntityType::Zombie { inner: EntityTypeStruct::from_raw(env,obj)?}),"SLIME" => Ok(EntityType::Slime { inner: EntityTypeStruct::from_raw(env,obj)?}),"GHAST" => Ok(EntityType::Ghast { inner: EntityTypeStruct::from_raw(env,obj)?}),"ZOMBIFIED_PIGLIN" => Ok(EntityType::ZombifiedPiglin { inner: EntityTypeStruct::from_raw(env,obj)?}),"ENDERMAN" => Ok(EntityType::Enderman { inner: EntityTypeStruct::from_raw(env,obj)?}),"CAVE_SPIDER" => Ok(EntityType::CaveSpider { inner: EntityTypeStruct::from_raw(env,obj)?}),"SILVERFISH" => Ok(EntityType::Silverfish { inner: EntityTypeStruct::from_raw(env,obj)?}),"BLAZE" => Ok(EntityType::Blaze { inner: EntityTypeStruct::from_raw(env,obj)?}),"MAGMA_CUBE" => Ok(EntityType::MagmaCube { inner: EntityTypeStruct::from_raw(env,obj)?}),"ENDER_DRAGON" => Ok(EntityType::EnderDragon { inner: EntityTypeStruct::from_raw(env,obj)?}),"WITHER" => Ok(EntityType::Wither { inner: EntityTypeStruct::from_raw(env,obj)?}),"BAT" => Ok(EntityType::Bat { inner: EntityTypeStruct::from_raw(env,obj)?}),"WITCH" => Ok(EntityType::Witch { inner: EntityTypeStruct::from_raw(env,obj)?}),"ENDERMITE" => Ok(EntityType::Endermite { inner: EntityTypeStruct::from_raw(env,obj)?}),"GUARDIAN" => Ok(EntityType::Guardian { inner: EntityTypeStruct::from_raw(env,obj)?}),"SHULKER" => Ok(EntityType::Shulker { inner: EntityTypeStruct::from_raw(env,obj)?}),"PIG" => Ok(EntityType::Pig { inner: EntityTypeStruct::from_raw(env,obj)?}),"SHEEP" => Ok(EntityType::Sheep { inner: EntityTypeStruct::from_raw(env,obj)?}),"COW" => Ok(EntityType::Cow { inner: EntityTypeStruct::from_raw(env,obj)?}),"CHICKEN" => Ok(EntityType::Chicken { inner: EntityTypeStruct::from_raw(env,obj)?}),"SQUID" => Ok(EntityType::Squid { inner: EntityTypeStruct::from_raw(env,obj)?}),"WOLF" => Ok(EntityType::Wolf { inner: EntityTypeStruct::from_raw(env,obj)?}),"MUSHROOM_COW" => Ok(EntityType::MushroomCow { inner: EntityTypeStruct::from_raw(env,obj)?}),"SNOWMAN" => Ok(EntityType::Snowman { inner: EntityTypeStruct::from_raw(env,obj)?}),"OCELOT" => Ok(EntityType::Ocelot { inner: EntityTypeStruct::from_raw(env,obj)?}),"IRON_GOLEM" => Ok(EntityType::IronGolem { inner: EntityTypeStruct::from_raw(env,obj)?}),"HORSE" => Ok(EntityType::Horse { inner: EntityTypeStruct::from_raw(env,obj)?}),"RABBIT" => Ok(EntityType::Rabbit { inner: EntityTypeStruct::from_raw(env,obj)?}),"POLAR_BEAR" => Ok(EntityType::PolarBear { inner: EntityTypeStruct::from_raw(env,obj)?}),"LLAMA" => Ok(EntityType::Llama { inner: EntityTypeStruct::from_raw(env,obj)?}),"LLAMA_SPIT" => Ok(EntityType::LlamaSpit { inner: EntityTypeStruct::from_raw(env,obj)?}),"PARROT" => Ok(EntityType::Parrot { inner: EntityTypeStruct::from_raw(env,obj)?}),"VILLAGER" => Ok(EntityType::Villager { inner: EntityTypeStruct::from_raw(env,obj)?}),"ENDER_CRYSTAL" => Ok(EntityType::EnderCrystal { inner: EntityTypeStruct::from_raw(env,obj)?}),"TURTLE" => Ok(EntityType::Turtle { inner: EntityTypeStruct::from_raw(env,obj)?}),"PHANTOM" => Ok(EntityType::Phantom { inner: EntityTypeStruct::from_raw(env,obj)?}),"TRIDENT" => Ok(EntityType::Trident { inner: EntityTypeStruct::from_raw(env,obj)?}),"COD" => Ok(EntityType::Cod { inner: EntityTypeStruct::from_raw(env,obj)?}),"SALMON" => Ok(EntityType::Salmon { inner: EntityTypeStruct::from_raw(env,obj)?}),"PUFFERFISH" => Ok(EntityType::Pufferfish { inner: EntityTypeStruct::from_raw(env,obj)?}),"TROPICAL_FISH" => Ok(EntityType::TropicalFish { inner: EntityTypeStruct::from_raw(env,obj)?}),"DROWNED" => Ok(EntityType::Drowned { inner: EntityTypeStruct::from_raw(env,obj)?}),"DOLPHIN" => Ok(EntityType::Dolphin { inner: EntityTypeStruct::from_raw(env,obj)?}),"CAT" => Ok(EntityType::Cat { inner: EntityTypeStruct::from_raw(env,obj)?}),"PANDA" => Ok(EntityType::Panda { inner: EntityTypeStruct::from_raw(env,obj)?}),"PILLAGER" => Ok(EntityType::Pillager { inner: EntityTypeStruct::from_raw(env,obj)?}),"RAVAGER" => Ok(EntityType::Ravager { inner: EntityTypeStruct::from_raw(env,obj)?}),"TRADER_LLAMA" => Ok(EntityType::TraderLlama { inner: EntityTypeStruct::from_raw(env,obj)?}),"WANDERING_TRADER" => Ok(EntityType::WanderingTrader { inner: EntityTypeStruct::from_raw(env,obj)?}),"FOX" => Ok(EntityType::Fox { inner: EntityTypeStruct::from_raw(env,obj)?}),"BEE" => Ok(EntityType::Bee { inner: EntityTypeStruct::from_raw(env,obj)?}),"HOGLIN" => Ok(EntityType::Hoglin { inner: EntityTypeStruct::from_raw(env,obj)?}),"PIGLIN" => Ok(EntityType::Piglin { inner: EntityTypeStruct::from_raw(env,obj)?}),"STRIDER" => Ok(EntityType::Strider { inner: EntityTypeStruct::from_raw(env,obj)?}),"ZOGLIN" => Ok(EntityType::Zoglin { inner: EntityTypeStruct::from_raw(env,obj)?}),"PIGLIN_BRUTE" => Ok(EntityType::PiglinBrute { inner: EntityTypeStruct::from_raw(env,obj)?}),"AXOLOTL" => Ok(EntityType::Axolotl { inner: EntityTypeStruct::from_raw(env,obj)?}),"GLOW_ITEM_FRAME" => Ok(EntityType::GlowItemFrame { inner: EntityTypeStruct::from_raw(env,obj)?}),"GLOW_SQUID" => Ok(EntityType::GlowSquid { inner: EntityTypeStruct::from_raw(env,obj)?}),"GOAT" => Ok(EntityType::Goat { inner: EntityTypeStruct::from_raw(env,obj)?}),"MARKER" => Ok(EntityType::Marker { inner: EntityTypeStruct::from_raw(env,obj)?}),"ALLAY" => Ok(EntityType::Allay { inner: EntityTypeStruct::from_raw(env,obj)?}),"CHEST_BOAT" => Ok(EntityType::ChestBoat { inner: EntityTypeStruct::from_raw(env,obj)?}),"FROG" => Ok(EntityType::Frog { inner: EntityTypeStruct::from_raw(env,obj)?}),"TADPOLE" => Ok(EntityType::Tadpole { inner: EntityTypeStruct::from_raw(env,obj)?}),"WARDEN" => Ok(EntityType::Warden { inner: EntityTypeStruct::from_raw(env,obj)?}),"CAMEL" => Ok(EntityType::Camel { inner: EntityTypeStruct::from_raw(env,obj)?}),"BLOCK_DISPLAY" => Ok(EntityType::BlockDisplay { inner: EntityTypeStruct::from_raw(env,obj)?}),"INTERACTION" => Ok(EntityType::Interaction { inner: EntityTypeStruct::from_raw(env,obj)?}),"ITEM_DISPLAY" => Ok(EntityType::ItemDisplay { inner: EntityTypeStruct::from_raw(env,obj)?}),"SNIFFER" => Ok(EntityType::Sniffer { inner: EntityTypeStruct::from_raw(env,obj)?}),"TEXT_DISPLAY" => Ok(EntityType::TextDisplay { inner: EntityTypeStruct::from_raw(env,obj)?}),"BREEZE" => Ok(EntityType::Breeze { inner: EntityTypeStruct::from_raw(env,obj)?}),"WIND_CHARGE" => Ok(EntityType::WindCharge { inner: EntityTypeStruct::from_raw(env,obj)?}),"FISHING_HOOK" => Ok(EntityType::FishingHook { inner: EntityTypeStruct::from_raw(env,obj)?}),"LIGHTNING" => Ok(EntityType::Lightning { inner: EntityTypeStruct::from_raw(env,obj)?}),"PLAYER" => Ok(EntityType::Player { inner: EntityTypeStruct::from_raw(env,obj)?}),"UNKNOWN" => Ok(EntityType::Unknown { inner: EntityTypeStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for EntityTypeStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for EntityTypeStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EntityTypeStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EntityType")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EntityTypeStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> EntityTypeStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let cls = jni.find_class("org/bukkit/entity/EntityType"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::EntityType::from_raw(&jni,obj
)}
#[deprecated]

	pub fn name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn key(&self) 
-> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::NamespacedKey;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKey",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::NamespacedKey::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn entity_class(&self) 
-> Result<Option<jni::objects::JClass<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Ljni::objects::JClass;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityClass",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
unsafe {jni::objects::JClass::from_raw(res.as_jni().l)}
)
)}
#[deprecated]

	pub fn type_id(&self) 
-> Result<i16, Box<dyn std::error::Error>>

{let sig = String::from("()Li16;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTypeId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.s()?
)}
#[deprecated]

	pub fn from_name(jni: &blackboxmc_general::SharedJNIEnv<'mc>,name: impl Into<String>) 
-> Result<Option<crate::entity::EntityType<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lcrate::entity::EntityType;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(jni.new_string(name.into())?));
let cls = jni.find_class("org/bukkit/entity/EntityType"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"fromName",
sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
jni.translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
let obj = res.l()?;
Ok(
Some(
crate::entity::EntityType::from_raw(&jni,obj
)?
)
)}
#[deprecated]

	pub fn from_id(jni: &blackboxmc_general::SharedJNIEnv<'mc>,id: i32) 
-> Result<Option<crate::entity::EntityType<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(I)Lcrate::entity::EntityType;");
let val_1 = jni::objects::JValueGen::Int(id);
let cls = jni.find_class("org/bukkit/entity/EntityType"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"fromId",
sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
jni.translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
let obj = res.l()?;
Ok(
Some(
crate::entity::EntityType::from_raw(&jni,obj
)?
)
)}
	pub fn is_spawnable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSpawnable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_alive(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAlive",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn translation_key(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTranslationKey",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn is_enabled_by_feature(&self,world: impl Into<crate::World<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/World;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(world.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"isEnabledByFeature",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Slime<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Slime<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Slime<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Slime from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Slime")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Slime object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Slime<'mc> {
	pub fn size(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSize",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_size(&self,sz: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(sz);
let res = self.jni_ref().call_method(&self.jni_object(),"setSize",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_target(&self,target: impl Into<crate::entity::LivingEntity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/LivingEntity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn target(&self) 
-> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::LivingEntity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::LivingEntity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_aware(&self,aware: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(aware.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAware",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_aware(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAware",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn ambient_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAmbientSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("(Z)Lf64;");
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)LVec;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)Lcrate::block::Block;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)LVec;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(count);
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(damage);
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Player;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lcrate::potion::PotionEffect;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(remove.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::EntityEquipment;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(ai.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/memory/MemoryKey;)Ljni::objects::JObject;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/memory/MemoryKey;Ljava/lang/Object;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(memory_value);
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(I)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Int(fall_height);
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_loot_table(&self,table: impl Into<crate::loot::LootTable<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/loot/LootTable;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(table.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLootTable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn loot_table(&self) 
-> Result<Option<crate::loot::LootTable<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::loot::LootTable;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLootTable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::loot::LootTable::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_seed(&self,seed: i64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(J)L();");
let val_1 = jni::objects::JValueGen::Long(seed);
let res = self.jni_ref().call_method(&self.jni_object(),"setSeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn seed(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Mob<'mc>> for Slime<'mc>{

fn into(self) -> crate::entity::Mob<'mc> {

crate::entity::Mob::from_raw(&self.jni_ref(), self.1).expect("Error converting Slime into crate::entity::Mob")

   }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for Slime<'mc>{

fn into(self) -> crate::entity::Enemy<'mc> {

crate::entity::Enemy::from_raw(&self.jni_ref(), self.1).expect("Error converting Slime into crate::entity::Enemy")

   }
}
pub enum TextDisplayTextAlignment<'mc> {
	Center {inner: TextDisplayTextAlignmentStruct<'mc>},
	Left {inner: TextDisplayTextAlignmentStruct<'mc>},
	Right {inner: TextDisplayTextAlignmentStruct<'mc>},
}
impl<'mc> std::fmt::Display for TextDisplayTextAlignment<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           TextDisplayTextAlignment::Center { .. } => f.write_str("CENTER"),
           TextDisplayTextAlignment::Left { .. } => f.write_str("LEFT"),
           TextDisplayTextAlignment::Right { .. } => f.write_str("RIGHT"),
       }
   }
}

        impl<'mc> TextDisplayTextAlignment<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<TextDisplayTextAlignment<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/TextDisplay/TextAlignment");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/TextDisplay/TextAlignment;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"CENTER" => Ok(TextDisplayTextAlignment::Center { inner: TextDisplayTextAlignmentStruct::from_raw(env,obj)?}),
"LEFT" => Ok(TextDisplayTextAlignment::Left { inner: TextDisplayTextAlignmentStruct::from_raw(env,obj)?}),
"RIGHT" => Ok(TextDisplayTextAlignment::Right { inner: TextDisplayTextAlignmentStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct TextDisplayTextAlignmentStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for TextDisplayTextAlignment<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Center { inner } => inner.0.clone(),
Self::Left { inner } => inner.0.clone(),
Self::Right { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Center { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Left { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Right { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for TextDisplayTextAlignment<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate TextDisplayTextAlignment from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TextDisplay/TextAlignment")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a TextDisplayTextAlignment object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "CENTER" => Ok(TextDisplayTextAlignment::Center { inner: TextDisplayTextAlignmentStruct::from_raw(env,obj)?}),"LEFT" => Ok(TextDisplayTextAlignment::Left { inner: TextDisplayTextAlignmentStruct::from_raw(env,obj)?}),"RIGHT" => Ok(TextDisplayTextAlignment::Right { inner: TextDisplayTextAlignmentStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for TextDisplayTextAlignmentStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for TextDisplayTextAlignmentStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate TextDisplayTextAlignmentStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TextDisplay/TextAlignment")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a TextDisplayTextAlignmentStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> TextDisplayTextAlignmentStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::TextDisplayTextAlignment<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::TextDisplayTextAlignment;");
let cls = jni.find_class("org/bukkit/entity/TextDisplay/TextAlignment"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::TextDisplayTextAlignment::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Mule<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Mule<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Mule<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Mule from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Mule")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Mule object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Mule<'mc> {
	pub fn is_carrying_chest(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCarryingChest",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_carrying_chest(&self,chest: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(chest.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCarryingChest",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::ChestedHorse<'mc>> for Mule<'mc>{

fn into(self) -> crate::entity::ChestedHorse<'mc> {

crate::entity::ChestedHorse::from_raw(&self.jni_ref(), self.1).expect("Error converting Mule into crate::entity::ChestedHorse")

   }
}
#[repr(C)]
pub struct Breedable<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Breedable<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Breedable<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Breedable from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Breedable")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Breedable object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Breedable<'mc> {
#[deprecated]

	pub fn set_age_lock_with_lock(&self,lock: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(lock.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAgeLock",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn age_lock(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getAgeLock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn can_breed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_breed_with_breed(&self,breed: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(breed.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBreed",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn age(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAge",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_age(&self,age: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(age);
let res = self.jni_ref().call_method(&self.jni_object(),"setAge",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_baby(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_adult(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"setAdult",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_adult(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAdult",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Ageable<'mc>> for Breedable<'mc>{

fn into(self) -> crate::entity::Ageable<'mc> {

crate::entity::Ageable::from_raw(&self.jni_ref(), self.1).expect("Error converting Breedable into crate::entity::Ageable")

   }
}
#[repr(C)]
pub struct Monster<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Monster<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Monster<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Monster from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Monster")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Monster object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Monster<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Creature<'mc>> for Monster<'mc>{

fn into(self) -> crate::entity::Creature<'mc> {

crate::entity::Creature::from_raw(&self.jni_ref(), self.1).expect("Error converting Monster into crate::entity::Creature")

   }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for Monster<'mc>{

fn into(self) -> crate::entity::Enemy<'mc> {

crate::entity::Enemy::from_raw(&self.jni_ref(), self.1).expect("Error converting Monster into crate::entity::Enemy")

   }
}
#[repr(C)]
pub struct Golem<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Golem<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Golem<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Golem from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Golem")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Golem object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Golem<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Creature<'mc>> for Golem<'mc>{

fn into(self) -> crate::entity::Creature<'mc> {

crate::entity::Creature::from_raw(&self.jni_ref(), self.1).expect("Error converting Golem into crate::entity::Creature")

   }
}
#[repr(C)]
pub struct FishHook<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for FishHook<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for FishHook<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate FishHook from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/FishHook")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a FishHook object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> FishHook<'mc> {
	pub fn min_wait_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMinWaitTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_min_wait_time(&self,min_wait_time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(min_wait_time);
let res = self.jni_ref().call_method(&self.jni_object(),"setMinWaitTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn max_wait_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxWaitTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_max_wait_time(&self,max_wait_time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(max_wait_time);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxWaitTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_wait_time(&self,min: i32,max: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(II)L();");
let val_1 = jni::objects::JValueGen::Int(min);
let val_2 = jni::objects::JValueGen::Int(max);
let res = self.jni_ref().call_method(&self.jni_object(),"setWaitTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn min_lure_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMinLureTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_min_lure_time(&self,min_lure_time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(min_lure_time);
let res = self.jni_ref().call_method(&self.jni_object(),"setMinLureTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn max_lure_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxLureTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_max_lure_time(&self,max_lure_time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(max_lure_time);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxLureTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_lure_time(&self,min: i32,max: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(II)L();");
let val_1 = jni::objects::JValueGen::Int(min);
let val_2 = jni::objects::JValueGen::Int(max);
let res = self.jni_ref().call_method(&self.jni_object(),"setLureTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn min_lure_angle(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMinLureAngle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_min_lure_angle(&self,min_lure_angle: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(min_lure_angle);
let res = self.jni_ref().call_method(&self.jni_object(),"setMinLureAngle",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn max_lure_angle(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxLureAngle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_max_lure_angle(&self,max_lure_angle: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(max_lure_angle);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxLureAngle",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_lure_angle(&self,min: f32,max: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(min);
let val_2 = jni::objects::JValueGen::Float(max);
let res = self.jni_ref().call_method(&self.jni_object(),"setLureAngle",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn apply_lure(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getApplyLure",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_apply_lure(&self,apply_lure: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(apply_lure.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setApplyLure",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn bite_chance(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBiteChance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_bite_chance(&self,chance: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(chance);
let res = self.jni_ref().call_method(&self.jni_object(),"setBiteChance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_in_open_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInOpenWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn hooked_entity(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHookedEntity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_hooked_entity(&self,entity: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setHookedEntity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn pull_hooked_entity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"pullHookedEntity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sky_influenced(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSkyInfluenced",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_sky_influenced(&self,sky_influenced: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(sky_influenced.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSkyInfluenced",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_rain_influenced(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isRainInfluenced",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_rain_influenced(&self,rain_influenced: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(rain_influenced.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setRainInfluenced",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn state(&self) 
-> Result<crate::entity::FishHookHookState<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::FishHookHookState;");
let res = self.jni_ref().call_method(&self.jni_object(),"getState",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::FishHookHookState::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for FishHook<'mc>{

fn into(self) -> crate::entity::Projectile<'mc> {

crate::entity::Projectile::from_raw(&self.jni_ref(), self.1).expect("Error converting FishHook into crate::entity::Projectile")

   }
}
#[repr(C)]
pub struct Witch<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Witch<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Witch<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Witch from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Witch")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Witch object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Witch<'mc> {
	pub fn is_drinking_potion(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDrinkingPotion",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_raid(&self,raid: impl Into<crate::Raid<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Raid;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(raid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn raid(&self) 
-> Result<Option<crate::Raid<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Raid;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Raid::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn wave(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWave",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_wave(&self,wave: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(wave);
let res = self.jni_ref().call_method(&self.jni_object(),"setWave",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn patrol_target(&self) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::Block;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPatrolTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_patrol_target(&self,block: impl Into<crate::block::Block<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/block/Block;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(block.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPatrolTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_patrol_leader(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPatrolLeader",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_patrol_leader(&self,leader: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(leader.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPatrolLeader",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_can_join_raid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCanJoinRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_can_join_raid(&self,join: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(join.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanJoinRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn ticks_outside_raid(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksOutsideRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_outside_raid(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksOutsideRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_celebrating(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCelebrating",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_celebrating(&self,celebrating: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(celebrating.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCelebrating",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn celebration_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCelebrationSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Raider<'mc>> for Witch<'mc>{

fn into(self) -> crate::entity::Raider<'mc> {

crate::entity::Raider::from_raw(&self.jni_ref(), self.1).expect("Error converting Witch into crate::entity::Raider")

   }
}
pub enum BoatType<'mc> {
	Oak {inner: BoatTypeStruct<'mc>},
	Spruce {inner: BoatTypeStruct<'mc>},
	Birch {inner: BoatTypeStruct<'mc>},
	Jungle {inner: BoatTypeStruct<'mc>},
	Acacia {inner: BoatTypeStruct<'mc>},
	Cherry {inner: BoatTypeStruct<'mc>},
	DarkOak {inner: BoatTypeStruct<'mc>},
	Mangrove {inner: BoatTypeStruct<'mc>},
	Bamboo {inner: BoatTypeStruct<'mc>},
}
impl<'mc> std::fmt::Display for BoatType<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           BoatType::Oak { .. } => f.write_str("OAK"),
           BoatType::Spruce { .. } => f.write_str("SPRUCE"),
           BoatType::Birch { .. } => f.write_str("BIRCH"),
           BoatType::Jungle { .. } => f.write_str("JUNGLE"),
           BoatType::Acacia { .. } => f.write_str("ACACIA"),
           BoatType::Cherry { .. } => f.write_str("CHERRY"),
           BoatType::DarkOak { .. } => f.write_str("DARK_OAK"),
           BoatType::Mangrove { .. } => f.write_str("MANGROVE"),
           BoatType::Bamboo { .. } => f.write_str("BAMBOO"),
       }
   }
}

        impl<'mc> BoatType<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<BoatType<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Boat/Type");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Boat/Type;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"OAK" => Ok(BoatType::Oak { inner: BoatTypeStruct::from_raw(env,obj)?}),
"SPRUCE" => Ok(BoatType::Spruce { inner: BoatTypeStruct::from_raw(env,obj)?}),
"BIRCH" => Ok(BoatType::Birch { inner: BoatTypeStruct::from_raw(env,obj)?}),
"JUNGLE" => Ok(BoatType::Jungle { inner: BoatTypeStruct::from_raw(env,obj)?}),
"ACACIA" => Ok(BoatType::Acacia { inner: BoatTypeStruct::from_raw(env,obj)?}),
"CHERRY" => Ok(BoatType::Cherry { inner: BoatTypeStruct::from_raw(env,obj)?}),
"DARK_OAK" => Ok(BoatType::DarkOak { inner: BoatTypeStruct::from_raw(env,obj)?}),
"MANGROVE" => Ok(BoatType::Mangrove { inner: BoatTypeStruct::from_raw(env,obj)?}),
"BAMBOO" => Ok(BoatType::Bamboo { inner: BoatTypeStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct BoatTypeStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for BoatType<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Oak { inner } => inner.0.clone(),
Self::Spruce { inner } => inner.0.clone(),
Self::Birch { inner } => inner.0.clone(),
Self::Jungle { inner } => inner.0.clone(),
Self::Acacia { inner } => inner.0.clone(),
Self::Cherry { inner } => inner.0.clone(),
Self::DarkOak { inner } => inner.0.clone(),
Self::Mangrove { inner } => inner.0.clone(),
Self::Bamboo { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Oak { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Spruce { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Birch { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Jungle { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Acacia { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Cherry { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::DarkOak { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Mangrove { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Bamboo { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for BoatType<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate BoatType from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Boat/Type")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a BoatType object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "OAK" => Ok(BoatType::Oak { inner: BoatTypeStruct::from_raw(env,obj)?}),"SPRUCE" => Ok(BoatType::Spruce { inner: BoatTypeStruct::from_raw(env,obj)?}),"BIRCH" => Ok(BoatType::Birch { inner: BoatTypeStruct::from_raw(env,obj)?}),"JUNGLE" => Ok(BoatType::Jungle { inner: BoatTypeStruct::from_raw(env,obj)?}),"ACACIA" => Ok(BoatType::Acacia { inner: BoatTypeStruct::from_raw(env,obj)?}),"CHERRY" => Ok(BoatType::Cherry { inner: BoatTypeStruct::from_raw(env,obj)?}),"DARK_OAK" => Ok(BoatType::DarkOak { inner: BoatTypeStruct::from_raw(env,obj)?}),"MANGROVE" => Ok(BoatType::Mangrove { inner: BoatTypeStruct::from_raw(env,obj)?}),"BAMBOO" => Ok(BoatType::Bamboo { inner: BoatTypeStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for BoatTypeStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for BoatTypeStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate BoatTypeStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Boat/Type")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a BoatTypeStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> BoatTypeStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::BoatType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::BoatType;");
let cls = jni.find_class("org/bukkit/entity/Boat/Type"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::BoatType::from_raw(&jni,obj
)}
	pub fn material(&self) 
-> Result<crate::Material<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Material;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaterial",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Material::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Boat<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Boat<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Boat<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Boat from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Boat")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Boat object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Boat<'mc> {
#[deprecated]

	pub fn wood_type(&self) 
-> Result<crate::TreeSpecies<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::TreeSpecies;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWoodType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::TreeSpecies::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_wood_type(&self,species: impl Into<crate::TreeSpecies<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/TreeSpecies;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(species.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setWoodType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn boat_type(&self) 
-> Result<crate::entity::BoatType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::BoatType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoatType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::BoatType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_boat_type(&self,val_type: impl Into<crate::entity::BoatType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Boat/Type;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBoatType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn max_speed(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxSpeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_max_speed(&self,speed: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(speed);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxSpeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn occupied_deceleration(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOccupiedDeceleration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_occupied_deceleration(&self,rate: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(rate);
let res = self.jni_ref().call_method(&self.jni_object(),"setOccupiedDeceleration",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn unoccupied_deceleration(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUnoccupiedDeceleration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_unoccupied_deceleration(&self,rate: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(rate);
let res = self.jni_ref().call_method(&self.jni_object(),"setUnoccupiedDeceleration",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn work_on_land(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorkOnLand",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_work_on_land(&self,work_on_land: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(work_on_land.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setWorkOnLand",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn status(&self) 
-> Result<crate::entity::BoatStatus<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::BoatStatus;");
let res = self.jni_ref().call_method(&self.jni_object(),"getStatus",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::BoatStatus::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_velocity(&self,vel: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(vel.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Vehicle<'mc>> for Boat<'mc>{

fn into(self) -> crate::entity::Vehicle<'mc> {

crate::entity::Vehicle::from_raw(&self.jni_ref(), self.1).expect("Error converting Boat into crate::entity::Vehicle")

   }
}
#[repr(C)]
pub struct ShulkerBullet<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ShulkerBullet<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ShulkerBullet<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ShulkerBullet from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ShulkerBullet")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ShulkerBullet object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ShulkerBullet<'mc> {
	pub fn target(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_target(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for ShulkerBullet<'mc>{

fn into(self) -> crate::entity::Projectile<'mc> {

crate::entity::Projectile::from_raw(&self.jni_ref(), self.1).expect("Error converting ShulkerBullet into crate::entity::Projectile")

   }
}
#[repr(C)]
pub struct LivingEntity<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for LivingEntity<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for LivingEntity<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate LivingEntity from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LivingEntity")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a LivingEntity object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> LivingEntity<'mc> {
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("(Z)Lf64;");
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)LVec;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)Lcrate::block::Block;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)LVec;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(count);
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(damage);
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Player;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lcrate::potion::PotionEffect;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(remove.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::EntityEquipment;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(ai.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/memory/MemoryKey;)Ljni::objects::JObject;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/memory/MemoryKey;Ljava/lang/Object;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(memory_value);
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(I)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Int(fall_height);
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_attribute(&self,attribute: impl Into<crate::attribute::Attribute<'mc>>) 
-> Result<Option<crate::attribute::AttributeInstance<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/attribute/Attribute;)Lcrate::attribute::AttributeInstance;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(attribute.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getAttribute",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::attribute::AttributeInstance::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn damage_with_amount(&self,amount: f64,damage_source: std::option::Option<impl Into<crate::damage::DamageSource<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(amount);
args.push(val_1);
if let Some(a) = damage_source {
sig += "Lorg/bukkit/damage/DamageSource;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"damage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn absorption_amount(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAbsorptionAmount",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_absorption_amount(&self,amount: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(amount);
let res = self.jni_ref().call_method(&self.jni_object(),"setAbsorptionAmount",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn max_health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_max_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn reset_max_health(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetMaxHealth",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn launch_projectile_with_projectile(&self,projectile: jni::objects::JClass<'mc>,velocity: std::option::Option<impl Into<crate::util::Vector<'mc>>>) 
-> Result<crate::entity::Projectile<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/Class;";
let val_1 = jni::objects::JValueGen::Object(projectile.into());
args.push(val_1);
if let Some(a) = velocity {
sig += "Lorg/bukkit/util/Vector;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/entity/Projectile;";
let res = self.jni_ref().call_method(&self.jni_object(),"launchProjectile",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Projectile::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::attribute::Attributable<'mc>> for LivingEntity<'mc>{

fn into(self) -> crate::attribute::Attributable<'mc> {

crate::attribute::Attributable::from_raw(&self.jni_ref(), self.1).expect("Error converting LivingEntity into crate::attribute::Attributable")

   }
}
impl<'mc> Into<crate::entity::Damageable<'mc>> for LivingEntity<'mc>{

fn into(self) -> crate::entity::Damageable<'mc> {

crate::entity::Damageable::from_raw(&self.jni_ref(), self.1).expect("Error converting LivingEntity into crate::entity::Damageable")

   }
}
impl<'mc> Into<crate::projectiles::ProjectileSource<'mc>> for LivingEntity<'mc>{

fn into(self) -> crate::projectiles::ProjectileSource<'mc> {

crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(), self.1).expect("Error converting LivingEntity into crate::projectiles::ProjectileSource")

   }
}
#[repr(C)]
pub struct Pig<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Pig<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Pig<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Pig from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Pig")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Pig object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Pig<'mc> {
	pub fn has_saddle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasSaddle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_saddle(&self,saddled: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(saddled.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSaddle",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn boost_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoostTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_boost_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setBoostTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn current_boost_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCurrentBoostTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_current_boost_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setCurrentBoostTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn steer_material(&self) 
-> Result<crate::Material<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Material;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSteerMaterial",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Material::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_velocity(&self,vel: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(vel.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Steerable<'mc>> for Pig<'mc>{

fn into(self) -> crate::entity::Steerable<'mc> {

crate::entity::Steerable::from_raw(&self.jni_ref(), self.1).expect("Error converting Pig into crate::entity::Steerable")

   }
}
impl<'mc> Into<crate::entity::Vehicle<'mc>> for Pig<'mc>{

fn into(self) -> crate::entity::Vehicle<'mc> {

crate::entity::Vehicle::from_raw(&self.jni_ref(), self.1).expect("Error converting Pig into crate::entity::Vehicle")

   }
}
#[repr(C)]
pub struct Guardian<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Guardian<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Guardian<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Guardian from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Guardian")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Guardian object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Guardian<'mc> {
	pub fn set_laser(&self,activated: bool) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Z)Lbool;");
let val_1 = jni::objects::JValueGen::Bool(activated.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setLaser",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_laser(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasLaser",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn laser_duration(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLaserDuration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_laser_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLaserTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn laser_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLaserTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
#[deprecated]

	pub fn is_elder(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isElder",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_elder(&self,should_be_elder: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(should_be_elder.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setElder",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_moving(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isMoving",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Guardian<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Guardian into crate::entity::Monster")

   }
}
pub enum WitherHead<'mc> {
	Center {inner: WitherHeadStruct<'mc>},
	Left {inner: WitherHeadStruct<'mc>},
	Right {inner: WitherHeadStruct<'mc>},
}
impl<'mc> std::fmt::Display for WitherHead<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           WitherHead::Center { .. } => f.write_str("CENTER"),
           WitherHead::Left { .. } => f.write_str("LEFT"),
           WitherHead::Right { .. } => f.write_str("RIGHT"),
       }
   }
}

        impl<'mc> WitherHead<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<WitherHead<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Wither/Head");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Wither/Head;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"CENTER" => Ok(WitherHead::Center { inner: WitherHeadStruct::from_raw(env,obj)?}),
"LEFT" => Ok(WitherHead::Left { inner: WitherHeadStruct::from_raw(env,obj)?}),
"RIGHT" => Ok(WitherHead::Right { inner: WitherHeadStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct WitherHeadStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for WitherHead<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Center { inner } => inner.0.clone(),
Self::Left { inner } => inner.0.clone(),
Self::Right { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Center { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Left { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Right { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for WitherHead<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate WitherHead from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Wither/Head")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a WitherHead object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "CENTER" => Ok(WitherHead::Center { inner: WitherHeadStruct::from_raw(env,obj)?}),"LEFT" => Ok(WitherHead::Left { inner: WitherHeadStruct::from_raw(env,obj)?}),"RIGHT" => Ok(WitherHead::Right { inner: WitherHeadStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for WitherHeadStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for WitherHeadStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate WitherHeadStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Wither/Head")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a WitherHeadStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> WitherHeadStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::WitherHead<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::WitherHead;");
let cls = jni.find_class("org/bukkit/entity/Wither/Head"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::WitherHead::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
pub enum VillagerType<'mc> {
	Desert {inner: VillagerTypeStruct<'mc>},
	Jungle {inner: VillagerTypeStruct<'mc>},
	Plains {inner: VillagerTypeStruct<'mc>},
	Savanna {inner: VillagerTypeStruct<'mc>},
	Snow {inner: VillagerTypeStruct<'mc>},
	Swamp {inner: VillagerTypeStruct<'mc>},
	Taiga {inner: VillagerTypeStruct<'mc>},
}
impl<'mc> std::fmt::Display for VillagerType<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           VillagerType::Desert { .. } => f.write_str("DESERT"),
           VillagerType::Jungle { .. } => f.write_str("JUNGLE"),
           VillagerType::Plains { .. } => f.write_str("PLAINS"),
           VillagerType::Savanna { .. } => f.write_str("SAVANNA"),
           VillagerType::Snow { .. } => f.write_str("SNOW"),
           VillagerType::Swamp { .. } => f.write_str("SWAMP"),
           VillagerType::Taiga { .. } => f.write_str("TAIGA"),
       }
   }
}

        impl<'mc> VillagerType<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<VillagerType<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Villager/Type");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Villager/Type;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"DESERT" => Ok(VillagerType::Desert { inner: VillagerTypeStruct::from_raw(env,obj)?}),
"JUNGLE" => Ok(VillagerType::Jungle { inner: VillagerTypeStruct::from_raw(env,obj)?}),
"PLAINS" => Ok(VillagerType::Plains { inner: VillagerTypeStruct::from_raw(env,obj)?}),
"SAVANNA" => Ok(VillagerType::Savanna { inner: VillagerTypeStruct::from_raw(env,obj)?}),
"SNOW" => Ok(VillagerType::Snow { inner: VillagerTypeStruct::from_raw(env,obj)?}),
"SWAMP" => Ok(VillagerType::Swamp { inner: VillagerTypeStruct::from_raw(env,obj)?}),
"TAIGA" => Ok(VillagerType::Taiga { inner: VillagerTypeStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct VillagerTypeStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for VillagerType<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Desert { inner } => inner.0.clone(),
Self::Jungle { inner } => inner.0.clone(),
Self::Plains { inner } => inner.0.clone(),
Self::Savanna { inner } => inner.0.clone(),
Self::Snow { inner } => inner.0.clone(),
Self::Swamp { inner } => inner.0.clone(),
Self::Taiga { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Desert { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Jungle { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Plains { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Savanna { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Snow { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Swamp { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Taiga { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for VillagerType<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate VillagerType from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Villager/Type")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a VillagerType object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "DESERT" => Ok(VillagerType::Desert { inner: VillagerTypeStruct::from_raw(env,obj)?}),"JUNGLE" => Ok(VillagerType::Jungle { inner: VillagerTypeStruct::from_raw(env,obj)?}),"PLAINS" => Ok(VillagerType::Plains { inner: VillagerTypeStruct::from_raw(env,obj)?}),"SAVANNA" => Ok(VillagerType::Savanna { inner: VillagerTypeStruct::from_raw(env,obj)?}),"SNOW" => Ok(VillagerType::Snow { inner: VillagerTypeStruct::from_raw(env,obj)?}),"SWAMP" => Ok(VillagerType::Swamp { inner: VillagerTypeStruct::from_raw(env,obj)?}),"TAIGA" => Ok(VillagerType::Taiga { inner: VillagerTypeStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for VillagerTypeStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for VillagerTypeStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate VillagerTypeStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Villager/Type")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a VillagerTypeStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> VillagerTypeStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::VillagerType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::VillagerType;");
let cls = jni.find_class("org/bukkit/entity/Villager/Type"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::VillagerType::from_raw(&jni,obj
)}
	pub fn key(&self) 
-> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::NamespacedKey;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKey",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::NamespacedKey::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct NPC<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for NPC<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for NPC<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate NPC from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/NPC")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a NPC object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> NPC<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Creature<'mc>> for NPC<'mc>{

fn into(self) -> crate::entity::Creature<'mc> {

crate::entity::Creature::from_raw(&self.jni_ref(), self.1).expect("Error converting NPC into crate::entity::Creature")

   }
}
#[repr(C)]
pub struct ItemDisplay<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ItemDisplay<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ItemDisplay<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ItemDisplay from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ItemDisplay")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ItemDisplay object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ItemDisplay<'mc> {
	pub fn item_stack(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemStack",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_item_stack(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setItemStack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_display_transform(&self) 
-> Result<crate::entity::ItemDisplayItemDisplayTransform<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::ItemDisplayItemDisplayTransform;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemDisplayTransform",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::ItemDisplayItemDisplayTransform::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item_display_transform(&self,display: impl Into<crate::entity::ItemDisplayItemDisplayTransform<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/ItemDisplay/ItemDisplayTransform;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(display.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setItemDisplayTransform",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn transformation(&self) 
-> Result<crate::util::Transformation<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Transformation;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTransformation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Transformation::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_transformation(&self,transformation: impl Into<crate::util::Transformation<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Transformation;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transformation.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTransformation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_transformation_matrix(&self,transformation_matrix: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/joml/Matrix4f;)L();");
let val_1 = jni::objects::JValueGen::Object(transformation_matrix);
let res = self.jni_ref().call_method(&self.jni_object(),"setTransformationMatrix",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn interpolation_duration(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInterpolationDuration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_interpolation_duration(&self,duration: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(duration);
let res = self.jni_ref().call_method(&self.jni_object(),"setInterpolationDuration",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_duration(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTeleportDuration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_teleport_duration(&self,duration: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(duration);
let res = self.jni_ref().call_method(&self.jni_object(),"setTeleportDuration",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn view_range(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getViewRange",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_view_range(&self,range: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(range);
let res = self.jni_ref().call_method(&self.jni_object(),"setViewRange",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shadow_radius(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShadowRadius",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_shadow_radius(&self,radius: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(radius);
let res = self.jni_ref().call_method(&self.jni_object(),"setShadowRadius",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shadow_strength(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShadowStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_shadow_strength(&self,strength: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setShadowStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn display_width(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_display_width(&self,width: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(width);
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayWidth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn display_height(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_display_height(&self,height: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(height);
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayHeight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn interpolation_delay(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInterpolationDelay",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_interpolation_delay(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setInterpolationDelay",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn billboard(&self) 
-> Result<crate::entity::DisplayBillboard<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::DisplayBillboard;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBillboard",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::DisplayBillboard::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_billboard(&self,billboard: impl Into<crate::entity::DisplayBillboard<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Display/Billboard;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(billboard.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBillboard",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn glow_color_override(&self) 
-> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Color;");
let res = self.jni_ref().call_method(&self.jni_object(),"getGlowColorOverride",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Color::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_glow_color_override(&self,color: impl Into<crate::Color<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Color;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowColorOverride",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn brightness(&self) 
-> Result<Option<crate::entity::DisplayBrightness<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::DisplayBrightness;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBrightness",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::DisplayBrightness::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_brightness(&self,brightness: impl Into<crate::entity::DisplayBrightness<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Display/Brightness;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(brightness.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBrightness",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Display<'mc>> for ItemDisplay<'mc>{

fn into(self) -> crate::entity::Display<'mc> {

crate::entity::Display::from_raw(&self.jni_ref(), self.1).expect("Error converting ItemDisplay into crate::entity::Display")

   }
}
#[repr(C)]
pub struct Cat<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Cat<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Cat<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Cat from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Cat")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Cat object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Cat<'mc> {
	pub fn cat_type(&self) 
-> Result<crate::entity::CatType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::CatType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCatType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::CatType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_cat_type(&self,val_type: impl Into<crate::entity::CatType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Cat/Type;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setCatType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn collar_color(&self) 
-> Result<crate::DyeColor<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::DyeColor;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCollarColor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::DyeColor::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_collar_color(&self,color: impl Into<crate::DyeColor<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/DyeColor;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setCollarColor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_tamed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTamed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_tamed(&self,tame: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(tame.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setTamed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn owner(&self) 
-> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AnimalTamer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOwner",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::AnimalTamer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_owner(&self,tamer: impl Into<crate::entity::AnimalTamer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(tamer.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setOwner",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_sitting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSitting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_sitting(&self,sitting: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(sitting.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSitting",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Tameable<'mc>> for Cat<'mc>{

fn into(self) -> crate::entity::Tameable<'mc> {

crate::entity::Tameable::from_raw(&self.jni_ref(), self.1).expect("Error converting Cat into crate::entity::Tameable")

   }
}
impl<'mc> Into<crate::entity::Sittable<'mc>> for Cat<'mc>{

fn into(self) -> crate::entity::Sittable<'mc> {

crate::entity::Sittable::from_raw(&self.jni_ref(), self.1).expect("Error converting Cat into crate::entity::Sittable")

   }
}
#[repr(C)]
pub struct Sheep<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Sheep<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Sheep<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Sheep from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Sheep")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Sheep object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Sheep<'mc> {
	pub fn is_sheared(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSheared",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_sheared(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSheared",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn color(&self) 
-> Result<Option<crate::DyeColor<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::DyeColor;");
let res = self.jni_ref().call_method(&self.jni_object(),"getColor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::DyeColor::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_color(&self,color: impl Into<crate::DyeColor<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/DyeColor;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setColor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Sheep<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Sheep into crate::entity::Animals")

   }
}
impl<'mc> Into<crate::material::Colorable<'mc>> for Sheep<'mc>{

fn into(self) -> crate::material::Colorable<'mc> {

crate::material::Colorable::from_raw(&self.jni_ref(), self.1).expect("Error converting Sheep into crate::material::Colorable")

   }
}
#[repr(C)]
pub struct Warden<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Warden<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Warden<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Warden from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Warden")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Warden object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Warden<'mc> {
	pub fn get_anger(&self,entity: impl Into<crate::entity::Entity<'mc>>) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Li32;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getAnger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn increase_anger(&self,entity: impl Into<crate::entity::Entity<'mc>>,increase: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;I)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(increase);
let res = self.jni_ref().call_method(&self.jni_object(),"increaseAnger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_anger(&self,entity: impl Into<crate::entity::Entity<'mc>>,anger: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;I)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(anger);
let res = self.jni_ref().call_method(&self.jni_object(),"setAnger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn clear_anger(&self,entity: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"clearAnger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn entity_angry_at(&self) 
-> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::LivingEntity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityAngryAt",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::LivingEntity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_disturbance_location(&self,location: impl Into<crate::Location<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setDisturbanceLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn anger_level(&self) 
-> Result<crate::entity::WardenAngerLevel<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::WardenAngerLevel;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAngerLevel",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::WardenAngerLevel::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Warden<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Warden into crate::entity::Monster")

   }
}
pub enum ItemDisplayItemDisplayTransform<'mc> {
	None {inner: ItemDisplayItemDisplayTransformStruct<'mc>},
	ThirdpersonLefthand {inner: ItemDisplayItemDisplayTransformStruct<'mc>},
	ThirdpersonRighthand {inner: ItemDisplayItemDisplayTransformStruct<'mc>},
	FirstpersonLefthand {inner: ItemDisplayItemDisplayTransformStruct<'mc>},
	FirstpersonRighthand {inner: ItemDisplayItemDisplayTransformStruct<'mc>},
	Head {inner: ItemDisplayItemDisplayTransformStruct<'mc>},
	Gui {inner: ItemDisplayItemDisplayTransformStruct<'mc>},
	Ground {inner: ItemDisplayItemDisplayTransformStruct<'mc>},
	Fixed {inner: ItemDisplayItemDisplayTransformStruct<'mc>},
}
impl<'mc> std::fmt::Display for ItemDisplayItemDisplayTransform<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           ItemDisplayItemDisplayTransform::None { .. } => f.write_str("NONE"),
           ItemDisplayItemDisplayTransform::ThirdpersonLefthand { .. } => f.write_str("THIRDPERSON_LEFTHAND"),
           ItemDisplayItemDisplayTransform::ThirdpersonRighthand { .. } => f.write_str("THIRDPERSON_RIGHTHAND"),
           ItemDisplayItemDisplayTransform::FirstpersonLefthand { .. } => f.write_str("FIRSTPERSON_LEFTHAND"),
           ItemDisplayItemDisplayTransform::FirstpersonRighthand { .. } => f.write_str("FIRSTPERSON_RIGHTHAND"),
           ItemDisplayItemDisplayTransform::Head { .. } => f.write_str("HEAD"),
           ItemDisplayItemDisplayTransform::Gui { .. } => f.write_str("GUI"),
           ItemDisplayItemDisplayTransform::Ground { .. } => f.write_str("GROUND"),
           ItemDisplayItemDisplayTransform::Fixed { .. } => f.write_str("FIXED"),
       }
   }
}

        impl<'mc> ItemDisplayItemDisplayTransform<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<ItemDisplayItemDisplayTransform<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/ItemDisplay/ItemDisplayTransform");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/ItemDisplay/ItemDisplayTransform;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"NONE" => Ok(ItemDisplayItemDisplayTransform::None { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),
"THIRDPERSON_LEFTHAND" => Ok(ItemDisplayItemDisplayTransform::ThirdpersonLefthand { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),
"THIRDPERSON_RIGHTHAND" => Ok(ItemDisplayItemDisplayTransform::ThirdpersonRighthand { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),
"FIRSTPERSON_LEFTHAND" => Ok(ItemDisplayItemDisplayTransform::FirstpersonLefthand { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),
"FIRSTPERSON_RIGHTHAND" => Ok(ItemDisplayItemDisplayTransform::FirstpersonRighthand { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),
"HEAD" => Ok(ItemDisplayItemDisplayTransform::Head { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),
"GUI" => Ok(ItemDisplayItemDisplayTransform::Gui { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),
"GROUND" => Ok(ItemDisplayItemDisplayTransform::Ground { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),
"FIXED" => Ok(ItemDisplayItemDisplayTransform::Fixed { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct ItemDisplayItemDisplayTransformStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ItemDisplayItemDisplayTransform<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::None { inner } => inner.0.clone(),
Self::ThirdpersonLefthand { inner } => inner.0.clone(),
Self::ThirdpersonRighthand { inner } => inner.0.clone(),
Self::FirstpersonLefthand { inner } => inner.0.clone(),
Self::FirstpersonRighthand { inner } => inner.0.clone(),
Self::Head { inner } => inner.0.clone(),
Self::Gui { inner } => inner.0.clone(),
Self::Ground { inner } => inner.0.clone(),
Self::Fixed { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ThirdpersonLefthand { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ThirdpersonRighthand { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::FirstpersonLefthand { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::FirstpersonRighthand { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Head { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Gui { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Ground { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Fixed { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for ItemDisplayItemDisplayTransform<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ItemDisplayItemDisplayTransform from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ItemDisplay/ItemDisplayTransform")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ItemDisplayItemDisplayTransform object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "NONE" => Ok(ItemDisplayItemDisplayTransform::None { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),"THIRDPERSON_LEFTHAND" => Ok(ItemDisplayItemDisplayTransform::ThirdpersonLefthand { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),"THIRDPERSON_RIGHTHAND" => Ok(ItemDisplayItemDisplayTransform::ThirdpersonRighthand { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),"FIRSTPERSON_LEFTHAND" => Ok(ItemDisplayItemDisplayTransform::FirstpersonLefthand { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),"FIRSTPERSON_RIGHTHAND" => Ok(ItemDisplayItemDisplayTransform::FirstpersonRighthand { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),"HEAD" => Ok(ItemDisplayItemDisplayTransform::Head { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),"GUI" => Ok(ItemDisplayItemDisplayTransform::Gui { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),"GROUND" => Ok(ItemDisplayItemDisplayTransform::Ground { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),"FIXED" => Ok(ItemDisplayItemDisplayTransform::Fixed { inner: ItemDisplayItemDisplayTransformStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for ItemDisplayItemDisplayTransformStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ItemDisplayItemDisplayTransformStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ItemDisplayItemDisplayTransformStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ItemDisplay/ItemDisplayTransform")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ItemDisplayItemDisplayTransformStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ItemDisplayItemDisplayTransformStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::ItemDisplayItemDisplayTransform<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::ItemDisplayItemDisplayTransform;");
let cls = jni.find_class("org/bukkit/entity/ItemDisplay/ItemDisplayTransform"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::ItemDisplayItemDisplayTransform::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct WitherSkull<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for WitherSkull<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for WitherSkull<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate WitherSkull from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/WitherSkull")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a WitherSkull object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> WitherSkull<'mc> {
	pub fn set_charged(&self,charged: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(charged.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCharged",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_charged(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCharged",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_direction(&self,direction: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(direction.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setDirection",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn direction(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDirection",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Fireball<'mc>> for WitherSkull<'mc>{

fn into(self) -> crate::entity::Fireball<'mc> {

crate::entity::Fireball::from_raw(&self.jni_ref(), self.1).expect("Error converting WitherSkull into crate::entity::Fireball")

   }
}
pub enum AxolotlVariant<'mc> {
	Lucy {inner: AxolotlVariantStruct<'mc>},
	Wild {inner: AxolotlVariantStruct<'mc>},
	Gold {inner: AxolotlVariantStruct<'mc>},
	Cyan {inner: AxolotlVariantStruct<'mc>},
	Blue {inner: AxolotlVariantStruct<'mc>},
}
impl<'mc> std::fmt::Display for AxolotlVariant<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           AxolotlVariant::Lucy { .. } => f.write_str("LUCY"),
           AxolotlVariant::Wild { .. } => f.write_str("WILD"),
           AxolotlVariant::Gold { .. } => f.write_str("GOLD"),
           AxolotlVariant::Cyan { .. } => f.write_str("CYAN"),
           AxolotlVariant::Blue { .. } => f.write_str("BLUE"),
       }
   }
}

        impl<'mc> AxolotlVariant<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<AxolotlVariant<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Axolotl/Variant");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Axolotl/Variant;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"LUCY" => Ok(AxolotlVariant::Lucy { inner: AxolotlVariantStruct::from_raw(env,obj)?}),
"WILD" => Ok(AxolotlVariant::Wild { inner: AxolotlVariantStruct::from_raw(env,obj)?}),
"GOLD" => Ok(AxolotlVariant::Gold { inner: AxolotlVariantStruct::from_raw(env,obj)?}),
"CYAN" => Ok(AxolotlVariant::Cyan { inner: AxolotlVariantStruct::from_raw(env,obj)?}),
"BLUE" => Ok(AxolotlVariant::Blue { inner: AxolotlVariantStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct AxolotlVariantStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for AxolotlVariant<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Lucy { inner } => inner.0.clone(),
Self::Wild { inner } => inner.0.clone(),
Self::Gold { inner } => inner.0.clone(),
Self::Cyan { inner } => inner.0.clone(),
Self::Blue { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Lucy { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Wild { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Gold { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Cyan { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Blue { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for AxolotlVariant<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate AxolotlVariant from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Axolotl/Variant")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a AxolotlVariant object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "LUCY" => Ok(AxolotlVariant::Lucy { inner: AxolotlVariantStruct::from_raw(env,obj)?}),"WILD" => Ok(AxolotlVariant::Wild { inner: AxolotlVariantStruct::from_raw(env,obj)?}),"GOLD" => Ok(AxolotlVariant::Gold { inner: AxolotlVariantStruct::from_raw(env,obj)?}),"CYAN" => Ok(AxolotlVariant::Cyan { inner: AxolotlVariantStruct::from_raw(env,obj)?}),"BLUE" => Ok(AxolotlVariant::Blue { inner: AxolotlVariantStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for AxolotlVariantStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for AxolotlVariantStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate AxolotlVariantStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Axolotl/Variant")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a AxolotlVariantStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> AxolotlVariantStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::AxolotlVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AxolotlVariant;");
let cls = jni.find_class("org/bukkit/entity/Axolotl/Variant"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::AxolotlVariant::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Silverfish<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Silverfish<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Silverfish<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Silverfish from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Silverfish")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Silverfish object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Silverfish<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Silverfish<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Silverfish into crate::entity::Monster")

   }
}
#[repr(C)]
pub struct Vehicle<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Vehicle<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Vehicle<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Vehicle from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Vehicle")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Vehicle object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Vehicle<'mc> {
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_velocity(&self,vel: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(vel.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Vehicle<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting Vehicle into crate::entity::Entity")

   }
}
pub enum OcelotType<'mc> {
	WildOcelot {inner: OcelotTypeStruct<'mc>},
	BlackCat {inner: OcelotTypeStruct<'mc>},
	RedCat {inner: OcelotTypeStruct<'mc>},
	SiameseCat {inner: OcelotTypeStruct<'mc>},
}
impl<'mc> std::fmt::Display for OcelotType<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           OcelotType::WildOcelot { .. } => f.write_str("WILD_OCELOT"),
           OcelotType::BlackCat { .. } => f.write_str("BLACK_CAT"),
           OcelotType::RedCat { .. } => f.write_str("RED_CAT"),
           OcelotType::SiameseCat { .. } => f.write_str("SIAMESE_CAT"),
       }
   }
}

        impl<'mc> OcelotType<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<OcelotType<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Ocelot/Type");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Ocelot/Type;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"WILD_OCELOT" => Ok(OcelotType::WildOcelot { inner: OcelotTypeStruct::from_raw(env,obj)?}),
"BLACK_CAT" => Ok(OcelotType::BlackCat { inner: OcelotTypeStruct::from_raw(env,obj)?}),
"RED_CAT" => Ok(OcelotType::RedCat { inner: OcelotTypeStruct::from_raw(env,obj)?}),
"SIAMESE_CAT" => Ok(OcelotType::SiameseCat { inner: OcelotTypeStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct OcelotTypeStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for OcelotType<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::WildOcelot { inner } => inner.0.clone(),
Self::BlackCat { inner } => inner.0.clone(),
Self::RedCat { inner } => inner.0.clone(),
Self::SiameseCat { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::WildOcelot { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::BlackCat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::RedCat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::SiameseCat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for OcelotType<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate OcelotType from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ocelot/Type")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a OcelotType object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "WILD_OCELOT" => Ok(OcelotType::WildOcelot { inner: OcelotTypeStruct::from_raw(env,obj)?}),"BLACK_CAT" => Ok(OcelotType::BlackCat { inner: OcelotTypeStruct::from_raw(env,obj)?}),"RED_CAT" => Ok(OcelotType::RedCat { inner: OcelotTypeStruct::from_raw(env,obj)?}),"SIAMESE_CAT" => Ok(OcelotType::SiameseCat { inner: OcelotTypeStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for OcelotTypeStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for OcelotTypeStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate OcelotTypeStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ocelot/Type")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a OcelotTypeStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> OcelotTypeStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::OcelotType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::OcelotType;");
let cls = jni.find_class("org/bukkit/entity/Ocelot/Type"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::OcelotType::from_raw(&jni,obj
)}
#[deprecated]

	pub fn id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
#[deprecated]

	pub fn get_type(jni: &blackboxmc_general::SharedJNIEnv<'mc>,id: i32) 
-> Result<Option<crate::entity::OcelotType<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(I)Lcrate::entity::OcelotType;");
let val_1 = jni::objects::JValueGen::Int(id);
let cls = jni.find_class("org/bukkit/entity/Ocelot/Type"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"getType",
sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
jni.translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
let obj = res.l()?;
Ok(
Some(
crate::entity::OcelotType::from_raw(&jni,obj
)?
)
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Horse<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Horse<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Horse<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Horse from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Horse object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Horse<'mc> {
	pub fn color(&self) 
-> Result<crate::entity::HorseColor<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::HorseColor;");
let res = self.jni_ref().call_method(&self.jni_object(),"getColor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::HorseColor::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_color(&self,color: impl Into<crate::entity::HorseColor<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Horse/Color;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setColor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn style(&self) 
-> Result<crate::entity::HorseStyle<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::HorseStyle;");
let res = self.jni_ref().call_method(&self.jni_object(),"getStyle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::HorseStyle::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_style(&self,style: impl Into<crate::entity::HorseStyle<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Horse/Style;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(style.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setStyle",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn is_carrying_chest(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCarryingChest",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_carrying_chest(&self,chest: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(chest.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCarryingChest",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn variant(&self) 
-> Result<crate::entity::HorseVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::HorseVariant;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVariant",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::HorseVariant::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_variant(&self,variant: impl Into<crate::entity::HorseVariant<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Horse/Variant;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(variant.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVariant",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn max_domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_max_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn jump_strength(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getJumpStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_jump_strength(&self,strength: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setJumpStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_eating_haystack(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEatingHaystack",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_eating_haystack(&self,eating_haystack: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(eating_haystack.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setEatingHaystack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::AbstractHorseInventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::AbstractHorseInventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::AbstractHorseInventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_velocity(&self,vel: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(vel.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_tamed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTamed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_tamed(&self,tame: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(tame.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setTamed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn owner(&self) 
-> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AnimalTamer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOwner",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::AnimalTamer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_owner(&self,tamer: impl Into<crate::entity::AnimalTamer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(tamer.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setOwner",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::AbstractHorse<'mc>> for Horse<'mc>{

fn into(self) -> crate::entity::AbstractHorse<'mc> {

crate::entity::AbstractHorse::from_raw(&self.jni_ref(), self.1).expect("Error converting Horse into crate::entity::AbstractHorse")

   }
}
#[repr(C)]
pub struct Enemy<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Enemy<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Enemy<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Enemy from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Enemy")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Enemy object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Enemy<'mc> {
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("(Z)Lf64;");
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)LVec;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)Lcrate::block::Block;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/Set;I)LVec;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(max_distance);
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(count);
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(damage);
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Player;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lcrate::potion::PotionEffect;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(remove.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::EntityEquipment;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(ai.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/memory/MemoryKey;)Ljni::objects::JObject;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/memory/MemoryKey;Ljava/lang/Object;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(memory_value);
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(I)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Int(fall_height);
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lcrate::Sound;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_attribute(&self,attribute: impl Into<crate::attribute::Attribute<'mc>>) 
-> Result<Option<crate::attribute::AttributeInstance<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/attribute/Attribute;)Lcrate::attribute::AttributeInstance;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(attribute.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getAttribute",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::attribute::AttributeInstance::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn damage_with_amount(&self,amount: f64,damage_source: std::option::Option<impl Into<crate::damage::DamageSource<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(amount);
args.push(val_1);
if let Some(a) = damage_source {
sig += "Lorg/bukkit/damage/DamageSource;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"damage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn absorption_amount(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAbsorptionAmount",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_absorption_amount(&self,amount: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(amount);
let res = self.jni_ref().call_method(&self.jni_object(),"setAbsorptionAmount",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn max_health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_max_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn reset_max_health(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetMaxHealth",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn launch_projectile_with_projectile(&self,projectile: jni::objects::JClass<'mc>,velocity: std::option::Option<impl Into<crate::util::Vector<'mc>>>) 
-> Result<crate::entity::Projectile<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/Class;";
let val_1 = jni::objects::JValueGen::Object(projectile.into());
args.push(val_1);
if let Some(a) = velocity {
sig += "Lorg/bukkit/util/Vector;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/entity/Projectile;";
let res = self.jni_ref().call_method(&self.jni_object(),"launchProjectile",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Projectile::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::LivingEntity<'mc>> for Enemy<'mc>{

fn into(self) -> crate::entity::LivingEntity<'mc> {

crate::entity::LivingEntity::from_raw(&self.jni_ref(), self.1).expect("Error converting Enemy into crate::entity::LivingEntity")

   }
}
#[repr(C)]
pub struct Breeze<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Breeze<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Breeze<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Breeze from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Breeze")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Breeze object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Breeze<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Breeze<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Breeze into crate::entity::Monster")

   }
}
#[repr(C)]
pub struct FallingBlock<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for FallingBlock<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for FallingBlock<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate FallingBlock from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/FallingBlock")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a FallingBlock object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> FallingBlock<'mc> {
#[deprecated]

	pub fn material(&self) 
-> Result<crate::Material<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Material;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaterial",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Material::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn block_data(&self) 
-> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::data::BlockData;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBlockData",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::data::BlockData::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn drop_item(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDropItem",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_drop_item(&self,drop: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(drop.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setDropItem",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn cancel_drop(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCancelDrop",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_cancel_drop(&self,cancel_drop: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(cancel_drop.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCancelDrop",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_hurt_entities(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canHurtEntities",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_hurt_entities(&self,hurt_entities: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(hurt_entities.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setHurtEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn damage_per_block(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDamagePerBlock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_damage_per_block(&self,damage: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(damage);
let res = self.jni_ref().call_method(&self.jni_object(),"setDamagePerBlock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn max_damage(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxDamage",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_max_damage(&self,damage: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(damage);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxDamage",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for FallingBlock<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting FallingBlock into crate::entity::Entity")

   }
}
#[repr(C)]
pub struct SmallFireball<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for SmallFireball<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for SmallFireball<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate SmallFireball from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SmallFireball")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a SmallFireball object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> SmallFireball<'mc> {
	pub fn display_item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayItem",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_display_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayItem",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::SizedFireball<'mc>> for SmallFireball<'mc>{

fn into(self) -> crate::entity::SizedFireball<'mc> {

crate::entity::SizedFireball::from_raw(&self.jni_ref(), self.1).expect("Error converting SmallFireball into crate::entity::SizedFireball")

   }
}
#[repr(C)]
pub struct Axolotl<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Axolotl<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Axolotl<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Axolotl from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Axolotl")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Axolotl object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Axolotl<'mc> {
	pub fn is_playing_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPlayingDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_playing_dead(&self,playing_dead: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(playing_dead.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPlayingDead",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn variant(&self) 
-> Result<crate::entity::AxolotlVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AxolotlVariant;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVariant",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::AxolotlVariant::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_variant(&self,variant: impl Into<crate::entity::AxolotlVariant<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Axolotl/Variant;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(variant.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVariant",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Axolotl<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Axolotl into crate::entity::Animals")

   }
}
#[repr(C)]
pub struct ChestBoat<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ChestBoat<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ChestBoat<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ChestBoat from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ChestBoat")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ChestBoat object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ChestBoat<'mc> {
#[deprecated]

	pub fn wood_type(&self) 
-> Result<crate::TreeSpecies<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::TreeSpecies;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWoodType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::TreeSpecies::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_wood_type(&self,species: impl Into<crate::TreeSpecies<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/TreeSpecies;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(species.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setWoodType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn boat_type(&self) 
-> Result<crate::entity::BoatType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::BoatType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoatType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::BoatType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_boat_type(&self,val_type: impl Into<crate::entity::BoatType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Boat/Type;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBoatType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn max_speed(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxSpeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_max_speed(&self,speed: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(speed);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxSpeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn occupied_deceleration(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOccupiedDeceleration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_occupied_deceleration(&self,rate: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(rate);
let res = self.jni_ref().call_method(&self.jni_object(),"setOccupiedDeceleration",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn unoccupied_deceleration(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUnoccupiedDeceleration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_unoccupied_deceleration(&self,rate: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(rate);
let res = self.jni_ref().call_method(&self.jni_object(),"setUnoccupiedDeceleration",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn work_on_land(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorkOnLand",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_work_on_land(&self,work_on_land: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(work_on_land.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setWorkOnLand",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn status(&self) 
-> Result<crate::entity::BoatStatus<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::BoatStatus;");
let res = self.jni_ref().call_method(&self.jni_object(),"getStatus",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::BoatStatus::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_velocity(&self,vel: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(vel.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::Inventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::Inventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_loot_table(&self,table: impl Into<crate::loot::LootTable<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/loot/LootTable;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(table.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLootTable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn loot_table(&self) 
-> Result<Option<crate::loot::LootTable<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::loot::LootTable;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLootTable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::loot::LootTable::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_seed(&self,seed: i64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(J)L();");
let val_1 = jni::objects::JValueGen::Long(seed);
let res = self.jni_ref().call_method(&self.jni_object(),"setSeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn seed(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Boat<'mc>> for ChestBoat<'mc>{

fn into(self) -> crate::entity::Boat<'mc> {

crate::entity::Boat::from_raw(&self.jni_ref(), self.1).expect("Error converting ChestBoat into crate::entity::Boat")

   }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for ChestBoat<'mc>{

fn into(self) -> crate::inventory::InventoryHolder<'mc> {

crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1).expect("Error converting ChestBoat into crate::inventory::InventoryHolder")

   }
}
impl<'mc> Into<crate::loot::Lootable<'mc>> for ChestBoat<'mc>{

fn into(self) -> crate::loot::Lootable<'mc> {

crate::loot::Lootable::from_raw(&self.jni_ref(), self.1).expect("Error converting ChestBoat into crate::loot::Lootable")

   }
}
#[repr(C)]
pub struct ExperienceOrb<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ExperienceOrb<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ExperienceOrb<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ExperienceOrb from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ExperienceOrb")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ExperienceOrb object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ExperienceOrb<'mc> {
	pub fn experience(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getExperience",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_experience(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setExperience",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for ExperienceOrb<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting ExperienceOrb into crate::entity::Entity")

   }
}
#[repr(C)]
pub struct Salmon<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Salmon<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Salmon<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Salmon from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Salmon")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Salmon object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Salmon<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Fish<'mc>> for Salmon<'mc>{

fn into(self) -> crate::entity::Fish<'mc> {

crate::entity::Fish::from_raw(&self.jni_ref(), self.1).expect("Error converting Salmon into crate::entity::Fish")

   }
}
#[repr(C)]
pub struct Fireball<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Fireball<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Fireball<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Fireball from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Fireball")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Fireball object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Fireball<'mc> {
	pub fn set_direction(&self,direction: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(direction.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setDirection",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn direction(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDirection",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_yield(&self,val_yield: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(val_yield);
let res = self.jni_ref().call_method(&self.jni_object(),"setYield",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_yield(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getYield",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_is_incendiary(&self,is_incendiary: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(is_incendiary.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setIsIncendiary",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_incendiary(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isIncendiary",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for Fireball<'mc>{

fn into(self) -> crate::entity::Projectile<'mc> {

crate::entity::Projectile::from_raw(&self.jni_ref(), self.1).expect("Error converting Fireball into crate::entity::Projectile")

   }
}
impl<'mc> Into<crate::entity::Explosive<'mc>> for Fireball<'mc>{

fn into(self) -> crate::entity::Explosive<'mc> {

crate::entity::Explosive::from_raw(&self.jni_ref(), self.1).expect("Error converting Fireball into crate::entity::Explosive")

   }
}
#[repr(C)]
pub struct Enderman<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Enderman<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Enderman<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Enderman from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Enderman")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Enderman object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Enderman<'mc> {
	pub fn carried_material(&self) 
-> Result<crate::material::MaterialData<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::material::MaterialData;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCarriedMaterial",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::material::MaterialData::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_carried_material(&self,material: impl Into<crate::material::MaterialData<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/material/MaterialData;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setCarriedMaterial",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn carried_block(&self) 
-> Result<Option<crate::block::data::BlockData<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::data::BlockData;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCarriedBlock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::data::BlockData::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_carried_block(&self,block_data: impl Into<crate::block::data::BlockData<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/block/data/BlockData;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(block_data.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setCarriedBlock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_towards(&self,entity: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"teleportTowards",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Enderman<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Enderman into crate::entity::Monster")

   }
}
#[repr(C)]
pub struct WanderingTrader<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for WanderingTrader<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for WanderingTrader<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate WanderingTrader from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/WanderingTrader")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a WanderingTrader object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> WanderingTrader<'mc> {
	pub fn despawn_delay(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDespawnDelay",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_despawn_delay(&self,despawn_delay: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(despawn_delay);
let res = self.jni_ref().call_method(&self.jni_object(),"setDespawnDelay",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::Inventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::Inventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::AbstractVillager<'mc>> for WanderingTrader<'mc>{

fn into(self) -> crate::entity::AbstractVillager<'mc> {

crate::entity::AbstractVillager::from_raw(&self.jni_ref(), self.1).expect("Error converting WanderingTrader into crate::entity::AbstractVillager")

   }
}
#[repr(C)]
pub struct TNTPrimed<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for TNTPrimed<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for TNTPrimed<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate TNTPrimed from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TNTPrimed")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a TNTPrimed object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> TNTPrimed<'mc> {
	pub fn set_fuse_ticks(&self,fuse_ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(fuse_ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFuseTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn fuse_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFuseTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn source(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSource",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_source(&self,source: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setSource",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_yield(&self,val_yield: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(val_yield);
let res = self.jni_ref().call_method(&self.jni_object(),"setYield",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_yield(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getYield",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_is_incendiary(&self,is_incendiary: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(is_incendiary.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setIsIncendiary",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_incendiary(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isIncendiary",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Explosive<'mc>> for TNTPrimed<'mc>{

fn into(self) -> crate::entity::Explosive<'mc> {

crate::entity::Explosive::from_raw(&self.jni_ref(), self.1).expect("Error converting TNTPrimed into crate::entity::Explosive")

   }
}
#[repr(C)]
pub struct Illusioner<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Illusioner<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Illusioner<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Illusioner from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Illusioner")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Illusioner object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Illusioner<'mc> {
	pub fn spell(&self) 
-> Result<crate::entity::SpellcasterSpell<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpellcasterSpell;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpell",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpellcasterSpell::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_spell(&self,spell: impl Into<crate::entity::SpellcasterSpell<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Spellcaster/Spell;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(spell.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setSpell",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Spellcaster<'mc>> for Illusioner<'mc>{

fn into(self) -> crate::entity::Spellcaster<'mc> {

crate::entity::Spellcaster::from_raw(&self.jni_ref(), self.1).expect("Error converting Illusioner into crate::entity::Spellcaster")

   }
}
#[repr(C)]
pub struct EnderDragon<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for EnderDragon<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for EnderDragon<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EnderDragon from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderDragon")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EnderDragon object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> EnderDragon<'mc> {
	pub fn phase(&self) 
-> Result<crate::entity::EnderDragonPhase<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EnderDragonPhase;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPhase",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EnderDragonPhase::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_phase(&self,phase: impl Into<crate::entity::EnderDragonPhase<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/EnderDragon/Phase;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(phase.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPhase",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn dragon_battle(&self) 
-> Result<Option<crate::boss::DragonBattle<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::boss::DragonBattle;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDragonBattle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::boss::DragonBattle::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_animation_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathAnimationTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn parts(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getParts",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn boss_bar(&self) 
-> Result<Option<crate::boss::BossBar<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::boss::BossBar;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBossBar",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::boss::BossBar::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_target(&self,target: impl Into<crate::entity::LivingEntity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/LivingEntity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn target(&self) 
-> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::LivingEntity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::LivingEntity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_aware(&self,aware: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(aware.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAware",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_aware(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAware",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn ambient_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAmbientSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_eye_height_with_ignore_pose(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
args.push(val_1);
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight_with_transparent(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_with_transparent(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks_with_transparent(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air_with_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air_with_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks_with_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown_with_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body_with_count(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(count);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks_with_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage_with_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(damage);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks_with_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks_with_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Player;";
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect_with_type(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect_with_type(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/potion/PotionEffect;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect_with_type(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Collection;";
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight_with_other(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away_with_remove(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(remove.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/EntityEquipment;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items_with_pickup(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder_with_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding_with_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming_with_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai_with_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ai.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack_with_target(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation_with_yaw(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable_with_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory_with_memory_key(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += ")Ljava/lang/Object;";
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory_with_memory_key(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/Object;";
let val_2 = jni::objects::JValueGen::Object(memory_value);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound_with_fall_height(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(fall_height);
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound_with_item_stack(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound_with_item_stack(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible_with_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_loot_table(&self,table: impl Into<crate::loot::LootTable<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/loot/LootTable;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(table.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLootTable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn loot_table(&self) 
-> Result<Option<crate::loot::LootTable<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::loot::LootTable;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLootTable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::loot::LootTable::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_seed(&self,seed: i64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(J)L();");
let val_1 = jni::objects::JValueGen::Long(seed);
let res = self.jni_ref().call_method(&self.jni_object(),"setSeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn seed(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}
	pub fn get_attribute(&self,attribute: impl Into<crate::attribute::Attribute<'mc>>) 
-> Result<Option<crate::attribute::AttributeInstance<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/attribute/Attribute;)Lcrate::attribute::AttributeInstance;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(attribute.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getAttribute",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::attribute::AttributeInstance::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn damage_with_amount(&self,amount: f64,damage_source: std::option::Option<impl Into<crate::damage::DamageSource<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(amount);
args.push(val_1);
if let Some(a) = damage_source {
sig += "Lorg/bukkit/damage/DamageSource;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"damage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn absorption_amount(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAbsorptionAmount",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_absorption_amount(&self,amount: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(amount);
let res = self.jni_ref().call_method(&self.jni_object(),"setAbsorptionAmount",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn max_health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_max_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn reset_max_health(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetMaxHealth",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn launch_projectile_with_projectile(&self,projectile: jni::objects::JClass<'mc>,velocity: std::option::Option<impl Into<crate::util::Vector<'mc>>>) 
-> Result<crate::entity::Projectile<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/Class;";
let val_1 = jni::objects::JValueGen::Object(projectile.into());
args.push(val_1);
if let Some(a) = velocity {
sig += "Lorg/bukkit/util/Vector;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/entity/Projectile;";
let res = self.jni_ref().call_method(&self.jni_object(),"launchProjectile",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Projectile::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::ComplexLivingEntity<'mc>> for EnderDragon<'mc>{

fn into(self) -> crate::entity::ComplexLivingEntity<'mc> {

crate::entity::ComplexLivingEntity::from_raw(&self.jni_ref(), self.1).expect("Error converting EnderDragon into crate::entity::ComplexLivingEntity")

   }
}
impl<'mc> Into<crate::entity::Boss<'mc>> for EnderDragon<'mc>{

fn into(self) -> crate::entity::Boss<'mc> {

crate::entity::Boss::from_raw(&self.jni_ref(), self.1).expect("Error converting EnderDragon into crate::entity::Boss")

   }
}
impl<'mc> Into<crate::entity::Mob<'mc>> for EnderDragon<'mc>{

fn into(self) -> crate::entity::Mob<'mc> {

crate::entity::Mob::from_raw(&self.jni_ref(), self.1).expect("Error converting EnderDragon into crate::entity::Mob")

   }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for EnderDragon<'mc>{

fn into(self) -> crate::entity::Enemy<'mc> {

crate::entity::Enemy::from_raw(&self.jni_ref(), self.1).expect("Error converting EnderDragon into crate::entity::Enemy")

   }
}
pub enum RabbitType<'mc> {
	Brown {inner: RabbitTypeStruct<'mc>},
	White {inner: RabbitTypeStruct<'mc>},
	Black {inner: RabbitTypeStruct<'mc>},
	BlackAndWhite {inner: RabbitTypeStruct<'mc>},
	Gold {inner: RabbitTypeStruct<'mc>},
	SaltAndPepper {inner: RabbitTypeStruct<'mc>},
	TheKillerBunny {inner: RabbitTypeStruct<'mc>},
}
impl<'mc> std::fmt::Display for RabbitType<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           RabbitType::Brown { .. } => f.write_str("BROWN"),
           RabbitType::White { .. } => f.write_str("WHITE"),
           RabbitType::Black { .. } => f.write_str("BLACK"),
           RabbitType::BlackAndWhite { .. } => f.write_str("BLACK_AND_WHITE"),
           RabbitType::Gold { .. } => f.write_str("GOLD"),
           RabbitType::SaltAndPepper { .. } => f.write_str("SALT_AND_PEPPER"),
           RabbitType::TheKillerBunny { .. } => f.write_str("THE_KILLER_BUNNY"),
       }
   }
}

        impl<'mc> RabbitType<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<RabbitType<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Rabbit/Type");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Rabbit/Type;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"BROWN" => Ok(RabbitType::Brown { inner: RabbitTypeStruct::from_raw(env,obj)?}),
"WHITE" => Ok(RabbitType::White { inner: RabbitTypeStruct::from_raw(env,obj)?}),
"BLACK" => Ok(RabbitType::Black { inner: RabbitTypeStruct::from_raw(env,obj)?}),
"BLACK_AND_WHITE" => Ok(RabbitType::BlackAndWhite { inner: RabbitTypeStruct::from_raw(env,obj)?}),
"GOLD" => Ok(RabbitType::Gold { inner: RabbitTypeStruct::from_raw(env,obj)?}),
"SALT_AND_PEPPER" => Ok(RabbitType::SaltAndPepper { inner: RabbitTypeStruct::from_raw(env,obj)?}),
"THE_KILLER_BUNNY" => Ok(RabbitType::TheKillerBunny { inner: RabbitTypeStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct RabbitTypeStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for RabbitType<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Brown { inner } => inner.0.clone(),
Self::White { inner } => inner.0.clone(),
Self::Black { inner } => inner.0.clone(),
Self::BlackAndWhite { inner } => inner.0.clone(),
Self::Gold { inner } => inner.0.clone(),
Self::SaltAndPepper { inner } => inner.0.clone(),
Self::TheKillerBunny { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Brown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::White { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Black { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::BlackAndWhite { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Gold { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::SaltAndPepper { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::TheKillerBunny { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for RabbitType<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate RabbitType from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Rabbit/Type")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a RabbitType object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "BROWN" => Ok(RabbitType::Brown { inner: RabbitTypeStruct::from_raw(env,obj)?}),"WHITE" => Ok(RabbitType::White { inner: RabbitTypeStruct::from_raw(env,obj)?}),"BLACK" => Ok(RabbitType::Black { inner: RabbitTypeStruct::from_raw(env,obj)?}),"BLACK_AND_WHITE" => Ok(RabbitType::BlackAndWhite { inner: RabbitTypeStruct::from_raw(env,obj)?}),"GOLD" => Ok(RabbitType::Gold { inner: RabbitTypeStruct::from_raw(env,obj)?}),"SALT_AND_PEPPER" => Ok(RabbitType::SaltAndPepper { inner: RabbitTypeStruct::from_raw(env,obj)?}),"THE_KILLER_BUNNY" => Ok(RabbitType::TheKillerBunny { inner: RabbitTypeStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for RabbitTypeStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for RabbitTypeStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate RabbitTypeStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Rabbit/Type")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a RabbitTypeStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> RabbitTypeStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::RabbitType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::RabbitType;");
let cls = jni.find_class("org/bukkit/entity/Rabbit/Type"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::RabbitType::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
pub enum FoxType<'mc> {
	Red {inner: FoxTypeStruct<'mc>},
	Snow {inner: FoxTypeStruct<'mc>},
}
impl<'mc> std::fmt::Display for FoxType<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           FoxType::Red { .. } => f.write_str("RED"),
           FoxType::Snow { .. } => f.write_str("SNOW"),
       }
   }
}

        impl<'mc> FoxType<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<FoxType<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Fox/Type");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Fox/Type;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"RED" => Ok(FoxType::Red { inner: FoxTypeStruct::from_raw(env,obj)?}),
"SNOW" => Ok(FoxType::Snow { inner: FoxTypeStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct FoxTypeStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for FoxType<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Red { inner } => inner.0.clone(),
Self::Snow { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Red { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Snow { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for FoxType<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate FoxType from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Fox/Type")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a FoxType object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "RED" => Ok(FoxType::Red { inner: FoxTypeStruct::from_raw(env,obj)?}),"SNOW" => Ok(FoxType::Snow { inner: FoxTypeStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for FoxTypeStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for FoxTypeStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate FoxTypeStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Fox/Type")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a FoxTypeStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> FoxTypeStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::FoxType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::FoxType;");
let cls = jni.find_class("org/bukkit/entity/Fox/Type"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::FoxType::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Vindicator<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Vindicator<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Vindicator<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Vindicator from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Vindicator")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Vindicator object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Vindicator<'mc> {
	pub fn is_johnny(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isJohnny",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_johnny(&self,johnny: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(johnny.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setJohnny",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Illager<'mc>> for Vindicator<'mc>{

fn into(self) -> crate::entity::Illager<'mc> {

crate::entity::Illager::from_raw(&self.jni_ref(), self.1).expect("Error converting Vindicator into crate::entity::Illager")

   }
}
#[repr(C)]
pub struct Shulker<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Shulker<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Shulker<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Shulker from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Shulker")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Shulker object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Shulker<'mc> {
	pub fn peek(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPeek",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_peek(&self,value: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setPeek",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn attached_face(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::BlockFace;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAttachedFace",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_attached_face(&self,face: impl Into<crate::block::BlockFace<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/block/BlockFace;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(face.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setAttachedFace",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn color(&self) 
-> Result<Option<crate::DyeColor<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::DyeColor;");
let res = self.jni_ref().call_method(&self.jni_object(),"getColor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::DyeColor::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_color(&self,color: impl Into<crate::DyeColor<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/DyeColor;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setColor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
args.push(val_1);
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(count);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(damage);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Player;";
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/potion/PotionEffect;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Collection;";
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(remove.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/EntityEquipment;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ai.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += ")Ljava/lang/Object;";
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/Object;";
let val_2 = jni::objects::JValueGen::Object(memory_value);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(fall_height);
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_attribute(&self,attribute: impl Into<crate::attribute::Attribute<'mc>>) 
-> Result<Option<crate::attribute::AttributeInstance<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/attribute/Attribute;)Lcrate::attribute::AttributeInstance;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(attribute.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getAttribute",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::attribute::AttributeInstance::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn damage_with_amount(&self,amount: f64,damage_source: std::option::Option<impl Into<crate::damage::DamageSource<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(amount);
args.push(val_1);
if let Some(a) = damage_source {
sig += "Lorg/bukkit/damage/DamageSource;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"damage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn absorption_amount(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAbsorptionAmount",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_absorption_amount(&self,amount: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(amount);
let res = self.jni_ref().call_method(&self.jni_object(),"setAbsorptionAmount",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn max_health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_max_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn reset_max_health(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetMaxHealth",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn launch_projectile_with_projectile(&self,projectile: jni::objects::JClass<'mc>,velocity: std::option::Option<impl Into<crate::util::Vector<'mc>>>) 
-> Result<crate::entity::Projectile<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/Class;";
let val_1 = jni::objects::JValueGen::Object(projectile.into());
args.push(val_1);
if let Some(a) = velocity {
sig += "Lorg/bukkit/util/Vector;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/entity/Projectile;";
let res = self.jni_ref().call_method(&self.jni_object(),"launchProjectile",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Projectile::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Golem<'mc>> for Shulker<'mc>{

fn into(self) -> crate::entity::Golem<'mc> {

crate::entity::Golem::from_raw(&self.jni_ref(), self.1).expect("Error converting Shulker into crate::entity::Golem")

   }
}
impl<'mc> Into<crate::material::Colorable<'mc>> for Shulker<'mc>{

fn into(self) -> crate::material::Colorable<'mc> {

crate::material::Colorable::from_raw(&self.jni_ref(), self.1).expect("Error converting Shulker into crate::material::Colorable")

   }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for Shulker<'mc>{

fn into(self) -> crate::entity::Enemy<'mc> {

crate::entity::Enemy::from_raw(&self.jni_ref(), self.1).expect("Error converting Shulker into crate::entity::Enemy")

   }
}
#[repr(C)]
pub struct SizedFireball<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for SizedFireball<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for SizedFireball<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate SizedFireball from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SizedFireball")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a SizedFireball object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> SizedFireball<'mc> {
	pub fn display_item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayItem",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_display_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayItem",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_direction(&self,direction: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(direction.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setDirection",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn direction(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDirection",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_yield(&self,val_yield: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(val_yield);
let res = self.jni_ref().call_method(&self.jni_object(),"setYield",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_yield(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getYield",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_is_incendiary(&self,is_incendiary: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(is_incendiary.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setIsIncendiary",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_incendiary(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isIncendiary",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Fireball<'mc>> for SizedFireball<'mc>{

fn into(self) -> crate::entity::Fireball<'mc> {

crate::entity::Fireball::from_raw(&self.jni_ref(), self.1).expect("Error converting SizedFireball into crate::entity::Fireball")

   }
}
pub enum SpawnCategory<'mc> {
	Monster {inner: SpawnCategoryStruct<'mc>},
	Animal {inner: SpawnCategoryStruct<'mc>},
	WaterAnimal {inner: SpawnCategoryStruct<'mc>},
	WaterAmbient {inner: SpawnCategoryStruct<'mc>},
	WaterUndergroundCreature {inner: SpawnCategoryStruct<'mc>},
	Ambient {inner: SpawnCategoryStruct<'mc>},
	Axolotl {inner: SpawnCategoryStruct<'mc>},
	Misc {inner: SpawnCategoryStruct<'mc>},
}
impl<'mc> std::fmt::Display for SpawnCategory<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           SpawnCategory::Monster { .. } => f.write_str("MONSTER"),
           SpawnCategory::Animal { .. } => f.write_str("ANIMAL"),
           SpawnCategory::WaterAnimal { .. } => f.write_str("WATER_ANIMAL"),
           SpawnCategory::WaterAmbient { .. } => f.write_str("WATER_AMBIENT"),
           SpawnCategory::WaterUndergroundCreature { .. } => f.write_str("WATER_UNDERGROUND_CREATURE"),
           SpawnCategory::Ambient { .. } => f.write_str("AMBIENT"),
           SpawnCategory::Axolotl { .. } => f.write_str("AXOLOTL"),
           SpawnCategory::Misc { .. } => f.write_str("MISC"),
       }
   }
}

        impl<'mc> SpawnCategory<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<SpawnCategory<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/SpawnCategory");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/SpawnCategory;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"MONSTER" => Ok(SpawnCategory::Monster { inner: SpawnCategoryStruct::from_raw(env,obj)?}),
"ANIMAL" => Ok(SpawnCategory::Animal { inner: SpawnCategoryStruct::from_raw(env,obj)?}),
"WATER_ANIMAL" => Ok(SpawnCategory::WaterAnimal { inner: SpawnCategoryStruct::from_raw(env,obj)?}),
"WATER_AMBIENT" => Ok(SpawnCategory::WaterAmbient { inner: SpawnCategoryStruct::from_raw(env,obj)?}),
"WATER_UNDERGROUND_CREATURE" => Ok(SpawnCategory::WaterUndergroundCreature { inner: SpawnCategoryStruct::from_raw(env,obj)?}),
"AMBIENT" => Ok(SpawnCategory::Ambient { inner: SpawnCategoryStruct::from_raw(env,obj)?}),
"AXOLOTL" => Ok(SpawnCategory::Axolotl { inner: SpawnCategoryStruct::from_raw(env,obj)?}),
"MISC" => Ok(SpawnCategory::Misc { inner: SpawnCategoryStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct SpawnCategoryStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for SpawnCategory<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Monster { inner } => inner.0.clone(),
Self::Animal { inner } => inner.0.clone(),
Self::WaterAnimal { inner } => inner.0.clone(),
Self::WaterAmbient { inner } => inner.0.clone(),
Self::WaterUndergroundCreature { inner } => inner.0.clone(),
Self::Ambient { inner } => inner.0.clone(),
Self::Axolotl { inner } => inner.0.clone(),
Self::Misc { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Monster { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Animal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::WaterAnimal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::WaterAmbient { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::WaterUndergroundCreature { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Ambient { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Axolotl { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Misc { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for SpawnCategory<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate SpawnCategory from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SpawnCategory")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a SpawnCategory object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "MONSTER" => Ok(SpawnCategory::Monster { inner: SpawnCategoryStruct::from_raw(env,obj)?}),"ANIMAL" => Ok(SpawnCategory::Animal { inner: SpawnCategoryStruct::from_raw(env,obj)?}),"WATER_ANIMAL" => Ok(SpawnCategory::WaterAnimal { inner: SpawnCategoryStruct::from_raw(env,obj)?}),"WATER_AMBIENT" => Ok(SpawnCategory::WaterAmbient { inner: SpawnCategoryStruct::from_raw(env,obj)?}),"WATER_UNDERGROUND_CREATURE" => Ok(SpawnCategory::WaterUndergroundCreature { inner: SpawnCategoryStruct::from_raw(env,obj)?}),"AMBIENT" => Ok(SpawnCategory::Ambient { inner: SpawnCategoryStruct::from_raw(env,obj)?}),"AXOLOTL" => Ok(SpawnCategory::Axolotl { inner: SpawnCategoryStruct::from_raw(env,obj)?}),"MISC" => Ok(SpawnCategory::Misc { inner: SpawnCategoryStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for SpawnCategoryStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for SpawnCategoryStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate SpawnCategoryStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SpawnCategory")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a SpawnCategoryStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> SpawnCategoryStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let cls = jni.find_class("org/bukkit/entity/SpawnCategory"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::SpawnCategory::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct WindCharge<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for WindCharge<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for WindCharge<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate WindCharge from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/WindCharge")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a WindCharge object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> WindCharge<'mc> {
	pub fn explode(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"explode",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_direction(&self,direction: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(direction.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setDirection",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn direction(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDirection",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_yield(&self,val_yield: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(val_yield);
let res = self.jni_ref().call_method(&self.jni_object(),"setYield",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_yield(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getYield",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_is_incendiary(&self,is_incendiary: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(is_incendiary.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setIsIncendiary",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_incendiary(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isIncendiary",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Fireball<'mc>> for WindCharge<'mc>{

fn into(self) -> crate::entity::Fireball<'mc> {

crate::entity::Fireball::from_raw(&self.jni_ref(), self.1).expect("Error converting WindCharge into crate::entity::Fireball")

   }
}
#[repr(C)]
pub struct Phantom<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Phantom<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Phantom<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Phantom from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Phantom")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Phantom object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Phantom<'mc> {
	pub fn size(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSize",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_size(&self,sz: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(sz);
let res = self.jni_ref().call_method(&self.jni_object(),"setSize",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
args.push(val_1);
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(count);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(damage);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Player;";
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/potion/PotionEffect;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Collection;";
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(remove.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/EntityEquipment;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ai.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += ")Ljava/lang/Object;";
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/Object;";
let val_2 = jni::objects::JValueGen::Object(memory_value);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(fall_height);
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_attribute(&self,attribute: impl Into<crate::attribute::Attribute<'mc>>) 
-> Result<Option<crate::attribute::AttributeInstance<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/attribute/Attribute;)Lcrate::attribute::AttributeInstance;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(attribute.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getAttribute",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::attribute::AttributeInstance::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn damage_with_amount(&self,amount: f64,damage_source: std::option::Option<impl Into<crate::damage::DamageSource<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(amount);
args.push(val_1);
if let Some(a) = damage_source {
sig += "Lorg/bukkit/damage/DamageSource;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"damage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn absorption_amount(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAbsorptionAmount",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_absorption_amount(&self,amount: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(amount);
let res = self.jni_ref().call_method(&self.jni_object(),"setAbsorptionAmount",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn max_health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_max_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn reset_max_health(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetMaxHealth",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn launch_projectile_with_projectile(&self,projectile: jni::objects::JClass<'mc>,velocity: std::option::Option<impl Into<crate::util::Vector<'mc>>>) 
-> Result<crate::entity::Projectile<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/Class;";
let val_1 = jni::objects::JValueGen::Object(projectile.into());
args.push(val_1);
if let Some(a) = velocity {
sig += "Lorg/bukkit/util/Vector;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/entity/Projectile;";
let res = self.jni_ref().call_method(&self.jni_object(),"launchProjectile",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Projectile::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Flying<'mc>> for Phantom<'mc>{

fn into(self) -> crate::entity::Flying<'mc> {

crate::entity::Flying::from_raw(&self.jni_ref(), self.1).expect("Error converting Phantom into crate::entity::Flying")

   }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for Phantom<'mc>{

fn into(self) -> crate::entity::Enemy<'mc> {

crate::entity::Enemy::from_raw(&self.jni_ref(), self.1).expect("Error converting Phantom into crate::entity::Enemy")

   }
}
#[repr(C)]
pub struct Tameable<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Tameable<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Tameable<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Tameable from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Tameable")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Tameable object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Tameable<'mc> {
	pub fn is_tamed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTamed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_tamed(&self,tame: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(tame.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setTamed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn owner(&self) 
-> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AnimalTamer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOwner",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::AnimalTamer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_owner(&self,tamer: impl Into<crate::entity::AnimalTamer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(tamer.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setOwner",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Tameable<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Tameable into crate::entity::Animals")

   }
}
#[repr(C)]
pub struct Ocelot<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Ocelot<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Ocelot<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Ocelot from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ocelot")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Ocelot object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Ocelot<'mc> {
	pub fn is_trusting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTrusting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_trusting(&self,trust: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(trust.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setTrusting",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn cat_type(&self) 
-> Result<crate::entity::OcelotType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::OcelotType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCatType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::OcelotType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_cat_type(&self,val_type: impl Into<crate::entity::OcelotType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Ocelot/Type;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setCatType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Ocelot<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Ocelot into crate::entity::Animals")

   }
}
#[repr(C)]
pub struct ZombieVillager<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ZombieVillager<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ZombieVillager<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ZombieVillager from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ZombieVillager")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ZombieVillager object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ZombieVillager<'mc> {
	pub fn set_villager_profession(&self,profession: impl Into<crate::entity::VillagerProfession<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Villager/Profession;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(profession.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVillagerProfession",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn villager_profession(&self) 
-> Result<Option<crate::entity::VillagerProfession<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::VillagerProfession;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVillagerProfession",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::VillagerProfession::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn villager_type(&self) 
-> Result<crate::entity::VillagerType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::VillagerType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVillagerType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::VillagerType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_villager_type(&self,val_type: impl Into<crate::entity::VillagerType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Villager/Type;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVillagerType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_converting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isConverting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn conversion_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getConversionTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_conversion_time(&self,time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(time);
let res = self.jni_ref().call_method(&self.jni_object(),"setConversionTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn conversion_player(&self) 
-> Result<Option<crate::OfflinePlayer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::OfflinePlayer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getConversionPlayer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::OfflinePlayer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_conversion_player(&self,conversion_player: impl Into<crate::OfflinePlayer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/OfflinePlayer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(conversion_player.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setConversionPlayer",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn is_baby(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isBaby",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_baby(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn is_villager(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVillager",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_villager(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVillager",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_break_doors(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canBreakDoors",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_can_break_doors(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanBreakDoors",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Zombie<'mc>> for ZombieVillager<'mc>{

fn into(self) -> crate::entity::Zombie<'mc> {

crate::entity::Zombie::from_raw(&self.jni_ref(), self.1).expect("Error converting ZombieVillager into crate::entity::Zombie")

   }
}
#[repr(C)]
pub struct Squid<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Squid<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Squid<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Squid from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Squid")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Squid object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Squid<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::WaterMob<'mc>> for Squid<'mc>{

fn into(self) -> crate::entity::WaterMob<'mc> {

crate::entity::WaterMob::from_raw(&self.jni_ref(), self.1).expect("Error converting Squid into crate::entity::WaterMob")

   }
}
#[repr(C)]
pub struct DragonFireball<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for DragonFireball<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for DragonFireball<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate DragonFireball from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/DragonFireball")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a DragonFireball object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> DragonFireball<'mc> {
	pub fn set_direction(&self,direction: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(direction.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setDirection",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn direction(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDirection",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_yield(&self,val_yield: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(val_yield);
let res = self.jni_ref().call_method(&self.jni_object(),"setYield",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_yield(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getYield",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_is_incendiary(&self,is_incendiary: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(is_incendiary.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setIsIncendiary",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_incendiary(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isIncendiary",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Fireball<'mc>> for DragonFireball<'mc>{

fn into(self) -> crate::entity::Fireball<'mc> {

crate::entity::Fireball::from_raw(&self.jni_ref(), self.1).expect("Error converting DragonFireball into crate::entity::Fireball")

   }
}
pub enum SpellcasterSpell<'mc> {
	None {inner: SpellcasterSpellStruct<'mc>},
	SummonVex {inner: SpellcasterSpellStruct<'mc>},
	Fangs {inner: SpellcasterSpellStruct<'mc>},
	Wololo {inner: SpellcasterSpellStruct<'mc>},
	Disappear {inner: SpellcasterSpellStruct<'mc>},
	Blindness {inner: SpellcasterSpellStruct<'mc>},
}
impl<'mc> std::fmt::Display for SpellcasterSpell<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           SpellcasterSpell::None { .. } => f.write_str("NONE"),
           SpellcasterSpell::SummonVex { .. } => f.write_str("SUMMON_VEX"),
           SpellcasterSpell::Fangs { .. } => f.write_str("FANGS"),
           SpellcasterSpell::Wololo { .. } => f.write_str("WOLOLO"),
           SpellcasterSpell::Disappear { .. } => f.write_str("DISAPPEAR"),
           SpellcasterSpell::Blindness { .. } => f.write_str("BLINDNESS"),
       }
   }
}

        impl<'mc> SpellcasterSpell<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<SpellcasterSpell<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Spellcaster/Spell");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Spellcaster/Spell;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"NONE" => Ok(SpellcasterSpell::None { inner: SpellcasterSpellStruct::from_raw(env,obj)?}),
"SUMMON_VEX" => Ok(SpellcasterSpell::SummonVex { inner: SpellcasterSpellStruct::from_raw(env,obj)?}),
"FANGS" => Ok(SpellcasterSpell::Fangs { inner: SpellcasterSpellStruct::from_raw(env,obj)?}),
"WOLOLO" => Ok(SpellcasterSpell::Wololo { inner: SpellcasterSpellStruct::from_raw(env,obj)?}),
"DISAPPEAR" => Ok(SpellcasterSpell::Disappear { inner: SpellcasterSpellStruct::from_raw(env,obj)?}),
"BLINDNESS" => Ok(SpellcasterSpell::Blindness { inner: SpellcasterSpellStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct SpellcasterSpellStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for SpellcasterSpell<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::None { inner } => inner.0.clone(),
Self::SummonVex { inner } => inner.0.clone(),
Self::Fangs { inner } => inner.0.clone(),
Self::Wololo { inner } => inner.0.clone(),
Self::Disappear { inner } => inner.0.clone(),
Self::Blindness { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::SummonVex { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Fangs { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Wololo { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Disappear { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Blindness { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for SpellcasterSpell<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate SpellcasterSpell from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Spellcaster/Spell")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a SpellcasterSpell object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "NONE" => Ok(SpellcasterSpell::None { inner: SpellcasterSpellStruct::from_raw(env,obj)?}),"SUMMON_VEX" => Ok(SpellcasterSpell::SummonVex { inner: SpellcasterSpellStruct::from_raw(env,obj)?}),"FANGS" => Ok(SpellcasterSpell::Fangs { inner: SpellcasterSpellStruct::from_raw(env,obj)?}),"WOLOLO" => Ok(SpellcasterSpell::Wololo { inner: SpellcasterSpellStruct::from_raw(env,obj)?}),"DISAPPEAR" => Ok(SpellcasterSpell::Disappear { inner: SpellcasterSpellStruct::from_raw(env,obj)?}),"BLINDNESS" => Ok(SpellcasterSpell::Blindness { inner: SpellcasterSpellStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for SpellcasterSpellStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for SpellcasterSpellStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate SpellcasterSpellStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Spellcaster/Spell")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a SpellcasterSpellStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> SpellcasterSpellStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::SpellcasterSpell<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpellcasterSpell;");
let cls = jni.find_class("org/bukkit/entity/Spellcaster/Spell"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::SpellcasterSpell::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Firework<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Firework<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Firework<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Firework from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Firework")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Firework object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Firework<'mc> {
	pub fn firework_meta(&self) 
-> Result<crate::inventory::meta::FireworkMeta<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::meta::FireworkMeta;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireworkMeta",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::meta::FireworkMeta::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_firework_meta(&self,meta: impl Into<crate::inventory::meta::FireworkMeta<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/meta/FireworkMeta;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(meta.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setFireworkMeta",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_attached_to(&self,entity: impl Into<crate::entity::LivingEntity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/LivingEntity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setAttachedTo",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attached_to(&self) 
-> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::LivingEntity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAttachedTo",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::LivingEntity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_life(&self,ticks: i32) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(I)Lbool;");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLife",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn life(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLife",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_max_life(&self,ticks: i32) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(I)Lbool;");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxLife",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn max_life(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxLife",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn detonate(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"detonate",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_detonated(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDetonated",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_shot_at_angle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isShotAtAngle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_shot_at_angle(&self,shot_at_angle: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(shot_at_angle.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setShotAtAngle",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for Firework<'mc>{

fn into(self) -> crate::entity::Projectile<'mc> {

crate::entity::Projectile::from_raw(&self.jni_ref(), self.1).expect("Error converting Firework into crate::entity::Projectile")

   }
}
#[repr(C)]
pub struct Villager<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Villager<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Villager<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Villager from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Villager")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Villager object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Villager<'mc> {
	pub fn profession(&self) 
-> Result<crate::entity::VillagerProfession<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::VillagerProfession;");
let res = self.jni_ref().call_method(&self.jni_object(),"getProfession",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::VillagerProfession::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_profession(&self,profession: impl Into<crate::entity::VillagerProfession<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Villager/Profession;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(profession.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setProfession",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn villager_type(&self) 
-> Result<crate::entity::VillagerType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::VillagerType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVillagerType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::VillagerType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_villager_type(&self,val_type: impl Into<crate::entity::VillagerType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Villager/Type;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVillagerType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn villager_level(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVillagerLevel",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_villager_level(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setVillagerLevel",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn villager_experience(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVillagerExperience",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_villager_experience(&self,experience: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(experience);
let res = self.jni_ref().call_method(&self.jni_object(),"setVillagerExperience",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn sleep(&self,location: impl Into<crate::Location<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"sleep",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn wakeup(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"wakeup",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shake_head(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"shakeHead",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn zombify(&self) 
-> Result<Option<crate::entity::ZombieVillager<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::ZombieVillager;");
let res = self.jni_ref().call_method(&self.jni_object(),"zombify",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::ZombieVillager::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::Inventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::Inventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::AbstractVillager<'mc>> for Villager<'mc>{

fn into(self) -> crate::entity::AbstractVillager<'mc> {

crate::entity::AbstractVillager::from_raw(&self.jni_ref(), self.1).expect("Error converting Villager into crate::entity::AbstractVillager")

   }
}
#[repr(C)]
pub struct AbstractSkeleton<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for AbstractSkeleton<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for AbstractSkeleton<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate AbstractSkeleton from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AbstractSkeleton")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a AbstractSkeleton object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> AbstractSkeleton<'mc> {
#[deprecated]

	pub fn skeleton_type(&self) 
-> Result<crate::entity::SkeletonSkeletonType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SkeletonSkeletonType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSkeletonType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SkeletonSkeletonType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_skeleton_type(&self,val_type: impl Into<crate::entity::SkeletonSkeletonType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Skeleton/SkeletonType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setSkeletonType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for AbstractSkeleton<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting AbstractSkeleton into crate::entity::Monster")

   }
}
#[repr(C)]
pub struct ZombieHorse<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ZombieHorse<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ZombieHorse<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ZombieHorse from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ZombieHorse")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ZombieHorse object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ZombieHorse<'mc> {
#[deprecated]

	pub fn variant(&self) 
-> Result<crate::entity::HorseVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::HorseVariant;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVariant",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::HorseVariant::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_variant(&self,variant: impl Into<crate::entity::HorseVariant<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Horse/Variant;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(variant.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVariant",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn max_domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_max_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn jump_strength(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getJumpStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_jump_strength(&self,strength: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setJumpStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_eating_haystack(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEatingHaystack",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_eating_haystack(&self,eating_haystack: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(eating_haystack.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setEatingHaystack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::AbstractHorseInventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::AbstractHorseInventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::AbstractHorseInventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_velocity(&self,vel: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(vel.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_tamed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTamed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_tamed(&self,tame: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(tame.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setTamed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn owner(&self) 
-> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AnimalTamer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOwner",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::AnimalTamer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_owner(&self,tamer: impl Into<crate::entity::AnimalTamer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(tamer.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setOwner",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::AbstractHorse<'mc>> for ZombieHorse<'mc>{

fn into(self) -> crate::entity::AbstractHorse<'mc> {

crate::entity::AbstractHorse::from_raw(&self.jni_ref(), self.1).expect("Error converting ZombieHorse into crate::entity::AbstractHorse")

   }
}
#[repr(C)]
pub struct Fox<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Fox<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Fox<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Fox from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Fox")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Fox object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Fox<'mc> {
	pub fn fox_type(&self) 
-> Result<crate::entity::FoxType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::FoxType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFoxType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::FoxType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_fox_type(&self,val_type: impl Into<crate::entity::FoxType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Fox/Type;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setFoxType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_crouching(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCrouching",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_crouching(&self,crouching: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(crouching.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCrouching",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_sleeping(&self,sleeping: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(sleeping.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSleeping",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn first_trusted_player(&self) 
-> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AnimalTamer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFirstTrustedPlayer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::AnimalTamer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_first_trusted_player(&self,player: impl Into<crate::entity::AnimalTamer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(player.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setFirstTrustedPlayer",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn second_trusted_player(&self) 
-> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AnimalTamer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSecondTrustedPlayer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::AnimalTamer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_second_trusted_player(&self,player: impl Into<crate::entity::AnimalTamer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(player.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setSecondTrustedPlayer",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_faceplanted(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFaceplanted",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sitting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSitting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_sitting(&self,sitting: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(sitting.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSitting",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Fox<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Fox into crate::entity::Animals")

   }
}
impl<'mc> Into<crate::entity::Sittable<'mc>> for Fox<'mc>{

fn into(self) -> crate::entity::Sittable<'mc> {

crate::entity::Sittable::from_raw(&self.jni_ref(), self.1).expect("Error converting Fox into crate::entity::Sittable")

   }
}
#[repr(C)]
pub struct Trident<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Trident<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Trident<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Trident from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Trident")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Trident object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Trident<'mc> {
	pub fn knockback_strength(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKnockbackStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_knockback_strength(&self,knockback_strength: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(knockback_strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setKnockbackStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDamage",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(damage);
let res = self.jni_ref().call_method(&self.jni_object(),"setDamage",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn pierce_level(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPierceLevel",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_pierce_level(&self,pierce_level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(pierce_level);
let res = self.jni_ref().call_method(&self.jni_object(),"setPierceLevel",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_critical(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCritical",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_critical(&self,critical: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(critical.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCritical",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_in_block(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInBlock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attached_block(&self) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::Block;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAttachedBlock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn pickup_status(&self) 
-> Result<crate::entity::AbstractArrowPickupStatus<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AbstractArrowPickupStatus;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPickupStatus",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::AbstractArrowPickupStatus::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_pickup_status(&self,status: impl Into<crate::entity::AbstractArrowPickupStatus<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AbstractArrow/PickupStatus;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(status.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPickupStatus",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_shot_from_crossbow(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isShotFromCrossbow",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_shot_from_crossbow(&self,shot_from_crossbow: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(shot_from_crossbow.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setShotFromCrossbow",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item_with_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::AbstractArrow<'mc>> for Trident<'mc>{

fn into(self) -> crate::entity::AbstractArrow<'mc> {

crate::entity::AbstractArrow::from_raw(&self.jni_ref(), self.1).expect("Error converting Trident into crate::entity::AbstractArrow")

   }
}
impl<'mc> Into<crate::entity::ThrowableProjectile<'mc>> for Trident<'mc>{

fn into(self) -> crate::entity::ThrowableProjectile<'mc> {

crate::entity::ThrowableProjectile::from_raw(&self.jni_ref(), self.1).expect("Error converting Trident into crate::entity::ThrowableProjectile")

   }
}
#[repr(C)]
pub struct IronGolem<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for IronGolem<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for IronGolem<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate IronGolem from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/IronGolem")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a IronGolem object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> IronGolem<'mc> {
	pub fn is_player_created(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPlayerCreated",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_player_created(&self,player_created: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(player_created.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPlayerCreated",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Golem<'mc>> for IronGolem<'mc>{

fn into(self) -> crate::entity::Golem<'mc> {

crate::entity::Golem::from_raw(&self.jni_ref(), self.1).expect("Error converting IronGolem into crate::entity::Golem")

   }
}
#[repr(C)]
pub struct Turtle<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Turtle<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Turtle<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Turtle from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Turtle")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Turtle object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Turtle<'mc> {
	pub fn has_egg(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasEgg",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_laying_egg(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLayingEgg",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Turtle<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Turtle into crate::entity::Animals")

   }
}
#[repr(C)]
pub struct Drowned<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Drowned<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Drowned<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Drowned from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Drowned")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Drowned object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Drowned<'mc> {
#[deprecated]

	pub fn is_baby(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isBaby",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_baby(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn is_villager(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVillager",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_villager(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVillager",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_villager_profession(&self,profession: impl Into<crate::entity::VillagerProfession<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Villager/Profession;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(profession.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVillagerProfession",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn villager_profession(&self) 
-> Result<Option<crate::entity::VillagerProfession<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::VillagerProfession;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVillagerProfession",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::VillagerProfession::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn is_converting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isConverting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn conversion_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getConversionTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_conversion_time(&self,time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(time);
let res = self.jni_ref().call_method(&self.jni_object(),"setConversionTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_break_doors(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canBreakDoors",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_can_break_doors(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanBreakDoors",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Zombie<'mc>> for Drowned<'mc>{

fn into(self) -> crate::entity::Zombie<'mc> {

crate::entity::Zombie::from_raw(&self.jni_ref(), self.1).expect("Error converting Drowned into crate::entity::Zombie")

   }
}
pub enum DisplayBillboard<'mc> {
	Fixed {inner: DisplayBillboardStruct<'mc>},
	Vertical {inner: DisplayBillboardStruct<'mc>},
	Horizontal {inner: DisplayBillboardStruct<'mc>},
	Center {inner: DisplayBillboardStruct<'mc>},
}
impl<'mc> std::fmt::Display for DisplayBillboard<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           DisplayBillboard::Fixed { .. } => f.write_str("FIXED"),
           DisplayBillboard::Vertical { .. } => f.write_str("VERTICAL"),
           DisplayBillboard::Horizontal { .. } => f.write_str("HORIZONTAL"),
           DisplayBillboard::Center { .. } => f.write_str("CENTER"),
       }
   }
}

        impl<'mc> DisplayBillboard<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<DisplayBillboard<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Display/Billboard");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Display/Billboard;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"FIXED" => Ok(DisplayBillboard::Fixed { inner: DisplayBillboardStruct::from_raw(env,obj)?}),
"VERTICAL" => Ok(DisplayBillboard::Vertical { inner: DisplayBillboardStruct::from_raw(env,obj)?}),
"HORIZONTAL" => Ok(DisplayBillboard::Horizontal { inner: DisplayBillboardStruct::from_raw(env,obj)?}),
"CENTER" => Ok(DisplayBillboard::Center { inner: DisplayBillboardStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct DisplayBillboardStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for DisplayBillboard<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Fixed { inner } => inner.0.clone(),
Self::Vertical { inner } => inner.0.clone(),
Self::Horizontal { inner } => inner.0.clone(),
Self::Center { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Fixed { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Vertical { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Horizontal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Center { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for DisplayBillboard<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate DisplayBillboard from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Display/Billboard")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a DisplayBillboard object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "FIXED" => Ok(DisplayBillboard::Fixed { inner: DisplayBillboardStruct::from_raw(env,obj)?}),"VERTICAL" => Ok(DisplayBillboard::Vertical { inner: DisplayBillboardStruct::from_raw(env,obj)?}),"HORIZONTAL" => Ok(DisplayBillboard::Horizontal { inner: DisplayBillboardStruct::from_raw(env,obj)?}),"CENTER" => Ok(DisplayBillboard::Center { inner: DisplayBillboardStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for DisplayBillboardStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for DisplayBillboardStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate DisplayBillboardStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Display/Billboard")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a DisplayBillboardStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> DisplayBillboardStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::DisplayBillboard<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::DisplayBillboard;");
let cls = jni.find_class("org/bukkit/entity/Display/Billboard"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::DisplayBillboard::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Marker<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Marker<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Marker<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Marker from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Marker")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Marker object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Marker<'mc> {
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Marker<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting Marker into crate::entity::Entity")

   }
}
pub enum LlamaColor<'mc> {
	Creamy {inner: LlamaColorStruct<'mc>},
	White {inner: LlamaColorStruct<'mc>},
	Brown {inner: LlamaColorStruct<'mc>},
	Gray {inner: LlamaColorStruct<'mc>},
}
impl<'mc> std::fmt::Display for LlamaColor<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           LlamaColor::Creamy { .. } => f.write_str("CREAMY"),
           LlamaColor::White { .. } => f.write_str("WHITE"),
           LlamaColor::Brown { .. } => f.write_str("BROWN"),
           LlamaColor::Gray { .. } => f.write_str("GRAY"),
       }
   }
}

        impl<'mc> LlamaColor<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<LlamaColor<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Llama/Color");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Llama/Color;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"CREAMY" => Ok(LlamaColor::Creamy { inner: LlamaColorStruct::from_raw(env,obj)?}),
"WHITE" => Ok(LlamaColor::White { inner: LlamaColorStruct::from_raw(env,obj)?}),
"BROWN" => Ok(LlamaColor::Brown { inner: LlamaColorStruct::from_raw(env,obj)?}),
"GRAY" => Ok(LlamaColor::Gray { inner: LlamaColorStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct LlamaColorStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for LlamaColor<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Creamy { inner } => inner.0.clone(),
Self::White { inner } => inner.0.clone(),
Self::Brown { inner } => inner.0.clone(),
Self::Gray { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Creamy { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::White { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Brown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Gray { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for LlamaColor<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate LlamaColor from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Llama/Color")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a LlamaColor object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "CREAMY" => Ok(LlamaColor::Creamy { inner: LlamaColorStruct::from_raw(env,obj)?}),"WHITE" => Ok(LlamaColor::White { inner: LlamaColorStruct::from_raw(env,obj)?}),"BROWN" => Ok(LlamaColor::Brown { inner: LlamaColorStruct::from_raw(env,obj)?}),"GRAY" => Ok(LlamaColor::Gray { inner: LlamaColorStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for LlamaColorStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for LlamaColorStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate LlamaColorStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Llama/Color")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a LlamaColorStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> LlamaColorStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::LlamaColor<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::LlamaColor;");
let cls = jni.find_class("org/bukkit/entity/Llama/Color"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::LlamaColor::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct CaveSpider<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for CaveSpider<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for CaveSpider<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate CaveSpider from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/CaveSpider")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a CaveSpider object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> CaveSpider<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Spider<'mc>> for CaveSpider<'mc>{

fn into(self) -> crate::entity::Spider<'mc> {

crate::entity::Spider::from_raw(&self.jni_ref(), self.1).expect("Error converting CaveSpider into crate::entity::Spider")

   }
}
#[repr(C)]
pub struct Egg<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Egg<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Egg<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Egg from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Egg")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Egg object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Egg<'mc> {
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(FF)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let val_2 = jni::objects::JValueGen::Float(pitch);
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::ThrowableProjectile<'mc>> for Egg<'mc>{

fn into(self) -> crate::entity::ThrowableProjectile<'mc> {

crate::entity::ThrowableProjectile::from_raw(&self.jni_ref(), self.1).expect("Error converting Egg into crate::entity::ThrowableProjectile")

   }
}
pub enum ParrotVariant<'mc> {
	Red {inner: ParrotVariantStruct<'mc>},
	Blue {inner: ParrotVariantStruct<'mc>},
	Green {inner: ParrotVariantStruct<'mc>},
	Cyan {inner: ParrotVariantStruct<'mc>},
	Gray {inner: ParrotVariantStruct<'mc>},
}
impl<'mc> std::fmt::Display for ParrotVariant<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           ParrotVariant::Red { .. } => f.write_str("RED"),
           ParrotVariant::Blue { .. } => f.write_str("BLUE"),
           ParrotVariant::Green { .. } => f.write_str("GREEN"),
           ParrotVariant::Cyan { .. } => f.write_str("CYAN"),
           ParrotVariant::Gray { .. } => f.write_str("GRAY"),
       }
   }
}

        impl<'mc> ParrotVariant<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<ParrotVariant<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Parrot/Variant");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Parrot/Variant;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"RED" => Ok(ParrotVariant::Red { inner: ParrotVariantStruct::from_raw(env,obj)?}),
"BLUE" => Ok(ParrotVariant::Blue { inner: ParrotVariantStruct::from_raw(env,obj)?}),
"GREEN" => Ok(ParrotVariant::Green { inner: ParrotVariantStruct::from_raw(env,obj)?}),
"CYAN" => Ok(ParrotVariant::Cyan { inner: ParrotVariantStruct::from_raw(env,obj)?}),
"GRAY" => Ok(ParrotVariant::Gray { inner: ParrotVariantStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct ParrotVariantStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ParrotVariant<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Red { inner } => inner.0.clone(),
Self::Blue { inner } => inner.0.clone(),
Self::Green { inner } => inner.0.clone(),
Self::Cyan { inner } => inner.0.clone(),
Self::Gray { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Red { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Blue { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Green { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Cyan { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Gray { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for ParrotVariant<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ParrotVariant from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Parrot/Variant")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ParrotVariant object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "RED" => Ok(ParrotVariant::Red { inner: ParrotVariantStruct::from_raw(env,obj)?}),"BLUE" => Ok(ParrotVariant::Blue { inner: ParrotVariantStruct::from_raw(env,obj)?}),"GREEN" => Ok(ParrotVariant::Green { inner: ParrotVariantStruct::from_raw(env,obj)?}),"CYAN" => Ok(ParrotVariant::Cyan { inner: ParrotVariantStruct::from_raw(env,obj)?}),"GRAY" => Ok(ParrotVariant::Gray { inner: ParrotVariantStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for ParrotVariantStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ParrotVariantStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ParrotVariantStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Parrot/Variant")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ParrotVariantStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ParrotVariantStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::ParrotVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::ParrotVariant;");
let cls = jni.find_class("org/bukkit/entity/Parrot/Variant"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::ParrotVariant::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct ItemFrame<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ItemFrame<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ItemFrame<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ItemFrame from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ItemFrame")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ItemFrame object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ItemFrame<'mc> {
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item_with_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>,play_sound: std::option::Option<bool>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = play_sound {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_drop_chance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemDropChance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_item_drop_chance(&self,chance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(chance);
let res = self.jni_ref().call_method(&self.jni_object(),"setItemDropChance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn rotation(&self) 
-> Result<crate::Rotation<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Rotation;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRotation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Rotation::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation_with_yaw(&self,yaw: f32,pitch: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
if let Some(a) = pitch {
sig += "F";
let val_2 = jni::objects::JValueGen::Float(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_fixed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFixed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_fixed(&self,fixed: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fixed.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setFixed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_facing_direction_with_face(&self,face: impl Into<crate::block::BlockFace<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/block/BlockFace;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(face.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setFacingDirection",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn attached_face(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::BlockFace;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAttachedFace",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Hanging<'mc>> for ItemFrame<'mc>{

fn into(self) -> crate::entity::Hanging<'mc> {

crate::entity::Hanging::from_raw(&self.jni_ref(), self.1).expect("Error converting ItemFrame into crate::entity::Hanging")

   }
}
#[repr(C)]
pub struct Interaction<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Interaction<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Interaction<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Interaction from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Interaction")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Interaction object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Interaction<'mc> {
	pub fn interaction_width(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInteractionWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_interaction_width(&self,width: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(width);
let res = self.jni_ref().call_method(&self.jni_object(),"setInteractionWidth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn interaction_height(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInteractionHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_interaction_height(&self,height: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(height);
let res = self.jni_ref().call_method(&self.jni_object(),"setInteractionHeight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_responsive(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isResponsive",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_responsive(&self,response: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(response.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setResponsive",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_attack(&self) 
-> Result<Option<crate::entity::InteractionPreviousInteraction<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::InteractionPreviousInteraction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastAttack",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::InteractionPreviousInteraction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn last_interaction(&self) 
-> Result<Option<crate::entity::InteractionPreviousInteraction<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::InteractionPreviousInteraction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastInteraction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::InteractionPreviousInteraction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
if let Some(a) = pitch {
sig += "F";
let val_2 = jni::objects::JValueGen::Float(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Interaction<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting Interaction into crate::entity::Entity")

   }
}
#[repr(C)]
pub struct Evoker<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Evoker<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Evoker<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Evoker from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Evoker")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Evoker object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Evoker<'mc> {
#[deprecated]

	pub fn current_spell(&self) 
-> Result<crate::entity::EvokerSpell<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EvokerSpell;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCurrentSpell",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EvokerSpell::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_current_spell(&self,spell: impl Into<crate::entity::EvokerSpell<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Evoker/Spell;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(spell.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setCurrentSpell",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn spell(&self) 
-> Result<crate::entity::SpellcasterSpell<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpellcasterSpell;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpell",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpellcasterSpell::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_spell(&self,spell: impl Into<crate::entity::SpellcasterSpell<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Spellcaster/Spell;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(spell.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setSpell",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Spellcaster<'mc>> for Evoker<'mc>{

fn into(self) -> crate::entity::Spellcaster<'mc> {

crate::entity::Spellcaster::from_raw(&self.jni_ref(), self.1).expect("Error converting Evoker into crate::entity::Spellcaster")

   }
}
#[repr(C)]
pub struct Damageable<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Damageable<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Damageable<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Damageable from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Damageable")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Damageable object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Damageable<'mc> {
	pub fn damage_with_amount(&self,amount: f64,damage_source: std::option::Option<impl Into<crate::damage::DamageSource<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(amount);
args.push(val_1);
if let Some(a) = damage_source {
sig += "Lorg/bukkit/damage/DamageSource;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"damage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn absorption_amount(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAbsorptionAmount",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_absorption_amount(&self,amount: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(amount);
let res = self.jni_ref().call_method(&self.jni_object(),"setAbsorptionAmount",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn max_health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_max_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn reset_max_health(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetMaxHealth",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
if let Some(a) = pitch {
sig += "F";
let val_2 = jni::objects::JValueGen::Float(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Damageable<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting Damageable into crate::entity::Entity")

   }
}
#[repr(C)]
pub struct Wither<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Wither<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Wither<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Wither from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Wither")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Wither object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Wither<'mc> {
	pub fn set_target(&self,target: impl Into<crate::entity::LivingEntity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/LivingEntity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_target(&self,head: impl Into<crate::entity::WitherHead<'mc>>) 
-> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Wither/Head;)Lcrate::entity::LivingEntity;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(head.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::LivingEntity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn invulnerability_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInvulnerabilityTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_invulnerability_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerabilityTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn boss_bar(&self) 
-> Result<Option<crate::boss::BossBar<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::boss::BossBar;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBossBar",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::boss::BossBar::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
if let Some(a) = pitch {
sig += "F";
let val_2 = jni::objects::JValueGen::Float(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Wither<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Wither into crate::entity::Monster")

   }
}
impl<'mc> Into<crate::entity::Boss<'mc>> for Wither<'mc>{

fn into(self) -> crate::entity::Boss<'mc> {

crate::entity::Boss::from_raw(&self.jni_ref(), self.1).expect("Error converting Wither into crate::entity::Boss")

   }
}
#[repr(C)]
pub struct EnderPearl<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for EnderPearl<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for EnderPearl<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EnderPearl from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderPearl")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EnderPearl object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> EnderPearl<'mc> {
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
if let Some(a) = pitch {
sig += "F";
let val_2 = jni::objects::JValueGen::Float(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::ThrowableProjectile<'mc>> for EnderPearl<'mc>{

fn into(self) -> crate::entity::ThrowableProjectile<'mc> {

crate::entity::ThrowableProjectile::from_raw(&self.jni_ref(), self.1).expect("Error converting EnderPearl into crate::entity::ThrowableProjectile")

   }
}
#[repr(C)]
pub struct Player<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Player<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Player<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Player from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Player")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Player object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Player<'mc> {
	pub fn display_name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn set_display_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn player_list_name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPlayerListName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn set_player_list_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setPlayerListName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn player_list_header(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPlayerListHeader",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn player_list_footer(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPlayerListFooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_player_list_header(&self,header: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(header.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setPlayerListHeader",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_player_list_footer(&self,footer: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(footer.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setPlayerListFooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_player_list_header_footer(&self,header: impl Into<String>,footer: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(header.into())?));
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(footer.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setPlayerListHeaderFooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_compass_target(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setCompassTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn compass_target(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCompassTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn address(&self) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Ljni::objects::JObject;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAddress",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn send_raw_message(&self,message: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(message.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"sendRawMessage",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn kick_player(&self,message: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(message.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"kickPlayer",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn ban_with_reason(&self,reason: impl Into<String>,duration: jni::objects::JObject<'mc>,source: impl Into<String>,kick_player: std::option::Option<bool>) 
-> Result<Option<crate::BanEntry<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(reason.into())?));
args.push(val_1);
sig += "Ljava/time/Duration;";
let val_2 = jni::objects::JValueGen::Object(duration);
args.push(val_2);
sig += "Ljava/lang/String;";
let val_3 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(source.into())?));
args.push(val_3);
if let Some(a) = kick_player {
sig += "Z";
let val_4 = jni::objects::JValueGen::Bool(a.into());
args.push(val_4);
}
sig += ")Lorg/bukkit/BanEntry;";
let res = self.jni_ref().call_method(&self.jni_object(),"ban",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::BanEntry::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ban_ip_with_reason(&self,reason: impl Into<String>,duration: jni::objects::JObject<'mc>,source: impl Into<String>,kick_player: bool) 
-> Result<Option<crate::BanEntry<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(reason.into())?));
args.push(val_1);
sig += "Ljava/time/Duration;";
let val_2 = jni::objects::JValueGen::Object(duration);
args.push(val_2);
sig += "Ljava/lang/String;";
let val_3 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(source.into())?));
args.push(val_3);
sig += "Z";
let val_4 = jni::objects::JValueGen::Bool(kick_player.into());
args.push(val_4);
sig += ")Lorg/bukkit/BanEntry;";
let res = self.jni_ref().call_method(&self.jni_object(),"banIp",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::BanEntry::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn chat(&self,msg: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(msg.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"chat",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn perform_command(&self,command: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(command.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"performCommand",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sneaking(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSneaking",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_sneaking(&self,sneak: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(sneak.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSneaking",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_sprinting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSprinting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_sprinting(&self,sprinting: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(sprinting.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSprinting",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn save_data(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"saveData",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn load_data(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"loadData",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_sleeping_ignored(&self,is_sleeping: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(is_sleeping.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSleepingIgnored",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_sleeping_ignored(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSleepingIgnored",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn bed_spawn_location(&self) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBedSpawnLocation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn respawn_location(&self) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRespawnLocation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_bed_spawn_location_with_location(&self,location: impl Into<crate::Location<'mc>>,force: std::option::Option<bool>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBedSpawnLocation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_respawn_location_with_location(&self,location: impl Into<crate::Location<'mc>>,force: std::option::Option<bool>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRespawnLocation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_note_with_loc(&self,loc: impl Into<crate::Location<'mc>>,instrument: impl Into<crate::Instrument<'mc>>,note: impl Into<crate::Note<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += "Lorg/bukkit/Instrument;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(instrument.into().jni_object().clone())});
args.push(val_2);
sig += "Lorg/bukkit/Note;";
let val_3 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(note.into().jni_object().clone())});
args.push(val_3);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playNote",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_sound_with_entity(&self,entity: impl Into<crate::entity::Entity<'mc>>,sound: impl Into<String>,category: impl Into<crate::SoundCategory<'mc>>,volume: f32,pitch: std::option::Option<f32>,seed: std::option::Option<i64>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(sound.into())?));
args.push(val_2);
sig += "Lorg/bukkit/SoundCategory;";
let val_3 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(category.into().jni_object().clone())});
args.push(val_3);
sig += "F";
let val_4 = jni::objects::JValueGen::Float(volume);
args.push(val_4);
if let Some(a) = pitch {
sig += "F";
let val_5 = jni::objects::JValueGen::Float(a);
args.push(val_5);
}
if let Some(a) = seed {
sig += "J";
let val_6 = jni::objects::JValueGen::Long(a);
args.push(val_6);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playSound",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_sound_with_location(&self,location: impl Into<crate::Location<'mc>>,sound: impl Into<String>,category: impl Into<crate::SoundCategory<'mc>>,volume: f32,pitch: std::option::Option<f32>,seed: std::option::Option<i64>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(sound.into())?));
args.push(val_2);
sig += "Lorg/bukkit/SoundCategory;";
let val_3 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(category.into().jni_object().clone())});
args.push(val_3);
sig += "F";
let val_4 = jni::objects::JValueGen::Float(volume);
args.push(val_4);
if let Some(a) = pitch {
sig += "F";
let val_5 = jni::objects::JValueGen::Float(a);
args.push(val_5);
}
if let Some(a) = seed {
sig += "J";
let val_6 = jni::objects::JValueGen::Long(a);
args.push(val_6);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playSound",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn stop_sound_with_category(&self,category: impl Into<crate::SoundCategory<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/SoundCategory;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(category.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"stopSound",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn stop_sound_with_sound(&self,sound: impl Into<String>,category: std::option::Option<impl Into<crate::SoundCategory<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(sound.into())?));
args.push(val_1);
if let Some(a) = category {
sig += "Lorg/bukkit/SoundCategory;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"stopSound",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn stop_all_sounds(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"stopAllSounds",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect_with_loc(&self,loc: impl Into<crate::Location<'mc>>,effect: impl Into<crate::Effect<'mc>>,data: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += "Lorg/bukkit/Effect;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_2);
sig += "Ljava/lang/Object;";
let val_3 = jni::objects::JValueGen::Object(data);
args.push(val_3);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn break_block(&self,block: impl Into<crate::block::Block<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/block/Block;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(block.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"breakBlock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn send_block_change_with_loc(&self,loc: impl Into<crate::Location<'mc>>,material: impl Into<crate::Material<'mc>>,data: std::option::Option<i8>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += "Lorg/bukkit/Material;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_2);
if let Some(a) = data {
sig += "B";
let val_3 = jni::objects::JValueGen::Byte(a);
args.push(val_3);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendBlockChange",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_block_damage_with_loc(&self,loc: impl Into<crate::Location<'mc>>,progress: f32,source_id: std::option::Option<i32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += "F";
let val_2 = jni::objects::JValueGen::Float(progress);
args.push(val_2);
if let Some(a) = source_id {
sig += "I";
let val_3 = jni::objects::JValueGen::Int(a);
args.push(val_3);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendBlockDamage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_equipment_change_with_entity(&self,entity: impl Into<crate::entity::LivingEntity<'mc>>,slot: impl Into<crate::inventory::EquipmentSlot<'mc>>,item: std::option::Option<impl Into<crate::inventory::ItemStack<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/LivingEntity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
args.push(val_1);
sig += "Lorg/bukkit/inventory/EquipmentSlot;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(slot.into().jni_object().clone())});
args.push(val_2);
if let Some(a) = item {
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_3 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_3);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendEquipmentChange",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_sign_change_with_loc(&self,loc: impl Into<crate::Location<'mc>>,lines: impl Into<String>,dye_color: std::option::Option<impl Into<crate::DyeColor<'mc>>>,has_glowing_text: std::option::Option<bool>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(lines.into())?));
args.push(val_2);
if let Some(a) = dye_color {
sig += "Lorg/bukkit/DyeColor;";
let val_3 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_3);
}
if let Some(a) = has_glowing_text {
sig += "Z";
let val_4 = jni::objects::JValueGen::Bool(a.into());
args.push(val_4);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendSignChange",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_block_update(&self,loc: impl Into<crate::Location<'mc>>,tile_state: impl Into<crate::block::TileState<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;Lorg/bukkit/block/TileState;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(tile_state.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"sendBlockUpdate",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_potion_effect_change(&self,entity: impl Into<crate::entity::LivingEntity<'mc>>,effect: impl Into<crate::potion::PotionEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/LivingEntity;Lorg/bukkit/potion/PotionEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"sendPotionEffectChange",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_potion_effect_change_remove(&self,entity: impl Into<crate::entity::LivingEntity<'mc>>,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/LivingEntity;Lorg/bukkit/potion/PotionEffectType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"sendPotionEffectChangeRemove",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_map(&self,map: impl Into<crate::map::MapView<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/map/MapView;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(map.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"sendMap",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(yaw);
let res = self.jni_ref().call_method(&self.jni_object(),"sendHurtAnimation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn update_inventory(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"updateInventory",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn previous_game_mode(&self) 
-> Result<Option<crate::GameMode<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::GameMode;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPreviousGameMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::GameMode::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_player_time(&self,time: i64,relative: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(JZ)L();");
let val_1 = jni::objects::JValueGen::Long(time);
let val_2 = jni::objects::JValueGen::Bool(relative.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPlayerTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn player_time(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPlayerTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}
	pub fn player_time_offset(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPlayerTimeOffset",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}
	pub fn is_player_time_relative(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPlayerTimeRelative",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn reset_player_time(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetPlayerTime",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_player_weather(&self,val_type: impl Into<crate::WeatherType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/WeatherType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPlayerWeather",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn player_weather(&self) 
-> Result<Option<crate::WeatherType<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::WeatherType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPlayerWeather",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::WeatherType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn reset_player_weather(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetPlayerWeather",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn exp_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getExpCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_exp_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setExpCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn give_exp(&self,amount: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(amount);
let res = self.jni_ref().call_method(&self.jni_object(),"giveExp",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn give_exp_levels(&self,amount: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(amount);
let res = self.jni_ref().call_method(&self.jni_object(),"giveExpLevels",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn exp(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getExp",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_exp(&self,exp: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(exp);
let res = self.jni_ref().call_method(&self.jni_object(),"setExp",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn level(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLevel",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_level(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setLevel",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn total_experience(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTotalExperience",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_total_experience(&self,exp: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(exp);
let res = self.jni_ref().call_method(&self.jni_object(),"setTotalExperience",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_experience_change_with_progress(&self,progress: f32,level: std::option::Option<i32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(progress);
args.push(val_1);
if let Some(a) = level {
sig += "I";
let val_2 = jni::objects::JValueGen::Int(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendExperienceChange",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn allow_flight(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAllowFlight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_allow_flight(&self,flight: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flight.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAllowFlight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hide_player_with_plugin(&self,plugin: impl Into<crate::plugin::Plugin<'mc>>,player: std::option::Option<impl Into<crate::entity::Player<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/plugin/Plugin;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(plugin.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = player {
sig += "Lorg/bukkit/entity/Player;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"hidePlayer",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn show_player_with_plugin(&self,plugin: impl Into<crate::plugin::Plugin<'mc>>,player: std::option::Option<impl Into<crate::entity::Player<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/plugin/Plugin;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(plugin.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = player {
sig += "Lorg/bukkit/entity/Player;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"showPlayer",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_see_with_entity(&self,entity: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canSee",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn hide_entity(&self,plugin: impl Into<crate::plugin::Plugin<'mc>>,entity: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/plugin/Plugin;Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(plugin.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hideEntity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn show_entity(&self,plugin: impl Into<crate::plugin::Plugin<'mc>>,entity: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/plugin/Plugin;Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(plugin.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"showEntity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_flying(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFlying",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_flying(&self,value: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(value.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setFlying",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_fly_speed(&self,value: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setFlySpeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_walk_speed(&self,value: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setWalkSpeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn fly_speed(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFlySpeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn walk_speed(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWalkSpeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
#[deprecated]

	pub fn set_texture_pack(&self,url: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(url.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setTexturePack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_resource_pack_with_url(&self,url: impl Into<String>,hash: std::option::Option<i8>,prompt: std::option::Option<impl Into<String>>,force: std::option::Option<bool>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(url.into())?));
args.push(val_1);
if let Some(a) = hash {
sig += "B";
let val_2 = jni::objects::JValueGen::Byte(a);
args.push(val_2);
}
if let Some(a) = prompt {
sig += "Ljava/lang/String;";
let val_3 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_3);
}
if let Some(a) = force {
sig += "Z";
let val_4 = jni::objects::JValueGen::Bool(a.into());
args.push(val_4);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setResourcePack",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_resource_pack_with_id(&self,id: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,url: std::option::Option<impl Into<String>>,hash: std::option::Option<i8>,prompt: std::option::Option<impl Into<String>>,force: std::option::Option<bool>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(id.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = url {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
if let Some(a) = hash {
sig += "B";
let val_3 = jni::objects::JValueGen::Byte(a);
args.push(val_3);
}
if let Some(a) = prompt {
sig += "Ljava/lang/String;";
let val_4 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_4);
}
if let Some(a) = force {
sig += "Z";
let val_5 = jni::objects::JValueGen::Bool(a.into());
args.push(val_5);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setResourcePack",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn add_resource_pack(&self,id: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,url: impl Into<String>,hash: i8,prompt: impl Into<String>,force: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;Ljava/lang/String;BLjava/lang/String;Z)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(id.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(url.into())?));
let val_3 = jni::objects::JValueGen::Byte(hash);
let val_4 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(prompt.into())?));
let val_5 = jni::objects::JValueGen::Bool(force.into());
let res = self.jni_ref().call_method(&self.jni_object(),"addResourcePack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3),jni::objects::JValueGen::from(val_4),jni::objects::JValueGen::from(val_5)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn remove_resource_pack(&self,id: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(id.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeResourcePack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn remove_resource_packs(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"removeResourcePacks",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard(&self) 
-> Result<crate::scoreboard::Scoreboard<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::scoreboard::Scoreboard;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboard",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::scoreboard::Scoreboard::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_scoreboard(&self,scoreboard: impl Into<crate::scoreboard::Scoreboard<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/scoreboard/Scoreboard;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(scoreboard.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setScoreboard",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn world_border(&self) 
-> Result<Option<crate::WorldBorder<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::WorldBorder;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorldBorder",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::WorldBorder::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_world_border(&self,border: impl Into<crate::WorldBorder<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/WorldBorder;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(border.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setWorldBorder",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_health_update_with_health(&self,health: std::option::Option<f64>,food_level: std::option::Option<i32>,saturation: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = health {
sig += "D";
let val_1 = jni::objects::JValueGen::Double(a);
args.push(val_1);
}
if let Some(a) = food_level {
sig += "I";
let val_2 = jni::objects::JValueGen::Int(a);
args.push(val_2);
}
if let Some(a) = saturation {
sig += "F";
let val_3 = jni::objects::JValueGen::Float(a);
args.push(val_3);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendHealthUpdate",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_health_scaled(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isHealthScaled",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_health_scaled(&self,scale: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(scale.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setHealthScaled",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_health_scale(&self,scale: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(scale);
let res = self.jni_ref().call_method(&self.jni_object(),"setHealthScale",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn health_scale(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHealthScale",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn spectator_target(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpectatorTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_spectator_target(&self,entity: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setSpectatorTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_title_with_title(&self,title: impl Into<String>,subtitle: impl Into<String>,fade_in: std::option::Option<i32>,stay: std::option::Option<i32>,fade_out: std::option::Option<i32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(title.into())?));
args.push(val_1);
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(subtitle.into())?));
args.push(val_2);
if let Some(a) = fade_in {
sig += "I";
let val_3 = jni::objects::JValueGen::Int(a);
args.push(val_3);
}
if let Some(a) = stay {
sig += "I";
let val_4 = jni::objects::JValueGen::Int(a);
args.push(val_4);
}
if let Some(a) = fade_out {
sig += "I";
let val_5 = jni::objects::JValueGen::Int(a);
args.push(val_5);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendTitle",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn reset_title(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetTitle",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn spawn_particle_with_particle(&self,particle: impl Into<crate::Particle<'mc>>,x: f64,y: f64,z: std::option::Option<f64>,count: std::option::Option<i32>,offset_x: std::option::Option<f64>,offset_y: std::option::Option<f64>,offset_z: std::option::Option<f64>,extra: std::option::Option<f64>,data: std::option::Option<jni::objects::JObject<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Particle;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(particle.into().jni_object().clone())});
args.push(val_1);
sig += "D";
let val_2 = jni::objects::JValueGen::Double(x);
args.push(val_2);
sig += "D";
let val_3 = jni::objects::JValueGen::Double(y);
args.push(val_3);
if let Some(a) = z {
sig += "D";
let val_4 = jni::objects::JValueGen::Double(a);
args.push(val_4);
}
if let Some(a) = count {
sig += "I";
let val_5 = jni::objects::JValueGen::Int(a);
args.push(val_5);
}
if let Some(a) = offset_x {
sig += "D";
let val_6 = jni::objects::JValueGen::Double(a);
args.push(val_6);
}
if let Some(a) = offset_y {
sig += "D";
let val_7 = jni::objects::JValueGen::Double(a);
args.push(val_7);
}
if let Some(a) = offset_z {
sig += "D";
let val_8 = jni::objects::JValueGen::Double(a);
args.push(val_8);
}
if let Some(a) = extra {
sig += "D";
let val_9 = jni::objects::JValueGen::Double(a);
args.push(val_9);
}
if let Some(a) = data {
sig += "Ljava/lang/Object;";
let val_10 = jni::objects::JValueGen::Object(a);
args.push(val_10);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"spawnParticle",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_advancement_progress(&self,advancement: impl Into<crate::advancement::Advancement<'mc>>) 
-> Result<crate::advancement::AdvancementProgress<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/advancement/Advancement;)Lcrate::advancement::AdvancementProgress;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(advancement.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getAdvancementProgress",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::advancement::AdvancementProgress::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn client_view_distance(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getClientViewDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn ping(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn locale(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLocale",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn update_commands(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"updateCommands",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn open_book(&self,book: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(book.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"openBook",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn open_sign_with_sign(&self,sign: impl Into<crate::block::Sign<'mc>>,side: std::option::Option<impl Into<crate::block::sign::Side<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/block/Sign;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sign.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = side {
sig += "Lorg/bukkit/block/sign/Side;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"openSign",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn show_demo_screen(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"showDemoScreen",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_allowing_server_listings(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAllowingServerListings",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::PlayerInventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::PlayerInventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::PlayerInventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ender_chest(&self) 
-> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::Inventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEnderChest",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::Inventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn main_hand(&self) 
-> Result<crate::inventory::MainHand<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::MainHand;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMainHand",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::MainHand::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_window_property(&self,prop: impl Into<crate::inventory::InventoryViewProperty<'mc>>,value: i32) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/InventoryView/Property;I)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(prop.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setWindowProperty",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn enchantment_seed(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEnchantmentSeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_enchantment_seed(&self,seed: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(seed);
let res = self.jni_ref().call_method(&self.jni_object(),"setEnchantmentSeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn open_inventory_with_inventory(&self,inventory: std::option::Option<impl Into<crate::inventory::InventoryView<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = inventory {
sig += "Lorg/bukkit/inventory/InventoryView;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"openInventory",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn open_workbench(&self,location: impl Into<crate::Location<'mc>>,force: bool) 
-> Result<Option<crate::inventory::InventoryView<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;Z)Lcrate::inventory::InventoryView;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Bool(force.into());
let res = self.jni_ref().call_method(&self.jni_object(),"openWorkbench",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::InventoryView::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn open_enchanting(&self,location: impl Into<crate::Location<'mc>>,force: bool) 
-> Result<Option<crate::inventory::InventoryView<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;Z)Lcrate::inventory::InventoryView;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Bool(force.into());
let res = self.jni_ref().call_method(&self.jni_object(),"openEnchanting",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::InventoryView::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn open_merchant_with_merchant(&self,merchant: impl Into<crate::inventory::Merchant<'mc>>,force: bool) 
-> Result<Option<crate::inventory::InventoryView<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/Merchant;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(merchant.into().jni_object().clone())});
args.push(val_1);
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(force.into());
args.push(val_2);
sig += ")Lorg/bukkit/inventory/InventoryView;";
let res = self.jni_ref().call_method(&self.jni_object(),"openMerchant",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::InventoryView::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn close_inventory(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"closeInventory",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn item_in_hand(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInHand",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_item_in_hand(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInHand",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_on_cursor(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemOnCursor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item_on_cursor(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setItemOnCursor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_cooldown(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Material;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_cooldown(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Material;)Li32;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_cooldown(&self,material: impl Into<crate::Material<'mc>>,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Material;I)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn sleep_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSleepTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn sleep(&self,location: impl Into<crate::Location<'mc>>,force: bool) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;Z)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Bool(force.into());
let res = self.jni_ref().call_method(&self.jni_object(),"sleep",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn wakeup(&self,set_spawn_location: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(set_spawn_location.into());
let res = self.jni_ref().call_method(&self.jni_object(),"wakeup",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn bed_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBedLocation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn game_mode(&self) 
-> Result<crate::GameMode<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::GameMode;");
let res = self.jni_ref().call_method(&self.jni_object(),"getGameMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::GameMode::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_game_mode(&self,mode: impl Into<crate::GameMode<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/GameMode;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(mode.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setGameMode",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_blocking(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isBlocking",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_hand_raised(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isHandRaised",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn exp_to_level(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getExpToLevel",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn attack_cooldown(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAttackCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn discover_recipe(&self,recipe: impl Into<crate::NamespacedKey<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(recipe.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"discoverRecipe",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn undiscover_recipe(&self,recipe: impl Into<crate::NamespacedKey<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(recipe.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"undiscoverRecipe",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_discovered_recipe(&self,recipe: impl Into<crate::NamespacedKey<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(recipe.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasDiscoveredRecipe",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn discovered_recipes(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDiscoveredRecipes",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn shoulder_entity_left(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShoulderEntityLeft",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_shoulder_entity_left(&self,entity: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShoulderEntityLeft",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn shoulder_entity_right(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShoulderEntityRight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_shoulder_entity_right(&self,entity: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShoulderEntityRight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn drop_item(&self,drop_all: bool) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Z)Lbool;");
let val_1 = jni::objects::JValueGen::Bool(drop_all.into());
let res = self.jni_ref().call_method(&self.jni_object(),"dropItem",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn exhaustion(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getExhaustion",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_exhaustion(&self,value: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setExhaustion",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn saturation(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSaturation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_saturation(&self,value: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setSaturation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn food_level(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFoodLevel",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_food_level(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setFoodLevel",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn saturated_regen_rate(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSaturatedRegenRate",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_saturated_regen_rate(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setSaturatedRegenRate",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn unsaturated_regen_rate(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUnsaturatedRegenRate",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_unsaturated_regen_rate(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setUnsaturatedRegenRate",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn starvation_rate(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getStarvationRate",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_starvation_rate(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setStarvationRate",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_death_location(&self) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDeathLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_last_death_location(&self,location: impl Into<crate::Location<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDeathLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn firework_boost(&self,firework_item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<Option<crate::entity::Firework<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lcrate::entity::Firework;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(firework_item_stack.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"fireworkBoost",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Firework::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
args.push(val_1);
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(count);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(damage);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Player;";
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/potion/PotionEffect;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Collection;";
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(remove.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/EntityEquipment;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ai.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += ")Ljava/lang/Object;";
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/Object;";
let val_2 = jni::objects::JValueGen::Object(memory_value);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(fall_height);
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_conversing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isConversing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn accept_conversation_input(&self,input: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(input.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"acceptConversationInput",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn begin_conversation(&self,conversation: impl Into<crate::conversations::Conversation<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/conversations/Conversation;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(conversation.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"beginConversation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn abandon_conversation_with_conversation(&self,conversation: impl Into<crate::conversations::Conversation<'mc>>,details: std::option::Option<impl Into<crate::conversations::ConversationAbandonedEvent<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/conversations/Conversation;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(conversation.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = details {
sig += "Lorg/bukkit/conversations/ConversationAbandonedEvent;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"abandonConversation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_online(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnline",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn player_profile(&self) 
-> Result<crate::profile::PlayerProfile<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::profile::PlayerProfile;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPlayerProfile",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::profile::PlayerProfile::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_banned(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isBanned",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_whitelisted(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isWhitelisted",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_whitelisted(&self,value: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(value.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setWhitelisted",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn player(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Player;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPlayer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn first_played(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFirstPlayed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}
	pub fn last_played(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastPlayed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}
	pub fn has_played_before(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasPlayedBefore",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn increment_statistic_with_statistic(&self,statistic: impl Into<crate::Statistic<'mc>>,entity_type: std::option::Option<impl Into<crate::entity::EntityType<'mc>>>,amount: std::option::Option<i32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Statistic;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(statistic.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = entity_type {
sig += "Lorg/bukkit/entity/EntityType;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
if let Some(a) = amount {
sig += "I";
let val_3 = jni::objects::JValueGen::Int(a);
args.push(val_3);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"incrementStatistic",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn decrement_statistic_with_statistic(&self,statistic: impl Into<crate::Statistic<'mc>>,entity_type: std::option::Option<impl Into<crate::entity::EntityType<'mc>>>,amount: std::option::Option<i32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Statistic;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(statistic.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = entity_type {
sig += "Lorg/bukkit/entity/EntityType;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
if let Some(a) = amount {
sig += "I";
let val_3 = jni::objects::JValueGen::Int(a);
args.push(val_3);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"decrementStatistic",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_statistic_with_statistic(&self,statistic: impl Into<crate::Statistic<'mc>>,entity_type: impl Into<crate::entity::EntityType<'mc>>,new_value: std::option::Option<i32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Statistic;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(statistic.into().jni_object().clone())});
args.push(val_1);
sig += "Lorg/bukkit/entity/EntityType;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(entity_type.into().jni_object().clone())});
args.push(val_2);
if let Some(a) = new_value {
sig += "I";
let val_3 = jni::objects::JValueGen::Int(a);
args.push(val_3);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setStatistic",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_statistic_with_statistic(&self,statistic: impl Into<crate::Statistic<'mc>>,entity_type: std::option::Option<impl Into<crate::entity::EntityType<'mc>>>) 
-> Result<i32, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Statistic;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(statistic.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = entity_type {
sig += "Lorg/bukkit/entity/EntityType;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getStatistic",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn location(&self) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn is_op(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOp",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_op(&self,value: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(value.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setOp",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn serialize(&self) 
-> Result<blackboxmc_java::util::JavaMap<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Map;");
let res = self.jni_ref().call_method(&self.jni_object(),"serialize",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaMap::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn send_plugin_message(&self,source: impl Into<crate::plugin::Plugin<'mc>>,channel: impl Into<String>,message: i8) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/plugin/Plugin;Ljava/lang/String;B)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(channel.into())?));
let val_3 = jni::objects::JValueGen::Byte(message);
let res = self.jni_ref().call_method(&self.jni_object(),"sendPluginMessage",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn listening_plugin_channels(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getListeningPluginChannels",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::HumanEntity<'mc>> for Player<'mc>{

fn into(self) -> crate::entity::HumanEntity<'mc> {

crate::entity::HumanEntity::from_raw(&self.jni_ref(), self.1).expect("Error converting Player into crate::entity::HumanEntity")

   }
}
impl<'mc> Into<crate::conversations::Conversable<'mc>> for Player<'mc>{

fn into(self) -> crate::conversations::Conversable<'mc> {

crate::conversations::Conversable::from_raw(&self.jni_ref(), self.1).expect("Error converting Player into crate::conversations::Conversable")

   }
}
impl<'mc> Into<crate::OfflinePlayer<'mc>> for Player<'mc>{

fn into(self) -> crate::OfflinePlayer<'mc> {

crate::OfflinePlayer::from_raw(&self.jni_ref(), self.1).expect("Error converting Player into crate::OfflinePlayer")

   }
}
impl<'mc> Into<crate::plugin::messaging::PluginMessageRecipient<'mc>> for Player<'mc>{

fn into(self) -> crate::plugin::messaging::PluginMessageRecipient<'mc> {

crate::plugin::messaging::PluginMessageRecipient::from_raw(&self.jni_ref(), self.1).expect("Error converting Player into crate::plugin::messaging::PluginMessageRecipient")

   }
}
#[repr(C)]
pub struct Skeleton<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Skeleton<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Skeleton<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Skeleton from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Skeleton")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Skeleton object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Skeleton<'mc> {
	pub fn is_converting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isConverting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn conversion_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getConversionTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_conversion_time(&self,time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(time);
let res = self.jni_ref().call_method(&self.jni_object(),"setConversionTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn skeleton_type(&self) 
-> Result<crate::entity::SkeletonSkeletonType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SkeletonSkeletonType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSkeletonType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SkeletonSkeletonType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_skeleton_type(&self,val_type: impl Into<crate::entity::SkeletonSkeletonType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Skeleton/SkeletonType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setSkeletonType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::AbstractSkeleton<'mc>> for Skeleton<'mc>{

fn into(self) -> crate::entity::AbstractSkeleton<'mc> {

crate::entity::AbstractSkeleton::from_raw(&self.jni_ref(), self.1).expect("Error converting Skeleton into crate::entity::AbstractSkeleton")

   }
}
#[repr(C)]
pub struct PolarBear<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for PolarBear<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for PolarBear<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate PolarBear from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/PolarBear")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a PolarBear object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> PolarBear<'mc> {
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for PolarBear<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting PolarBear into crate::entity::Animals")

   }
}
#[repr(C)]
pub struct Creature<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Creature<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Creature<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Creature from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Creature")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Creature object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Creature<'mc> {
	pub fn set_target(&self,target: impl Into<crate::entity::LivingEntity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/LivingEntity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn target(&self) 
-> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::LivingEntity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::LivingEntity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_aware(&self,aware: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(aware.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAware",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_aware(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAware",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn ambient_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAmbientSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
args.push(val_1);
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(count);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(damage);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Player;";
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/potion/PotionEffect;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Collection;";
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(remove.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/EntityEquipment;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ai.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += ")Ljava/lang/Object;";
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/Object;";
let val_2 = jni::objects::JValueGen::Object(memory_value);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(fall_height);
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_loot_table(&self,table: impl Into<crate::loot::LootTable<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/loot/LootTable;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(table.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLootTable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn loot_table(&self) 
-> Result<Option<crate::loot::LootTable<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::loot::LootTable;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLootTable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::loot::LootTable::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_seed(&self,seed: i64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(J)L();");
let val_1 = jni::objects::JValueGen::Long(seed);
let res = self.jni_ref().call_method(&self.jni_object(),"setSeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn seed(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Mob<'mc>> for Creature<'mc>{

fn into(self) -> crate::entity::Mob<'mc> {

crate::entity::Mob::from_raw(&self.jni_ref(), self.1).expect("Error converting Creature into crate::entity::Mob")

   }
}
pub enum HorseStyle<'mc> {
	None {inner: HorseStyleStruct<'mc>},
	White {inner: HorseStyleStruct<'mc>},
	Whitefield {inner: HorseStyleStruct<'mc>},
	WhiteDots {inner: HorseStyleStruct<'mc>},
	BlackDots {inner: HorseStyleStruct<'mc>},
}
impl<'mc> std::fmt::Display for HorseStyle<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           HorseStyle::None { .. } => f.write_str("NONE"),
           HorseStyle::White { .. } => f.write_str("WHITE"),
           HorseStyle::Whitefield { .. } => f.write_str("WHITEFIELD"),
           HorseStyle::WhiteDots { .. } => f.write_str("WHITE_DOTS"),
           HorseStyle::BlackDots { .. } => f.write_str("BLACK_DOTS"),
       }
   }
}

        impl<'mc> HorseStyle<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<HorseStyle<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Horse/Style");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Horse/Style;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"NONE" => Ok(HorseStyle::None { inner: HorseStyleStruct::from_raw(env,obj)?}),
"WHITE" => Ok(HorseStyle::White { inner: HorseStyleStruct::from_raw(env,obj)?}),
"WHITEFIELD" => Ok(HorseStyle::Whitefield { inner: HorseStyleStruct::from_raw(env,obj)?}),
"WHITE_DOTS" => Ok(HorseStyle::WhiteDots { inner: HorseStyleStruct::from_raw(env,obj)?}),
"BLACK_DOTS" => Ok(HorseStyle::BlackDots { inner: HorseStyleStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct HorseStyleStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for HorseStyle<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::None { inner } => inner.0.clone(),
Self::White { inner } => inner.0.clone(),
Self::Whitefield { inner } => inner.0.clone(),
Self::WhiteDots { inner } => inner.0.clone(),
Self::BlackDots { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::White { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Whitefield { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::WhiteDots { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::BlackDots { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for HorseStyle<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate HorseStyle from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse/Style")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a HorseStyle object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "NONE" => Ok(HorseStyle::None { inner: HorseStyleStruct::from_raw(env,obj)?}),"WHITE" => Ok(HorseStyle::White { inner: HorseStyleStruct::from_raw(env,obj)?}),"WHITEFIELD" => Ok(HorseStyle::Whitefield { inner: HorseStyleStruct::from_raw(env,obj)?}),"WHITE_DOTS" => Ok(HorseStyle::WhiteDots { inner: HorseStyleStruct::from_raw(env,obj)?}),"BLACK_DOTS" => Ok(HorseStyle::BlackDots { inner: HorseStyleStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for HorseStyleStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for HorseStyleStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate HorseStyleStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse/Style")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a HorseStyleStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> HorseStyleStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::HorseStyle<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::HorseStyle;");
let cls = jni.find_class("org/bukkit/entity/Horse/Style"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::HorseStyle::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct ThrownExpBottle<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ThrownExpBottle<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ThrownExpBottle<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ThrownExpBottle from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ThrownExpBottle")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ThrownExpBottle object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ThrownExpBottle<'mc> {
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
if let Some(a) = pitch {
sig += "F";
let val_2 = jni::objects::JValueGen::Float(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::ThrowableProjectile<'mc>> for ThrownExpBottle<'mc>{

fn into(self) -> crate::entity::ThrowableProjectile<'mc> {

crate::entity::ThrowableProjectile::from_raw(&self.jni_ref(), self.1).expect("Error converting ThrownExpBottle into crate::entity::ThrowableProjectile")

   }
}
#[repr(C)]
pub struct Wolf<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Wolf<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Wolf<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Wolf from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Wolf")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Wolf object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Wolf<'mc> {
	pub fn is_angry(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAngry",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_angry(&self,angry: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(angry.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAngry",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn collar_color(&self) 
-> Result<crate::DyeColor<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::DyeColor;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCollarColor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::DyeColor::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_collar_color(&self,color: impl Into<crate::DyeColor<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/DyeColor;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setCollarColor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_wet(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isWet",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tail_angle(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTailAngle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn is_interested(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInterested",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_interested(&self,interested: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(interested.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInterested",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_tamed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTamed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_tamed(&self,tame: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(tame.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setTamed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn owner(&self) 
-> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AnimalTamer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOwner",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::AnimalTamer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_owner(&self,tamer: impl Into<crate::entity::AnimalTamer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(tamer.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setOwner",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sitting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSitting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_sitting(&self,sitting: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(sitting.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSitting",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Tameable<'mc>> for Wolf<'mc>{

fn into(self) -> crate::entity::Tameable<'mc> {

crate::entity::Tameable::from_raw(&self.jni_ref(), self.1).expect("Error converting Wolf into crate::entity::Tameable")

   }
}
impl<'mc> Into<crate::entity::Sittable<'mc>> for Wolf<'mc>{

fn into(self) -> crate::entity::Sittable<'mc> {

crate::entity::Sittable::from_raw(&self.jni_ref(), self.1).expect("Error converting Wolf into crate::entity::Sittable")

   }
}
#[repr(C)]
pub struct WitherSkeleton<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for WitherSkeleton<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for WitherSkeleton<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate WitherSkeleton from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/WitherSkeleton")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a WitherSkeleton object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> WitherSkeleton<'mc> {
#[deprecated]

	pub fn skeleton_type(&self) 
-> Result<crate::entity::SkeletonSkeletonType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SkeletonSkeletonType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSkeletonType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SkeletonSkeletonType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_skeleton_type(&self,val_type: impl Into<crate::entity::SkeletonSkeletonType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Skeleton/SkeletonType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setSkeletonType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::AbstractSkeleton<'mc>> for WitherSkeleton<'mc>{

fn into(self) -> crate::entity::AbstractSkeleton<'mc> {

crate::entity::AbstractSkeleton::from_raw(&self.jni_ref(), self.1).expect("Error converting WitherSkeleton into crate::entity::AbstractSkeleton")

   }
}
#[repr(C)]
pub struct ComplexLivingEntity<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ComplexLivingEntity<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ComplexLivingEntity<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ComplexLivingEntity from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ComplexLivingEntity")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ComplexLivingEntity object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ComplexLivingEntity<'mc> {
	pub fn parts(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getParts",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
args.push(val_1);
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(count);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(damage);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Player;";
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/potion/PotionEffect;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Collection;";
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(remove.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/EntityEquipment;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ai.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += ")Ljava/lang/Object;";
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/Object;";
let val_2 = jni::objects::JValueGen::Object(memory_value);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(fall_height);
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_attribute(&self,attribute: impl Into<crate::attribute::Attribute<'mc>>) 
-> Result<Option<crate::attribute::AttributeInstance<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/attribute/Attribute;)Lcrate::attribute::AttributeInstance;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(attribute.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getAttribute",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::attribute::AttributeInstance::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn damage_with_amount(&self,amount: f64,damage_source: std::option::Option<impl Into<crate::damage::DamageSource<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(amount);
args.push(val_1);
if let Some(a) = damage_source {
sig += "Lorg/bukkit/damage/DamageSource;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"damage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn absorption_amount(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAbsorptionAmount",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_absorption_amount(&self,amount: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(amount);
let res = self.jni_ref().call_method(&self.jni_object(),"setAbsorptionAmount",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn max_health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_max_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn reset_max_health(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetMaxHealth",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn launch_projectile_with_projectile(&self,projectile: jni::objects::JClass<'mc>,velocity: std::option::Option<impl Into<crate::util::Vector<'mc>>>) 
-> Result<crate::entity::Projectile<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/Class;";
let val_1 = jni::objects::JValueGen::Object(projectile.into());
args.push(val_1);
if let Some(a) = velocity {
sig += "Lorg/bukkit/util/Vector;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/entity/Projectile;";
let res = self.jni_ref().call_method(&self.jni_object(),"launchProjectile",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Projectile::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::LivingEntity<'mc>> for ComplexLivingEntity<'mc>{

fn into(self) -> crate::entity::LivingEntity<'mc> {

crate::entity::LivingEntity::from_raw(&self.jni_ref(), self.1).expect("Error converting ComplexLivingEntity into crate::entity::LivingEntity")

   }
}
#[repr(C)]
pub struct Camel<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Camel<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Camel<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Camel from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Camel")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Camel object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Camel<'mc> {
	pub fn is_dashing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDashing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_dashing(&self,dashing: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(dashing.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setDashing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn variant(&self) 
-> Result<crate::entity::HorseVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::HorseVariant;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVariant",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::HorseVariant::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_variant(&self,variant: impl Into<crate::entity::HorseVariant<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Horse/Variant;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(variant.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVariant",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn max_domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_max_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn jump_strength(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getJumpStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_jump_strength(&self,strength: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setJumpStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_eating_haystack(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEatingHaystack",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_eating_haystack(&self,eating_haystack: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(eating_haystack.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setEatingHaystack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::AbstractHorseInventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::AbstractHorseInventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::AbstractHorseInventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_velocity(&self,vel: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(vel.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_tamed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTamed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_tamed(&self,tame: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(tame.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setTamed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn owner(&self) 
-> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AnimalTamer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOwner",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::AnimalTamer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_owner(&self,tamer: impl Into<crate::entity::AnimalTamer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(tamer.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setOwner",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_sitting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSitting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_sitting(&self,sitting: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(sitting.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSitting",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::AbstractHorse<'mc>> for Camel<'mc>{

fn into(self) -> crate::entity::AbstractHorse<'mc> {

crate::entity::AbstractHorse::from_raw(&self.jni_ref(), self.1).expect("Error converting Camel into crate::entity::AbstractHorse")

   }
}
impl<'mc> Into<crate::entity::Sittable<'mc>> for Camel<'mc>{

fn into(self) -> crate::entity::Sittable<'mc> {

crate::entity::Sittable::from_raw(&self.jni_ref(), self.1).expect("Error converting Camel into crate::entity::Sittable")

   }
}
#[repr(C)]
pub struct Panda<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Panda<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Panda<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Panda from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Panda")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Panda object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Panda<'mc> {
	pub fn main_gene(&self) 
-> Result<crate::entity::PandaGene<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::PandaGene;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMainGene",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::PandaGene::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_main_gene(&self,gene: impl Into<crate::entity::PandaGene<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Panda/Gene;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(gene.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMainGene",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hidden_gene(&self) 
-> Result<crate::entity::PandaGene<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::PandaGene;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHiddenGene",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::PandaGene::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_hidden_gene(&self,gene: impl Into<crate::entity::PandaGene<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Panda/Gene;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(gene.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setHiddenGene",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_rolling(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isRolling",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_rolling(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setRolling",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_sneezing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSneezing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_sneezing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSneezing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_on_back(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnBack",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_on_back(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setOnBack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_eating(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEating",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_eating(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setEating",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_scared(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isScared",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn unhappy_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUnhappyTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sitting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSitting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_sitting(&self,sitting: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(sitting.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSitting",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Panda<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Panda into crate::entity::Animals")

   }
}
impl<'mc> Into<crate::entity::Sittable<'mc>> for Panda<'mc>{

fn into(self) -> crate::entity::Sittable<'mc> {

crate::entity::Sittable::from_raw(&self.jni_ref(), self.1).expect("Error converting Panda into crate::entity::Sittable")

   }
}
#[repr(C)]
pub struct AbstractVillager<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for AbstractVillager<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for AbstractVillager<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate AbstractVillager from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AbstractVillager")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a AbstractVillager object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> AbstractVillager<'mc> {
	pub fn inventory(&self) 
-> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::Inventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::Inventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_age_lock_with_lock(&self,lock: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(lock.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAgeLock",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn age_lock(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getAgeLock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn can_breed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_breed_with_breed(&self,breed: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(breed.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBreed",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn age(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAge",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_age(&self,age: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(age);
let res = self.jni_ref().call_method(&self.jni_object(),"setAge",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_baby(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_adult(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"setAdult",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_adult(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAdult",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn recipes(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRecipes",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn set_recipes(&self,recipes: Vec<jni::objects::JObject<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/List;)L();");
let raw_val_1 = self.jni_ref().new_object("java/util/ArrayList", "()V", vec![])?;
for v in recipes{
let map_val_0 = jni::objects::JValueGen::Object(v);
self.jni_ref().call_method(&raw_val_1,"add","(Ljava/lang/Object;)Z",vec![jni::objects::JValueGen::from(map_val_0)])?;
};
let val_1 = jni::objects::JValueGen::Object(raw_val_1);
let res = self.jni_ref().call_method(&self.jni_object(),"setRecipes",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_recipe(&self,i: i32) 
-> Result<crate::inventory::MerchantRecipe<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("(I)Lcrate::inventory::MerchantRecipe;");
let val_1 = jni::objects::JValueGen::Int(i);
let res = self.jni_ref().call_method(&self.jni_object(),"getRecipe",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::MerchantRecipe::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_recipe(&self,i: i32,recipe: impl Into<crate::inventory::MerchantRecipe<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(ILorg/bukkit/inventory/MerchantRecipe;)L();");
let val_1 = jni::objects::JValueGen::Int(i);
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(recipe.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setRecipe",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn recipe_count(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRecipeCount",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn is_trading(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTrading",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn trader(&self) 
-> Result<Option<crate::entity::HumanEntity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::HumanEntity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrader",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::HumanEntity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Breedable<'mc>> for AbstractVillager<'mc>{

fn into(self) -> crate::entity::Breedable<'mc> {

crate::entity::Breedable::from_raw(&self.jni_ref(), self.1).expect("Error converting AbstractVillager into crate::entity::Breedable")

   }
}
impl<'mc> Into<crate::entity::NPC<'mc>> for AbstractVillager<'mc>{

fn into(self) -> crate::entity::NPC<'mc> {

crate::entity::NPC::from_raw(&self.jni_ref(), self.1).expect("Error converting AbstractVillager into crate::entity::NPC")

   }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for AbstractVillager<'mc>{

fn into(self) -> crate::inventory::InventoryHolder<'mc> {

crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1).expect("Error converting AbstractVillager into crate::inventory::InventoryHolder")

   }
}
impl<'mc> Into<crate::inventory::Merchant<'mc>> for AbstractVillager<'mc>{

fn into(self) -> crate::inventory::Merchant<'mc> {

crate::inventory::Merchant::from_raw(&self.jni_ref(), self.1).expect("Error converting AbstractVillager into crate::inventory::Merchant")

   }
}
#[repr(C)]
pub struct Blaze<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Blaze<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Blaze<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Blaze from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Blaze")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Blaze object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Blaze<'mc> {

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Blaze<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Blaze into crate::entity::Monster")

   }
}
#[repr(C)]
pub struct Hoglin<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Hoglin<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Hoglin<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Hoglin from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Hoglin")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Hoglin object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Hoglin<'mc> {
	pub fn is_immune_to_zombification(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isImmuneToZombification",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_immune_to_zombification(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setImmuneToZombification",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_able_to_be_hunted(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAbleToBeHunted",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_is_able_to_be_hunted(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setIsAbleToBeHunted",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn conversion_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getConversionTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_conversion_time(&self,time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(time);
let res = self.jni_ref().call_method(&self.jni_object(),"setConversionTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_converting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isConverting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
args.push(val_1);
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(count);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(damage);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Player;";
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/potion/PotionEffect;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Collection;";
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(remove.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/EntityEquipment;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ai.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += ")Ljava/lang/Object;";
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/Object;";
let val_2 = jni::objects::JValueGen::Object(memory_value);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(fall_height);
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_attribute(&self,attribute: impl Into<crate::attribute::Attribute<'mc>>) 
-> Result<Option<crate::attribute::AttributeInstance<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/attribute/Attribute;)Lcrate::attribute::AttributeInstance;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(attribute.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getAttribute",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::attribute::AttributeInstance::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn damage_with_amount(&self,amount: f64,damage_source: std::option::Option<impl Into<crate::damage::DamageSource<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(amount);
args.push(val_1);
if let Some(a) = damage_source {
sig += "Lorg/bukkit/damage/DamageSource;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"damage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn absorption_amount(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAbsorptionAmount",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_absorption_amount(&self,amount: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(amount);
let res = self.jni_ref().call_method(&self.jni_object(),"setAbsorptionAmount",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn max_health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_max_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn reset_max_health(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetMaxHealth",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn launch_projectile_with_projectile(&self,projectile: jni::objects::JClass<'mc>,velocity: std::option::Option<impl Into<crate::util::Vector<'mc>>>) 
-> Result<crate::entity::Projectile<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/Class;";
let val_1 = jni::objects::JValueGen::Object(projectile.into());
args.push(val_1);
if let Some(a) = velocity {
sig += "Lorg/bukkit/util/Vector;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/entity/Projectile;";
let res = self.jni_ref().call_method(&self.jni_object(),"launchProjectile",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Projectile::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Hoglin<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Hoglin into crate::entity::Animals")

   }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for Hoglin<'mc>{

fn into(self) -> crate::entity::Enemy<'mc> {

crate::entity::Enemy::from_raw(&self.jni_ref(), self.1).expect("Error converting Hoglin into crate::entity::Enemy")

   }
}
#[repr(C)]
pub struct Animals<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Animals<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Animals<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Animals from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Animals")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Animals object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Animals<'mc> {
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_age_lock_with_lock(&self,lock: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(lock.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAgeLock",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn age_lock(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getAgeLock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn can_breed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_breed_with_breed(&self,breed: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(breed.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBreed",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn age(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAge",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_age(&self,age: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(age);
let res = self.jni_ref().call_method(&self.jni_object(),"setAge",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_baby(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_adult(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"setAdult",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_adult(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAdult",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Breedable<'mc>> for Animals<'mc>{

fn into(self) -> crate::entity::Breedable<'mc> {

crate::entity::Breedable::from_raw(&self.jni_ref(), self.1).expect("Error converting Animals into crate::entity::Breedable")

   }
}
#[repr(C)]
pub struct ArmorStand<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ArmorStand<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ArmorStand<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ArmorStand from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ArmorStand")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ArmorStand object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ArmorStand<'mc> {
#[deprecated]

	pub fn item_in_hand(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInHand",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_item_in_hand(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInHand",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn boots(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoots",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_boots(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBoots",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn leggings(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLeggings",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_leggings(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLeggings",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn chestplate(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getChestplate",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_chestplate(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setChestplate",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn helmet(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHelmet",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_helmet(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setHelmet",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn body_pose(&self) 
-> Result<crate::util::EulerAngle<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::EulerAngle;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBodyPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::EulerAngle::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_body_pose(&self,pose: impl Into<crate::util::EulerAngle<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/EulerAngle;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(pose.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBodyPose",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn left_arm_pose(&self) 
-> Result<crate::util::EulerAngle<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::EulerAngle;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLeftArmPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::EulerAngle::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_left_arm_pose(&self,pose: impl Into<crate::util::EulerAngle<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/EulerAngle;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(pose.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLeftArmPose",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn right_arm_pose(&self) 
-> Result<crate::util::EulerAngle<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::EulerAngle;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRightArmPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::EulerAngle::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_right_arm_pose(&self,pose: impl Into<crate::util::EulerAngle<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/EulerAngle;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(pose.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setRightArmPose",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn left_leg_pose(&self) 
-> Result<crate::util::EulerAngle<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::EulerAngle;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLeftLegPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::EulerAngle::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_left_leg_pose(&self,pose: impl Into<crate::util::EulerAngle<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/EulerAngle;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(pose.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLeftLegPose",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn right_leg_pose(&self) 
-> Result<crate::util::EulerAngle<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::EulerAngle;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRightLegPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::EulerAngle::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_right_leg_pose(&self,pose: impl Into<crate::util::EulerAngle<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/EulerAngle;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(pose.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setRightLegPose",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn head_pose(&self) 
-> Result<crate::util::EulerAngle<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::EulerAngle;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeadPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::EulerAngle::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_head_pose(&self,pose: impl Into<crate::util::EulerAngle<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/EulerAngle;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(pose.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setHeadPose",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_base_plate(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasBasePlate",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_base_plate(&self,base_plate: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(base_plate.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBasePlate",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_arms(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasArms",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_arms(&self,arms: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(arms.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setArms",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_small(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSmall",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_small(&self,small: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(small.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSmall",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_marker(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isMarker",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_marker(&self,marker: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(marker.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setMarker",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn add_equipment_lock(&self,slot: impl Into<crate::inventory::EquipmentSlot<'mc>>,lock_type: impl Into<crate::entity::ArmorStandLockType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/EquipmentSlot;Lorg/bukkit/entity/ArmorStand/LockType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(slot.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(lock_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addEquipmentLock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn remove_equipment_lock(&self,slot: impl Into<crate::inventory::EquipmentSlot<'mc>>,lock_type: impl Into<crate::entity::ArmorStandLockType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/EquipmentSlot;Lorg/bukkit/entity/ArmorStand/LockType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(slot.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(lock_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeEquipmentLock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_equipment_lock(&self,slot: impl Into<crate::inventory::EquipmentSlot<'mc>>,lock_type: impl Into<crate::entity::ArmorStandLockType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/EquipmentSlot;Lorg/bukkit/entity/ArmorStand/LockType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(slot.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(lock_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasEquipmentLock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
args.push(val_1);
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(count);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(damage);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Player;";
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/potion/PotionEffect;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Collection;";
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(remove.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/EntityEquipment;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ai.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += ")Ljava/lang/Object;";
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/Object;";
let val_2 = jni::objects::JValueGen::Object(memory_value);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(fall_height);
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_attribute(&self,attribute: impl Into<crate::attribute::Attribute<'mc>>) 
-> Result<Option<crate::attribute::AttributeInstance<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/attribute/Attribute;)Lcrate::attribute::AttributeInstance;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(attribute.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getAttribute",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::attribute::AttributeInstance::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn damage_with_amount(&self,amount: f64,damage_source: std::option::Option<impl Into<crate::damage::DamageSource<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(amount);
args.push(val_1);
if let Some(a) = damage_source {
sig += "Lorg/bukkit/damage/DamageSource;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"damage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn absorption_amount(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAbsorptionAmount",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_absorption_amount(&self,amount: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(amount);
let res = self.jni_ref().call_method(&self.jni_object(),"setAbsorptionAmount",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn max_health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_max_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn reset_max_health(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetMaxHealth",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn launch_projectile_with_projectile(&self,projectile: jni::objects::JClass<'mc>,velocity: std::option::Option<impl Into<crate::util::Vector<'mc>>>) 
-> Result<crate::entity::Projectile<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/Class;";
let val_1 = jni::objects::JValueGen::Object(projectile.into());
args.push(val_1);
if let Some(a) = velocity {
sig += "Lorg/bukkit/util/Vector;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/entity/Projectile;";
let res = self.jni_ref().call_method(&self.jni_object(),"launchProjectile",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Projectile::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::LivingEntity<'mc>> for ArmorStand<'mc>{

fn into(self) -> crate::entity::LivingEntity<'mc> {

crate::entity::LivingEntity::from_raw(&self.jni_ref(), self.1).expect("Error converting ArmorStand into crate::entity::LivingEntity")

   }
}
#[repr(C)]
pub struct Creeper<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Creeper<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Creeper<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Creeper from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Creeper")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Creeper object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Creeper<'mc> {
	pub fn is_powered(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPowered",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_powered(&self,value: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(value.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPowered",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_max_fuse_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxFuseTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn max_fuse_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFuseTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fuse_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFuseTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn fuse_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFuseTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_explosion_radius(&self,radius: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(radius);
let res = self.jni_ref().call_method(&self.jni_object(),"setExplosionRadius",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn explosion_radius(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getExplosionRadius",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn explode(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"explode",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn ignite(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"ignite",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Creeper<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Creeper into crate::entity::Monster")

   }
}
#[repr(C)]
pub struct Illager<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Illager<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Illager<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Illager from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Illager")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Illager object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Illager<'mc> {
	pub fn set_raid(&self,raid: impl Into<crate::Raid<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Raid;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(raid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn raid(&self) 
-> Result<Option<crate::Raid<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Raid;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Raid::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn wave(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWave",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_wave(&self,wave: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(wave);
let res = self.jni_ref().call_method(&self.jni_object(),"setWave",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn patrol_target(&self) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::Block;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPatrolTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_patrol_target(&self,block: impl Into<crate::block::Block<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/block/Block;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(block.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPatrolTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_patrol_leader(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPatrolLeader",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_patrol_leader(&self,leader: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(leader.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPatrolLeader",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_can_join_raid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCanJoinRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_can_join_raid(&self,join: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(join.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanJoinRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn ticks_outside_raid(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksOutsideRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_outside_raid(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksOutsideRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_celebrating(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCelebrating",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_celebrating(&self,celebrating: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(celebrating.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCelebrating",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn celebration_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCelebrationSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Raider<'mc>> for Illager<'mc>{

fn into(self) -> crate::entity::Raider<'mc> {

crate::entity::Raider::from_raw(&self.jni_ref(), self.1).expect("Error converting Illager into crate::entity::Raider")

   }
}
pub enum PandaGene<'mc> {
	Normal {inner: PandaGeneStruct<'mc>},
	Lazy {inner: PandaGeneStruct<'mc>},
	Worried {inner: PandaGeneStruct<'mc>},
	Playful {inner: PandaGeneStruct<'mc>},
	Brown {inner: PandaGeneStruct<'mc>},
	Weak {inner: PandaGeneStruct<'mc>},
	Aggressive {inner: PandaGeneStruct<'mc>},
}
impl<'mc> std::fmt::Display for PandaGene<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           PandaGene::Normal { .. } => f.write_str("NORMAL"),
           PandaGene::Lazy { .. } => f.write_str("LAZY"),
           PandaGene::Worried { .. } => f.write_str("WORRIED"),
           PandaGene::Playful { .. } => f.write_str("PLAYFUL"),
           PandaGene::Brown { .. } => f.write_str("BROWN"),
           PandaGene::Weak { .. } => f.write_str("WEAK"),
           PandaGene::Aggressive { .. } => f.write_str("AGGRESSIVE"),
       }
   }
}

        impl<'mc> PandaGene<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<PandaGene<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Panda/Gene");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Panda/Gene;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"NORMAL" => Ok(PandaGene::Normal { inner: PandaGeneStruct::from_raw(env,obj)?}),
"LAZY" => Ok(PandaGene::Lazy { inner: PandaGeneStruct::from_raw(env,obj)?}),
"WORRIED" => Ok(PandaGene::Worried { inner: PandaGeneStruct::from_raw(env,obj)?}),
"PLAYFUL" => Ok(PandaGene::Playful { inner: PandaGeneStruct::from_raw(env,obj)?}),
"BROWN" => Ok(PandaGene::Brown { inner: PandaGeneStruct::from_raw(env,obj)?}),
"WEAK" => Ok(PandaGene::Weak { inner: PandaGeneStruct::from_raw(env,obj)?}),
"AGGRESSIVE" => Ok(PandaGene::Aggressive { inner: PandaGeneStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct PandaGeneStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for PandaGene<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Normal { inner } => inner.0.clone(),
Self::Lazy { inner } => inner.0.clone(),
Self::Worried { inner } => inner.0.clone(),
Self::Playful { inner } => inner.0.clone(),
Self::Brown { inner } => inner.0.clone(),
Self::Weak { inner } => inner.0.clone(),
Self::Aggressive { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Normal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Lazy { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Worried { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Playful { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Brown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Weak { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Aggressive { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for PandaGene<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate PandaGene from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Panda/Gene")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a PandaGene object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "NORMAL" => Ok(PandaGene::Normal { inner: PandaGeneStruct::from_raw(env,obj)?}),"LAZY" => Ok(PandaGene::Lazy { inner: PandaGeneStruct::from_raw(env,obj)?}),"WORRIED" => Ok(PandaGene::Worried { inner: PandaGeneStruct::from_raw(env,obj)?}),"PLAYFUL" => Ok(PandaGene::Playful { inner: PandaGeneStruct::from_raw(env,obj)?}),"BROWN" => Ok(PandaGene::Brown { inner: PandaGeneStruct::from_raw(env,obj)?}),"WEAK" => Ok(PandaGene::Weak { inner: PandaGeneStruct::from_raw(env,obj)?}),"AGGRESSIVE" => Ok(PandaGene::Aggressive { inner: PandaGeneStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for PandaGeneStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for PandaGeneStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate PandaGeneStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Panda/Gene")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a PandaGeneStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> PandaGeneStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::PandaGene<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::PandaGene;");
let cls = jni.find_class("org/bukkit/entity/Panda/Gene"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::PandaGene::from_raw(&jni,obj
)}
	pub fn is_recessive(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isRecessive",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Explosive<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Explosive<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Explosive<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Explosive from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Explosive")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Explosive object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Explosive<'mc> {
	pub fn set_yield(&self,val_yield: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(val_yield);
let res = self.jni_ref().call_method(&self.jni_object(),"setYield",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_yield(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getYield",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_is_incendiary(&self,is_incendiary: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(is_incendiary.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setIsIncendiary",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_incendiary(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isIncendiary",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
if let Some(a) = pitch {
sig += "F";
let val_2 = jni::objects::JValueGen::Float(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Explosive<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting Explosive into crate::entity::Entity")

   }
}
#[repr(C)]
pub struct Zombie<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Zombie<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Zombie<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Zombie from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Zombie")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Zombie object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Zombie<'mc> {
#[deprecated]

	pub fn is_baby(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isBaby",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_baby_with_flag(&self,flag: std::option::Option<bool>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = flag {
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(a.into());
args.push(val_1);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn is_villager(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVillager",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_villager(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVillager",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_villager_profession(&self,profession: impl Into<crate::entity::VillagerProfession<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Villager/Profession;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(profession.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVillagerProfession",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn villager_profession(&self) 
-> Result<Option<crate::entity::VillagerProfession<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::VillagerProfession;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVillagerProfession",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::VillagerProfession::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn is_converting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isConverting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn conversion_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getConversionTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_conversion_time(&self,time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(time);
let res = self.jni_ref().call_method(&self.jni_object(),"setConversionTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_break_doors(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canBreakDoors",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_can_break_doors(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanBreakDoors",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn age(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAge",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_age(&self,age: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(age);
let res = self.jni_ref().call_method(&self.jni_object(),"setAge",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_age_lock(&self,lock: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(lock.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAgeLock",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn age_lock(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getAgeLock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_adult(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"setAdult",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_adult(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAdult",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn can_breed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_breed(&self,breed: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(breed.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBreed",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Zombie<'mc>{

fn into(self) -> crate::entity::Monster<'mc> {

crate::entity::Monster::from_raw(&self.jni_ref(), self.1).expect("Error converting Zombie into crate::entity::Monster")

   }
}
impl<'mc> Into<crate::entity::Ageable<'mc>> for Zombie<'mc>{

fn into(self) -> crate::entity::Ageable<'mc> {

crate::entity::Ageable::from_raw(&self.jni_ref(), self.1).expect("Error converting Zombie into crate::entity::Ageable")

   }
}
#[repr(C)]
pub struct Tadpole<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Tadpole<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Tadpole<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Tadpole from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Tadpole")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Tadpole object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Tadpole<'mc> {
	pub fn age(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAge",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_age(&self,age: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(age);
let res = self.jni_ref().call_method(&self.jni_object(),"setAge",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Fish<'mc>> for Tadpole<'mc>{

fn into(self) -> crate::entity::Fish<'mc> {

crate::entity::Fish::from_raw(&self.jni_ref(), self.1).expect("Error converting Tadpole into crate::entity::Fish")

   }
}
#[repr(C)]
pub struct SkeletonHorse<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for SkeletonHorse<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for SkeletonHorse<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate SkeletonHorse from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SkeletonHorse")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a SkeletonHorse object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> SkeletonHorse<'mc> {
	pub fn is_trapped(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTrapped",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_trapped(&self,trapped: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(trapped.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setTrapped",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn trap_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrapTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_trap_time(&self,trap_time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(trap_time);
let res = self.jni_ref().call_method(&self.jni_object(),"setTrapTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn variant(&self) 
-> Result<crate::entity::HorseVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::HorseVariant;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVariant",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::HorseVariant::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_variant(&self,variant: impl Into<crate::entity::HorseVariant<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Horse/Variant;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(variant.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVariant",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn max_domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_max_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn jump_strength(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getJumpStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_jump_strength(&self,strength: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setJumpStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_eating_haystack(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEatingHaystack",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_eating_haystack(&self,eating_haystack: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(eating_haystack.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setEatingHaystack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::AbstractHorseInventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::AbstractHorseInventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::AbstractHorseInventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_velocity(&self,vel: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(vel.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_tamed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTamed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_tamed(&self,tame: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(tame.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setTamed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn owner(&self) 
-> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AnimalTamer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOwner",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::AnimalTamer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_owner(&self,tamer: impl Into<crate::entity::AnimalTamer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(tamer.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setOwner",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::AbstractHorse<'mc>> for SkeletonHorse<'mc>{

fn into(self) -> crate::entity::AbstractHorse<'mc> {

crate::entity::AbstractHorse::from_raw(&self.jni_ref(), self.1).expect("Error converting SkeletonHorse into crate::entity::AbstractHorse")

   }
}
pub enum EntityCategory<'mc> {
	None {inner: EntityCategoryStruct<'mc>},
	Undead {inner: EntityCategoryStruct<'mc>},
	Arthropod {inner: EntityCategoryStruct<'mc>},
	Illager {inner: EntityCategoryStruct<'mc>},
	Water {inner: EntityCategoryStruct<'mc>},
}
impl<'mc> std::fmt::Display for EntityCategory<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           EntityCategory::None { .. } => f.write_str("NONE"),
           EntityCategory::Undead { .. } => f.write_str("UNDEAD"),
           EntityCategory::Arthropod { .. } => f.write_str("ARTHROPOD"),
           EntityCategory::Illager { .. } => f.write_str("ILLAGER"),
           EntityCategory::Water { .. } => f.write_str("WATER"),
       }
   }
}

        impl<'mc> EntityCategory<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<EntityCategory<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/EntityCategory");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/EntityCategory;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"NONE" => Ok(EntityCategory::None { inner: EntityCategoryStruct::from_raw(env,obj)?}),
"UNDEAD" => Ok(EntityCategory::Undead { inner: EntityCategoryStruct::from_raw(env,obj)?}),
"ARTHROPOD" => Ok(EntityCategory::Arthropod { inner: EntityCategoryStruct::from_raw(env,obj)?}),
"ILLAGER" => Ok(EntityCategory::Illager { inner: EntityCategoryStruct::from_raw(env,obj)?}),
"WATER" => Ok(EntityCategory::Water { inner: EntityCategoryStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct EntityCategoryStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for EntityCategory<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::None { inner } => inner.0.clone(),
Self::Undead { inner } => inner.0.clone(),
Self::Arthropod { inner } => inner.0.clone(),
Self::Illager { inner } => inner.0.clone(),
Self::Water { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Undead { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Arthropod { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Illager { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Water { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for EntityCategory<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EntityCategory from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EntityCategory")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EntityCategory object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "NONE" => Ok(EntityCategory::None { inner: EntityCategoryStruct::from_raw(env,obj)?}),"UNDEAD" => Ok(EntityCategory::Undead { inner: EntityCategoryStruct::from_raw(env,obj)?}),"ARTHROPOD" => Ok(EntityCategory::Arthropod { inner: EntityCategoryStruct::from_raw(env,obj)?}),"ILLAGER" => Ok(EntityCategory::Illager { inner: EntityCategoryStruct::from_raw(env,obj)?}),"WATER" => Ok(EntityCategory::Water { inner: EntityCategoryStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for EntityCategoryStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for EntityCategoryStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EntityCategoryStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EntityCategory")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EntityCategoryStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> EntityCategoryStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityCategory;");
let cls = jni.find_class("org/bukkit/entity/EntityCategory"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::EntityCategory::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct BlockDisplay<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for BlockDisplay<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for BlockDisplay<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate BlockDisplay from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/BlockDisplay")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a BlockDisplay object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> BlockDisplay<'mc> {
	pub fn block(&self) 
-> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::data::BlockData;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBlock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::data::BlockData::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_block(&self,block: impl Into<crate::block::data::BlockData<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/block/data/BlockData;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(block.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBlock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn transformation(&self) 
-> Result<crate::util::Transformation<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Transformation;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTransformation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Transformation::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_transformation(&self,transformation: impl Into<crate::util::Transformation<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Transformation;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transformation.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTransformation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_transformation_matrix(&self,transformation_matrix: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/joml/Matrix4f;)L();");
let val_1 = jni::objects::JValueGen::Object(transformation_matrix);
let res = self.jni_ref().call_method(&self.jni_object(),"setTransformationMatrix",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn interpolation_duration(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInterpolationDuration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_interpolation_duration(&self,duration: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(duration);
let res = self.jni_ref().call_method(&self.jni_object(),"setInterpolationDuration",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_duration(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTeleportDuration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_teleport_duration(&self,duration: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(duration);
let res = self.jni_ref().call_method(&self.jni_object(),"setTeleportDuration",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn view_range(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getViewRange",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_view_range(&self,range: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(range);
let res = self.jni_ref().call_method(&self.jni_object(),"setViewRange",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shadow_radius(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShadowRadius",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_shadow_radius(&self,radius: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(radius);
let res = self.jni_ref().call_method(&self.jni_object(),"setShadowRadius",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shadow_strength(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShadowStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_shadow_strength(&self,strength: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setShadowStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn display_width(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_display_width(&self,width: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(width);
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayWidth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn display_height(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_display_height(&self,height: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(height);
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayHeight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn interpolation_delay(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInterpolationDelay",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_interpolation_delay(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setInterpolationDelay",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn billboard(&self) 
-> Result<crate::entity::DisplayBillboard<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::DisplayBillboard;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBillboard",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::DisplayBillboard::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_billboard(&self,billboard: impl Into<crate::entity::DisplayBillboard<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Display/Billboard;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(billboard.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBillboard",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn glow_color_override(&self) 
-> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Color;");
let res = self.jni_ref().call_method(&self.jni_object(),"getGlowColorOverride",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Color::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_glow_color_override(&self,color: impl Into<crate::Color<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Color;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowColorOverride",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn brightness(&self) 
-> Result<Option<crate::entity::DisplayBrightness<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::DisplayBrightness;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBrightness",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::DisplayBrightness::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_brightness(&self,brightness: impl Into<crate::entity::DisplayBrightness<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Display/Brightness;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(brightness.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBrightness",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Display<'mc>> for BlockDisplay<'mc>{

fn into(self) -> crate::entity::Display<'mc> {

crate::entity::Display::from_raw(&self.jni_ref(), self.1).expect("Error converting BlockDisplay into crate::entity::Display")

   }
}
pub enum CatType<'mc> {
	Tabby {inner: CatTypeStruct<'mc>},
	Black {inner: CatTypeStruct<'mc>},
	Red {inner: CatTypeStruct<'mc>},
	Siamese {inner: CatTypeStruct<'mc>},
	BritishShorthair {inner: CatTypeStruct<'mc>},
	Calico {inner: CatTypeStruct<'mc>},
	Persian {inner: CatTypeStruct<'mc>},
	Ragdoll {inner: CatTypeStruct<'mc>},
	White {inner: CatTypeStruct<'mc>},
	Jellie {inner: CatTypeStruct<'mc>},
	AllBlack {inner: CatTypeStruct<'mc>},
}
impl<'mc> std::fmt::Display for CatType<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           CatType::Tabby { .. } => f.write_str("TABBY"),
           CatType::Black { .. } => f.write_str("BLACK"),
           CatType::Red { .. } => f.write_str("RED"),
           CatType::Siamese { .. } => f.write_str("SIAMESE"),
           CatType::BritishShorthair { .. } => f.write_str("BRITISH_SHORTHAIR"),
           CatType::Calico { .. } => f.write_str("CALICO"),
           CatType::Persian { .. } => f.write_str("PERSIAN"),
           CatType::Ragdoll { .. } => f.write_str("RAGDOLL"),
           CatType::White { .. } => f.write_str("WHITE"),
           CatType::Jellie { .. } => f.write_str("JELLIE"),
           CatType::AllBlack { .. } => f.write_str("ALL_BLACK"),
       }
   }
}

        impl<'mc> CatType<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<CatType<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Cat/Type");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Cat/Type;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"TABBY" => Ok(CatType::Tabby { inner: CatTypeStruct::from_raw(env,obj)?}),
"BLACK" => Ok(CatType::Black { inner: CatTypeStruct::from_raw(env,obj)?}),
"RED" => Ok(CatType::Red { inner: CatTypeStruct::from_raw(env,obj)?}),
"SIAMESE" => Ok(CatType::Siamese { inner: CatTypeStruct::from_raw(env,obj)?}),
"BRITISH_SHORTHAIR" => Ok(CatType::BritishShorthair { inner: CatTypeStruct::from_raw(env,obj)?}),
"CALICO" => Ok(CatType::Calico { inner: CatTypeStruct::from_raw(env,obj)?}),
"PERSIAN" => Ok(CatType::Persian { inner: CatTypeStruct::from_raw(env,obj)?}),
"RAGDOLL" => Ok(CatType::Ragdoll { inner: CatTypeStruct::from_raw(env,obj)?}),
"WHITE" => Ok(CatType::White { inner: CatTypeStruct::from_raw(env,obj)?}),
"JELLIE" => Ok(CatType::Jellie { inner: CatTypeStruct::from_raw(env,obj)?}),
"ALL_BLACK" => Ok(CatType::AllBlack { inner: CatTypeStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct CatTypeStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for CatType<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Tabby { inner } => inner.0.clone(),
Self::Black { inner } => inner.0.clone(),
Self::Red { inner } => inner.0.clone(),
Self::Siamese { inner } => inner.0.clone(),
Self::BritishShorthair { inner } => inner.0.clone(),
Self::Calico { inner } => inner.0.clone(),
Self::Persian { inner } => inner.0.clone(),
Self::Ragdoll { inner } => inner.0.clone(),
Self::White { inner } => inner.0.clone(),
Self::Jellie { inner } => inner.0.clone(),
Self::AllBlack { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Tabby { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Black { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Red { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Siamese { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::BritishShorthair { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Calico { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Persian { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Ragdoll { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::White { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Jellie { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::AllBlack { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for CatType<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate CatType from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Cat/Type")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a CatType object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "TABBY" => Ok(CatType::Tabby { inner: CatTypeStruct::from_raw(env,obj)?}),"BLACK" => Ok(CatType::Black { inner: CatTypeStruct::from_raw(env,obj)?}),"RED" => Ok(CatType::Red { inner: CatTypeStruct::from_raw(env,obj)?}),"SIAMESE" => Ok(CatType::Siamese { inner: CatTypeStruct::from_raw(env,obj)?}),"BRITISH_SHORTHAIR" => Ok(CatType::BritishShorthair { inner: CatTypeStruct::from_raw(env,obj)?}),"CALICO" => Ok(CatType::Calico { inner: CatTypeStruct::from_raw(env,obj)?}),"PERSIAN" => Ok(CatType::Persian { inner: CatTypeStruct::from_raw(env,obj)?}),"RAGDOLL" => Ok(CatType::Ragdoll { inner: CatTypeStruct::from_raw(env,obj)?}),"WHITE" => Ok(CatType::White { inner: CatTypeStruct::from_raw(env,obj)?}),"JELLIE" => Ok(CatType::Jellie { inner: CatTypeStruct::from_raw(env,obj)?}),"ALL_BLACK" => Ok(CatType::AllBlack { inner: CatTypeStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for CatTypeStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for CatTypeStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate CatTypeStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Cat/Type")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a CatTypeStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> CatTypeStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::CatType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::CatType;");
let cls = jni.find_class("org/bukkit/entity/Cat/Type"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::CatType::from_raw(&jni,obj
)}
	pub fn key(&self) 
-> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::NamespacedKey;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKey",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::NamespacedKey::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Sittable<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Sittable<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Sittable<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Sittable from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Sittable")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Sittable object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Sittable<'mc> {
	pub fn is_sitting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSitting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_sitting(&self,sitting: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(sitting.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSitting",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Parrot<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Parrot<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Parrot<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Parrot from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Parrot")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Parrot object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Parrot<'mc> {
	pub fn variant(&self) 
-> Result<crate::entity::ParrotVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::ParrotVariant;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVariant",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::ParrotVariant::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_variant(&self,variant: impl Into<crate::entity::ParrotVariant<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Parrot/Variant;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(variant.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVariant",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dancing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDancing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_tamed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTamed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_tamed(&self,tame: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(tame.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setTamed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn owner(&self) 
-> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AnimalTamer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOwner",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::AnimalTamer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_owner(&self,tamer: impl Into<crate::entity::AnimalTamer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(tamer.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setOwner",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sitting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSitting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_sitting(&self,sitting: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(sitting.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSitting",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Tameable<'mc>> for Parrot<'mc>{

fn into(self) -> crate::entity::Tameable<'mc> {

crate::entity::Tameable::from_raw(&self.jni_ref(), self.1).expect("Error converting Parrot into crate::entity::Tameable")

   }
}
impl<'mc> Into<crate::entity::Sittable<'mc>> for Parrot<'mc>{

fn into(self) -> crate::entity::Sittable<'mc> {

crate::entity::Sittable::from_raw(&self.jni_ref(), self.1).expect("Error converting Parrot into crate::entity::Sittable")

   }
}
#[repr(C)]
pub struct LingeringPotion<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for LingeringPotion<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for LingeringPotion<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate LingeringPotion from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LingeringPotion")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a LingeringPotion object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> LingeringPotion<'mc> {
	pub fn effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item_with_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)Lcrate::Location;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::BoundingBox;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::World;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
if let Some(a) = pitch {
sig += "F";
let val_2 = jni::objects::JValueGen::Float(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(DDD)LVec;");
let val_1 = jni::objects::JValueGen::Double(x);
let val_2 = jni::objects::JValueGen::Double(y);
let val_3 = jni::objects::JValueGen::Double(z);
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2),jni::objects::JValueGen::from(val_3)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fire.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Server;");
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Entity;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(distance);
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::event::entity::EntityDamageEvent;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(value);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/EntityEffect;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Entity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(cooldown);
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::PistonMoveReaction;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::Pose;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::SpawnCategory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntitySnapshot;");
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::ThrownPotion<'mc>> for LingeringPotion<'mc>{

fn into(self) -> crate::entity::ThrownPotion<'mc> {

crate::entity::ThrownPotion::from_raw(&self.jni_ref(), self.1).expect("Error converting LingeringPotion into crate::entity::ThrownPotion")

   }
}
#[repr(C)]
pub struct PufferFish<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for PufferFish<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for PufferFish<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate PufferFish from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/PufferFish")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a PufferFish object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> PufferFish<'mc> {
	pub fn puff_state(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPuffState",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_puff_state(&self,state: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(state);
let res = self.jni_ref().call_method(&self.jni_object(),"setPuffState",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Fish<'mc>> for PufferFish<'mc>{

fn into(self) -> crate::entity::Fish<'mc> {

crate::entity::Fish::from_raw(&self.jni_ref(), self.1).expect("Error converting PufferFish into crate::entity::Fish")

   }
}
#[repr(C)]
pub struct TropicalFish<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for TropicalFish<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for TropicalFish<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate TropicalFish from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TropicalFish")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a TropicalFish object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> TropicalFish<'mc> {
	pub fn pattern_color(&self) 
-> Result<crate::DyeColor<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::DyeColor;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPatternColor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::DyeColor::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_pattern_color(&self,color: impl Into<crate::DyeColor<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/DyeColor;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPatternColor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn body_color(&self) 
-> Result<crate::DyeColor<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::DyeColor;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBodyColor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::DyeColor::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_body_color(&self,color: impl Into<crate::DyeColor<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/DyeColor;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBodyColor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn pattern(&self) 
-> Result<crate::entity::TropicalFishPattern<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::TropicalFishPattern;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPattern",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::TropicalFishPattern::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_pattern(&self,pattern: impl Into<crate::entity::TropicalFishPattern<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/TropicalFish/Pattern;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(pattern.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPattern",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Fish<'mc>> for TropicalFish<'mc>{

fn into(self) -> crate::entity::Fish<'mc> {

crate::entity::Fish::from_raw(&self.jni_ref(), self.1).expect("Error converting TropicalFish into crate::entity::Fish")

   }
}
#[repr(C)]
pub struct Flying<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Flying<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Flying<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Flying from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Flying")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Flying object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Flying<'mc> {
	pub fn set_target(&self,target: impl Into<crate::entity::LivingEntity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/LivingEntity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn target(&self) 
-> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::LivingEntity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::LivingEntity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_aware(&self,aware: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(aware.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAware",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_aware(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAware",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn ambient_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAmbientSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
args.push(val_1);
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(count);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(damage);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Player;";
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/potion/PotionEffect;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Collection;";
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(remove.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/EntityEquipment;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ai.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += ")Ljava/lang/Object;";
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/Object;";
let val_2 = jni::objects::JValueGen::Object(memory_value);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(fall_height);
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_loot_table(&self,table: impl Into<crate::loot::LootTable<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/loot/LootTable;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(table.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLootTable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn loot_table(&self) 
-> Result<Option<crate::loot::LootTable<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::loot::LootTable;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLootTable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::loot::LootTable::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_seed(&self,seed: i64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(J)L();");
let val_1 = jni::objects::JValueGen::Long(seed);
let res = self.jni_ref().call_method(&self.jni_object(),"setSeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn seed(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Mob<'mc>> for Flying<'mc>{

fn into(self) -> crate::entity::Mob<'mc> {

crate::entity::Mob::from_raw(&self.jni_ref(), self.1).expect("Error converting Flying into crate::entity::Mob")

   }
}
#[repr(C)]
pub struct Pillager<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Pillager<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Pillager<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Pillager from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Pillager")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Pillager object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Pillager<'mc> {
	pub fn set_raid(&self,raid: impl Into<crate::Raid<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Raid;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(raid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn raid(&self) 
-> Result<Option<crate::Raid<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Raid;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Raid::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn wave(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWave",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_wave(&self,wave: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(wave);
let res = self.jni_ref().call_method(&self.jni_object(),"setWave",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn patrol_target(&self) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::Block;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPatrolTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_patrol_target(&self,block: impl Into<crate::block::Block<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/block/Block;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(block.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPatrolTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_patrol_leader(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isPatrolLeader",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_patrol_leader(&self,leader: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(leader.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setPatrolLeader",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_can_join_raid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCanJoinRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_can_join_raid(&self,join: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(join.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanJoinRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn ticks_outside_raid(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksOutsideRaid",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_outside_raid(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksOutsideRaid",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_celebrating(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCelebrating",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_celebrating(&self,celebrating: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(celebrating.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCelebrating",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn celebration_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCelebrationSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::Inventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::Inventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Illager<'mc>> for Pillager<'mc>{

fn into(self) -> crate::entity::Illager<'mc> {

crate::entity::Illager::from_raw(&self.jni_ref(), self.1).expect("Error converting Pillager into crate::entity::Illager")

   }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for Pillager<'mc>{

fn into(self) -> crate::inventory::InventoryHolder<'mc> {

crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1).expect("Error converting Pillager into crate::inventory::InventoryHolder")

   }
}
#[repr(C)]
pub struct Husk<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Husk<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Husk<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Husk from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Husk")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Husk object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Husk<'mc> {
	pub fn is_converting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isConverting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn conversion_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getConversionTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_conversion_time(&self,time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(time);
let res = self.jni_ref().call_method(&self.jni_object(),"setConversionTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn is_baby(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isBaby",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_baby_with_flag(&self,flag: std::option::Option<bool>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = flag {
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(a.into());
args.push(val_1);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn is_villager(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVillager",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_villager(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVillager",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_villager_profession(&self,profession: impl Into<crate::entity::VillagerProfession<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Villager/Profession;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(profession.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVillagerProfession",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn villager_profession(&self) 
-> Result<Option<crate::entity::VillagerProfession<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::VillagerProfession;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVillagerProfession",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::VillagerProfession::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn can_break_doors(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"canBreakDoors",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_can_break_doors(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCanBreakDoors",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn age(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAge",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_age(&self,age: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(age);
let res = self.jni_ref().call_method(&self.jni_object(),"setAge",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_age_lock(&self,lock: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(lock.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAgeLock",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn age_lock(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getAgeLock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_adult(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"setAdult",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_adult(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAdult",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn can_breed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_breed(&self,breed: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(breed.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBreed",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Zombie<'mc>> for Husk<'mc>{

fn into(self) -> crate::entity::Zombie<'mc> {

crate::entity::Zombie::from_raw(&self.jni_ref(), self.1).expect("Error converting Husk into crate::entity::Zombie")

   }
}
#[repr(C)]
pub struct GlowSquid<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for GlowSquid<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for GlowSquid<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate GlowSquid from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/GlowSquid")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a GlowSquid object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> GlowSquid<'mc> {
	pub fn dark_ticks_remaining(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDarkTicksRemaining",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_dark_ticks_remaining(&self,dark_ticks_remaining: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(dark_ticks_remaining);
let res = self.jni_ref().call_method(&self.jni_object(),"setDarkTicksRemaining",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Squid<'mc>> for GlowSquid<'mc>{

fn into(self) -> crate::entity::Squid<'mc> {

crate::entity::Squid::from_raw(&self.jni_ref(), self.1).expect("Error converting GlowSquid into crate::entity::Squid")

   }
}
#[repr(C)]
pub struct EnderDragonPart<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for EnderDragonPart<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for EnderDragonPart<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EnderDragonPart from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderDragonPart")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EnderDragonPart object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> EnderDragonPart<'mc> {
	pub fn parent(&self) 
-> Result<crate::entity::EnderDragon<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EnderDragon;");
let res = self.jni_ref().call_method(&self.jni_object(),"getParent",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EnderDragon::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_location_with_loc(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity_with_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/util/Vector;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/Vector;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/BoundingBox;";
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/World;";
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation_with_yaw(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += "F";
let val_2 = jni::objects::JValueGen::Float(pitch);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities_with_x(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(x);
args.push(val_1);
sig += "D";
let val_2 = jni::objects::JValueGen::Double(y);
args.push(val_2);
sig += "D";
let val_3 = jni::objects::JValueGen::Double(z);
args.push(val_3);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks_with_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire_with_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(fire.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks_with_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Server;";
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent_with_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger_with_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger_with_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger_with_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")F";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance_with_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(distance);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause_with_event(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/event/entity/EntityDamageEvent;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/event/entity/EntityDamageEvent;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/UUID;";
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived_with_value(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(value);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect_with_type(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/EntityEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityType;";
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible_with_flag(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default_with_visible(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(visible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing_with_flag(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable_with_flag(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent_with_flag(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity_with_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown_with_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(cooldown);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag_with_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag_with_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/PistonMoveReaction;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Pose;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/SpawnCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntitySnapshot;";
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn damage_with_amount(&self,amount: f64,damage_source: std::option::Option<impl Into<crate::damage::DamageSource<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(amount);
args.push(val_1);
if let Some(a) = damage_source {
sig += "Lorg/bukkit/damage/DamageSource;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"damage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn absorption_amount(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAbsorptionAmount",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_absorption_amount(&self,amount: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(amount);
let res = self.jni_ref().call_method(&self.jni_object(),"setAbsorptionAmount",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn max_health(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxHealth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
#[deprecated]

	pub fn set_max_health(&self,health: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(health);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxHealth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn reset_max_health(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"resetMaxHealth",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::ComplexEntityPart<'mc>> for EnderDragonPart<'mc>{

fn into(self) -> crate::entity::ComplexEntityPart<'mc> {

crate::entity::ComplexEntityPart::from_raw(&self.jni_ref(), self.1).expect("Error converting EnderDragonPart into crate::entity::ComplexEntityPart")

   }
}
impl<'mc> Into<crate::entity::Damageable<'mc>> for EnderDragonPart<'mc>{

fn into(self) -> crate::entity::Damageable<'mc> {

crate::entity::Damageable::from_raw(&self.jni_ref(), self.1).expect("Error converting EnderDragonPart into crate::entity::Damageable")

   }
}
pub enum VillagerProfession<'mc> {
	None {inner: VillagerProfessionStruct<'mc>},
	Armorer {inner: VillagerProfessionStruct<'mc>},
	Butcher {inner: VillagerProfessionStruct<'mc>},
	Cartographer {inner: VillagerProfessionStruct<'mc>},
	Cleric {inner: VillagerProfessionStruct<'mc>},
	Farmer {inner: VillagerProfessionStruct<'mc>},
	Fisherman {inner: VillagerProfessionStruct<'mc>},
	Fletcher {inner: VillagerProfessionStruct<'mc>},
	Leatherworker {inner: VillagerProfessionStruct<'mc>},
	Librarian {inner: VillagerProfessionStruct<'mc>},
	Mason {inner: VillagerProfessionStruct<'mc>},
	Nitwit {inner: VillagerProfessionStruct<'mc>},
	Shepherd {inner: VillagerProfessionStruct<'mc>},
	Toolsmith {inner: VillagerProfessionStruct<'mc>},
	Weaponsmith {inner: VillagerProfessionStruct<'mc>},
}
impl<'mc> std::fmt::Display for VillagerProfession<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           VillagerProfession::None { .. } => f.write_str("NONE"),
           VillagerProfession::Armorer { .. } => f.write_str("ARMORER"),
           VillagerProfession::Butcher { .. } => f.write_str("BUTCHER"),
           VillagerProfession::Cartographer { .. } => f.write_str("CARTOGRAPHER"),
           VillagerProfession::Cleric { .. } => f.write_str("CLERIC"),
           VillagerProfession::Farmer { .. } => f.write_str("FARMER"),
           VillagerProfession::Fisherman { .. } => f.write_str("FISHERMAN"),
           VillagerProfession::Fletcher { .. } => f.write_str("FLETCHER"),
           VillagerProfession::Leatherworker { .. } => f.write_str("LEATHERWORKER"),
           VillagerProfession::Librarian { .. } => f.write_str("LIBRARIAN"),
           VillagerProfession::Mason { .. } => f.write_str("MASON"),
           VillagerProfession::Nitwit { .. } => f.write_str("NITWIT"),
           VillagerProfession::Shepherd { .. } => f.write_str("SHEPHERD"),
           VillagerProfession::Toolsmith { .. } => f.write_str("TOOLSMITH"),
           VillagerProfession::Weaponsmith { .. } => f.write_str("WEAPONSMITH"),
       }
   }
}

        impl<'mc> VillagerProfession<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<VillagerProfession<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Villager/Profession");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Villager/Profession;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"NONE" => Ok(VillagerProfession::None { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"ARMORER" => Ok(VillagerProfession::Armorer { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"BUTCHER" => Ok(VillagerProfession::Butcher { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"CARTOGRAPHER" => Ok(VillagerProfession::Cartographer { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"CLERIC" => Ok(VillagerProfession::Cleric { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"FARMER" => Ok(VillagerProfession::Farmer { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"FISHERMAN" => Ok(VillagerProfession::Fisherman { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"FLETCHER" => Ok(VillagerProfession::Fletcher { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"LEATHERWORKER" => Ok(VillagerProfession::Leatherworker { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"LIBRARIAN" => Ok(VillagerProfession::Librarian { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"MASON" => Ok(VillagerProfession::Mason { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"NITWIT" => Ok(VillagerProfession::Nitwit { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"SHEPHERD" => Ok(VillagerProfession::Shepherd { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"TOOLSMITH" => Ok(VillagerProfession::Toolsmith { inner: VillagerProfessionStruct::from_raw(env,obj)?}),
"WEAPONSMITH" => Ok(VillagerProfession::Weaponsmith { inner: VillagerProfessionStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct VillagerProfessionStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for VillagerProfession<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::None { inner } => inner.0.clone(),
Self::Armorer { inner } => inner.0.clone(),
Self::Butcher { inner } => inner.0.clone(),
Self::Cartographer { inner } => inner.0.clone(),
Self::Cleric { inner } => inner.0.clone(),
Self::Farmer { inner } => inner.0.clone(),
Self::Fisherman { inner } => inner.0.clone(),
Self::Fletcher { inner } => inner.0.clone(),
Self::Leatherworker { inner } => inner.0.clone(),
Self::Librarian { inner } => inner.0.clone(),
Self::Mason { inner } => inner.0.clone(),
Self::Nitwit { inner } => inner.0.clone(),
Self::Shepherd { inner } => inner.0.clone(),
Self::Toolsmith { inner } => inner.0.clone(),
Self::Weaponsmith { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Armorer { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Butcher { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Cartographer { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Cleric { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Farmer { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Fisherman { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Fletcher { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Leatherworker { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Librarian { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Mason { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Nitwit { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Shepherd { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Toolsmith { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Weaponsmith { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for VillagerProfession<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate VillagerProfession from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Villager/Profession")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a VillagerProfession object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "NONE" => Ok(VillagerProfession::None { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"ARMORER" => Ok(VillagerProfession::Armorer { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"BUTCHER" => Ok(VillagerProfession::Butcher { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"CARTOGRAPHER" => Ok(VillagerProfession::Cartographer { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"CLERIC" => Ok(VillagerProfession::Cleric { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"FARMER" => Ok(VillagerProfession::Farmer { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"FISHERMAN" => Ok(VillagerProfession::Fisherman { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"FLETCHER" => Ok(VillagerProfession::Fletcher { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"LEATHERWORKER" => Ok(VillagerProfession::Leatherworker { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"LIBRARIAN" => Ok(VillagerProfession::Librarian { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"MASON" => Ok(VillagerProfession::Mason { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"NITWIT" => Ok(VillagerProfession::Nitwit { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"SHEPHERD" => Ok(VillagerProfession::Shepherd { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"TOOLSMITH" => Ok(VillagerProfession::Toolsmith { inner: VillagerProfessionStruct::from_raw(env,obj)?}),"WEAPONSMITH" => Ok(VillagerProfession::Weaponsmith { inner: VillagerProfessionStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for VillagerProfessionStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for VillagerProfessionStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate VillagerProfessionStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Villager/Profession")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a VillagerProfessionStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> VillagerProfessionStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::VillagerProfession<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::VillagerProfession;");
let cls = jni.find_class("org/bukkit/entity/Villager/Profession"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::VillagerProfession::from_raw(&jni,obj
)}
	pub fn key(&self) 
-> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::NamespacedKey;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKey",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::NamespacedKey::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
pub enum ArmorStandLockType<'mc> {
	AddingOrChanging {inner: ArmorStandLockTypeStruct<'mc>},
	RemovingOrChanging {inner: ArmorStandLockTypeStruct<'mc>},
	Adding {inner: ArmorStandLockTypeStruct<'mc>},
}
impl<'mc> std::fmt::Display for ArmorStandLockType<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           ArmorStandLockType::AddingOrChanging { .. } => f.write_str("ADDING_OR_CHANGING"),
           ArmorStandLockType::RemovingOrChanging { .. } => f.write_str("REMOVING_OR_CHANGING"),
           ArmorStandLockType::Adding { .. } => f.write_str("ADDING"),
       }
   }
}

        impl<'mc> ArmorStandLockType<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<ArmorStandLockType<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/ArmorStand/LockType");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/ArmorStand/LockType;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"ADDING_OR_CHANGING" => Ok(ArmorStandLockType::AddingOrChanging { inner: ArmorStandLockTypeStruct::from_raw(env,obj)?}),
"REMOVING_OR_CHANGING" => Ok(ArmorStandLockType::RemovingOrChanging { inner: ArmorStandLockTypeStruct::from_raw(env,obj)?}),
"ADDING" => Ok(ArmorStandLockType::Adding { inner: ArmorStandLockTypeStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct ArmorStandLockTypeStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ArmorStandLockType<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::AddingOrChanging { inner } => inner.0.clone(),
Self::RemovingOrChanging { inner } => inner.0.clone(),
Self::Adding { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::AddingOrChanging { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::RemovingOrChanging { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Adding { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for ArmorStandLockType<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ArmorStandLockType from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ArmorStand/LockType")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ArmorStandLockType object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "ADDING_OR_CHANGING" => Ok(ArmorStandLockType::AddingOrChanging { inner: ArmorStandLockTypeStruct::from_raw(env,obj)?}),"REMOVING_OR_CHANGING" => Ok(ArmorStandLockType::RemovingOrChanging { inner: ArmorStandLockTypeStruct::from_raw(env,obj)?}),"ADDING" => Ok(ArmorStandLockType::Adding { inner: ArmorStandLockTypeStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for ArmorStandLockTypeStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ArmorStandLockTypeStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ArmorStandLockTypeStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ArmorStand/LockType")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ArmorStandLockTypeStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ArmorStandLockTypeStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::ArmorStandLockType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::ArmorStandLockType;");
let cls = jni.find_class("org/bukkit/entity/ArmorStand/LockType"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::ArmorStandLockType::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Bee<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Bee<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Bee<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Bee from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Bee")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Bee object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Bee<'mc> {
	pub fn hive(&self) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getHive",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_hive(&self,location: impl Into<crate::Location<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setHive",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn flower(&self) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFlower",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_flower(&self,location: impl Into<crate::Location<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setFlower",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_nectar(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasNectar",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_has_nectar(&self,nectar: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(nectar.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setHasNectar",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_stung(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasStung",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_has_stung(&self,stung: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(stung.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setHasStung",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn anger(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAnger",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_anger(&self,anger: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(anger);
let res = self.jni_ref().call_method(&self.jni_object(),"setAnger",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn cannot_enter_hive_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCannotEnterHiveTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_cannot_enter_hive_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setCannotEnterHiveTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn breed_cause(&self) 
-> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::UUID;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBreedCause",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_breed_cause(&self,uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/util/UUID;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(uuid.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBreedCause",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_love_mode(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isLoveMode",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn love_mode_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLoveModeTicks",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_love_mode_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setLoveModeTicks",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_breed_item_with_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Material;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isBreedItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_age_lock_with_lock(&self,lock: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(lock.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAgeLock",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn age_lock(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getAgeLock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn can_breed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_breed_with_breed(&self,breed: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(breed.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBreed",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn age(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAge",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_age(&self,age: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(age);
let res = self.jni_ref().call_method(&self.jni_object(),"setAge",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_baby(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_adult(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"setAdult",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_adult(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAdult",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Bee<'mc>{

fn into(self) -> crate::entity::Animals<'mc> {

crate::entity::Animals::from_raw(&self.jni_ref(), self.1).expect("Error converting Bee into crate::entity::Animals")

   }
}
pub enum WardenAngerLevel<'mc> {
	Calm {inner: WardenAngerLevelStruct<'mc>},
	Agitated {inner: WardenAngerLevelStruct<'mc>},
	Angry {inner: WardenAngerLevelStruct<'mc>},
}
impl<'mc> std::fmt::Display for WardenAngerLevel<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           WardenAngerLevel::Calm { .. } => f.write_str("CALM"),
           WardenAngerLevel::Agitated { .. } => f.write_str("AGITATED"),
           WardenAngerLevel::Angry { .. } => f.write_str("ANGRY"),
       }
   }
}

        impl<'mc> WardenAngerLevel<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<WardenAngerLevel<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Warden/AngerLevel");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Warden/AngerLevel;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"CALM" => Ok(WardenAngerLevel::Calm { inner: WardenAngerLevelStruct::from_raw(env,obj)?}),
"AGITATED" => Ok(WardenAngerLevel::Agitated { inner: WardenAngerLevelStruct::from_raw(env,obj)?}),
"ANGRY" => Ok(WardenAngerLevel::Angry { inner: WardenAngerLevelStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct WardenAngerLevelStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for WardenAngerLevel<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Calm { inner } => inner.0.clone(),
Self::Agitated { inner } => inner.0.clone(),
Self::Angry { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Calm { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Agitated { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Angry { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for WardenAngerLevel<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate WardenAngerLevel from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Warden/AngerLevel")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a WardenAngerLevel object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "CALM" => Ok(WardenAngerLevel::Calm { inner: WardenAngerLevelStruct::from_raw(env,obj)?}),"AGITATED" => Ok(WardenAngerLevel::Agitated { inner: WardenAngerLevelStruct::from_raw(env,obj)?}),"ANGRY" => Ok(WardenAngerLevel::Angry { inner: WardenAngerLevelStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for WardenAngerLevelStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for WardenAngerLevelStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate WardenAngerLevelStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Warden/AngerLevel")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a WardenAngerLevelStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> WardenAngerLevelStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::WardenAngerLevel<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::WardenAngerLevel;");
let cls = jni.find_class("org/bukkit/entity/Warden/AngerLevel"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::WardenAngerLevel::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Ambient<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Ambient<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Ambient<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Ambient from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ambient")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Ambient object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Ambient<'mc> {
	pub fn set_target(&self,target: impl Into<crate::entity::LivingEntity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/LivingEntity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn target(&self) 
-> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::LivingEntity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::LivingEntity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_aware(&self,aware: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(aware.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAware",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_aware(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAware",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn ambient_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAmbientSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
args.push(val_1);
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(count);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(damage);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Player;";
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/potion/PotionEffect;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Collection;";
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(remove.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/EntityEquipment;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ai.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += ")Ljava/lang/Object;";
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/Object;";
let val_2 = jni::objects::JValueGen::Object(memory_value);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(fall_height);
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_loot_table(&self,table: impl Into<crate::loot::LootTable<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/loot/LootTable;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(table.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLootTable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn loot_table(&self) 
-> Result<Option<crate::loot::LootTable<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::loot::LootTable;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLootTable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::loot::LootTable::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_seed(&self,seed: i64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(J)L();");
let val_1 = jni::objects::JValueGen::Long(seed);
let res = self.jni_ref().call_method(&self.jni_object(),"setSeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn seed(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Mob<'mc>> for Ambient<'mc>{

fn into(self) -> crate::entity::Mob<'mc> {

crate::entity::Mob::from_raw(&self.jni_ref(), self.1).expect("Error converting Ambient into crate::entity::Mob")

   }
}
#[repr(C)]
pub struct Minecart<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Minecart<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Minecart<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Minecart from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Minecart")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Minecart object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Minecart<'mc> {
	pub fn set_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(damage);
let res = self.jni_ref().call_method(&self.jni_object(),"setDamage",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDamage",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn max_speed(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxSpeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_max_speed(&self,speed: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(speed);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxSpeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_slow_when_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isSlowWhenEmpty",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_slow_when_empty(&self,slow: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(slow.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setSlowWhenEmpty",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn flying_velocity_mod(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getFlyingVelocityMod",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_flying_velocity_mod(&self,flying: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(flying.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setFlyingVelocityMod",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn derailed_velocity_mod(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDerailedVelocityMod",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_derailed_velocity_mod(&self,derailed: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(derailed.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setDerailedVelocityMod",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_display_block(&self,material: impl Into<crate::material::MaterialData<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/material/MaterialData;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayBlock",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn display_block(&self) 
-> Result<crate::material::MaterialData<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::material::MaterialData;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayBlock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::material::MaterialData::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_display_block_data(&self,block_data: impl Into<crate::block::data::BlockData<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/block/data/BlockData;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(block_data.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayBlockData",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn display_block_data(&self) 
-> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::data::BlockData;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayBlockData",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::data::BlockData::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_display_block_offset(&self,offset: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(offset);
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayBlockOffset",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn display_block_offset(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayBlockOffset",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_velocity(&self,vel: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(vel.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/BoundingBox;";
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/World;";
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += "F";
let val_2 = jni::objects::JValueGen::Float(pitch);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(x);
args.push(val_1);
sig += "D";
let val_2 = jni::objects::JValueGen::Double(y);
args.push(val_2);
sig += "D";
let val_3 = jni::objects::JValueGen::Double(z);
args.push(val_3);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(fire.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Server;";
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")F";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(distance);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/event/entity/EntityDamageEvent;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/event/entity/EntityDamageEvent;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/UUID;";
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(value);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/EntityEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityType;";
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(visible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(cooldown);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/PistonMoveReaction;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Pose;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/SpawnCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntitySnapshot;";
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Vehicle<'mc>> for Minecart<'mc>{

fn into(self) -> crate::entity::Vehicle<'mc> {

crate::entity::Vehicle::from_raw(&self.jni_ref(), self.1).expect("Error converting Minecart into crate::entity::Vehicle")

   }
}
#[repr(C)]
pub struct AreaEffectCloud<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for AreaEffectCloud<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for AreaEffectCloud<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate AreaEffectCloud from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AreaEffectCloud")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a AreaEffectCloud object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> AreaEffectCloud<'mc> {
	pub fn duration(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDuration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_duration(&self,duration: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(duration);
let res = self.jni_ref().call_method(&self.jni_object(),"setDuration",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn wait_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getWaitTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_wait_time(&self,wait_time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(wait_time);
let res = self.jni_ref().call_method(&self.jni_object(),"setWaitTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn reapplication_delay(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getReapplicationDelay",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_reapplication_delay(&self,delay: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(delay);
let res = self.jni_ref().call_method(&self.jni_object(),"setReapplicationDelay",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn duration_on_use(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDurationOnUse",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_duration_on_use(&self,duration: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(duration);
let res = self.jni_ref().call_method(&self.jni_object(),"setDurationOnUse",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn radius(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRadius",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_radius(&self,radius: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(radius);
let res = self.jni_ref().call_method(&self.jni_object(),"setRadius",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn radius_on_use(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRadiusOnUse",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_radius_on_use(&self,radius: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(radius);
let res = self.jni_ref().call_method(&self.jni_object(),"setRadiusOnUse",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn radius_per_tick(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRadiusPerTick",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_radius_per_tick(&self,radius: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(radius);
let res = self.jni_ref().call_method(&self.jni_object(),"setRadiusPerTick",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn particle(&self) 
-> Result<crate::Particle<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Particle;");
let res = self.jni_ref().call_method(&self.jni_object(),"getParticle",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Particle::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_particle_with_particle(&self,particle: impl Into<crate::Particle<'mc>>,data: std::option::Option<jni::objects::JObject<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Particle;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(particle.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = data {
sig += "Ljava/lang/Object;";
let val_2 = jni::objects::JValueGen::Object(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setParticle",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_base_potion_data(&self,data: impl Into<crate::potion::PotionData<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionData;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(data.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBasePotionData",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn base_potion_data(&self) 
-> Result<crate::potion::PotionData<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::potion::PotionData;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBasePotionData",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::potion::PotionData::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_base_potion_type(&self,val_type: impl Into<crate::potion::PotionType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionType;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBasePotionType",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn base_potion_type(&self) 
-> Result<crate::potion::PotionType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::potion::PotionType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBasePotionType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::potion::PotionType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn has_custom_effects(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"hasCustomEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn custom_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_custom_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,overwrite: bool) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffect;Z)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
let val_2 = jni::objects::JValueGen::Bool(overwrite.into());
let res = self.jni_ref().call_method(&self.jni_object(),"addCustomEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_custom_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeCustomEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_custom_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"hasCustomEffect",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn clear_custom_effects(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"clearCustomEffects",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn color(&self) 
-> Result<crate::Color<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Color;");
let res = self.jni_ref().call_method(&self.jni_object(),"getColor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Color::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_color(&self,color: impl Into<crate::Color<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Color;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setColor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn source(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSource",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_source(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setSource",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/util/Vector;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/Vector;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/BoundingBox;";
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/World;";
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += "F";
let val_2 = jni::objects::JValueGen::Float(pitch);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(x);
args.push(val_1);
sig += "D";
let val_2 = jni::objects::JValueGen::Double(y);
args.push(val_2);
sig += "D";
let val_3 = jni::objects::JValueGen::Double(z);
args.push(val_3);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(fire.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Server;";
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")F";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(distance);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/event/entity/EntityDamageEvent;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/event/entity/EntityDamageEvent;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/UUID;";
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(value);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/EntityEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityType;";
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(visible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(cooldown);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/PistonMoveReaction;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Pose;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/SpawnCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntitySnapshot;";
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for AreaEffectCloud<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting AreaEffectCloud into crate::entity::Entity")

   }
}
pub enum HorseColor<'mc> {
	White {inner: HorseColorStruct<'mc>},
	Creamy {inner: HorseColorStruct<'mc>},
	Chestnut {inner: HorseColorStruct<'mc>},
	Brown {inner: HorseColorStruct<'mc>},
	Black {inner: HorseColorStruct<'mc>},
	Gray {inner: HorseColorStruct<'mc>},
	DarkBrown {inner: HorseColorStruct<'mc>},
}
impl<'mc> std::fmt::Display for HorseColor<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           HorseColor::White { .. } => f.write_str("WHITE"),
           HorseColor::Creamy { .. } => f.write_str("CREAMY"),
           HorseColor::Chestnut { .. } => f.write_str("CHESTNUT"),
           HorseColor::Brown { .. } => f.write_str("BROWN"),
           HorseColor::Black { .. } => f.write_str("BLACK"),
           HorseColor::Gray { .. } => f.write_str("GRAY"),
           HorseColor::DarkBrown { .. } => f.write_str("DARK_BROWN"),
       }
   }
}

        impl<'mc> HorseColor<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<HorseColor<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Horse/Color");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Horse/Color;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"WHITE" => Ok(HorseColor::White { inner: HorseColorStruct::from_raw(env,obj)?}),
"CREAMY" => Ok(HorseColor::Creamy { inner: HorseColorStruct::from_raw(env,obj)?}),
"CHESTNUT" => Ok(HorseColor::Chestnut { inner: HorseColorStruct::from_raw(env,obj)?}),
"BROWN" => Ok(HorseColor::Brown { inner: HorseColorStruct::from_raw(env,obj)?}),
"BLACK" => Ok(HorseColor::Black { inner: HorseColorStruct::from_raw(env,obj)?}),
"GRAY" => Ok(HorseColor::Gray { inner: HorseColorStruct::from_raw(env,obj)?}),
"DARK_BROWN" => Ok(HorseColor::DarkBrown { inner: HorseColorStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct HorseColorStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for HorseColor<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::White { inner } => inner.0.clone(),
Self::Creamy { inner } => inner.0.clone(),
Self::Chestnut { inner } => inner.0.clone(),
Self::Brown { inner } => inner.0.clone(),
Self::Black { inner } => inner.0.clone(),
Self::Gray { inner } => inner.0.clone(),
Self::DarkBrown { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::White { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Creamy { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Chestnut { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Brown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Black { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Gray { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::DarkBrown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for HorseColor<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate HorseColor from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse/Color")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a HorseColor object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "WHITE" => Ok(HorseColor::White { inner: HorseColorStruct::from_raw(env,obj)?}),"CREAMY" => Ok(HorseColor::Creamy { inner: HorseColorStruct::from_raw(env,obj)?}),"CHESTNUT" => Ok(HorseColor::Chestnut { inner: HorseColorStruct::from_raw(env,obj)?}),"BROWN" => Ok(HorseColor::Brown { inner: HorseColorStruct::from_raw(env,obj)?}),"BLACK" => Ok(HorseColor::Black { inner: HorseColorStruct::from_raw(env,obj)?}),"GRAY" => Ok(HorseColor::Gray { inner: HorseColorStruct::from_raw(env,obj)?}),"DARK_BROWN" => Ok(HorseColor::DarkBrown { inner: HorseColorStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for HorseColorStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for HorseColorStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate HorseColorStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse/Color")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a HorseColorStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> HorseColorStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::HorseColor<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::HorseColor;");
let cls = jni.find_class("org/bukkit/entity/Horse/Color"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::HorseColor::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Ageable<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Ageable<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Ageable<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Ageable from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ageable")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Ageable object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Ageable<'mc> {
	pub fn age(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAge",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_age(&self,age: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(age);
let res = self.jni_ref().call_method(&self.jni_object(),"setAge",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_age_lock(&self,lock: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(lock.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAgeLock",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn age_lock(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getAgeLock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_baby(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_adult(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"setAdult",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_adult(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAdult",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn can_breed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_breed(&self,breed: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(breed.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBreed",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_target(&self,target: impl Into<crate::entity::LivingEntity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/LivingEntity;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn target(&self) 
-> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::LivingEntity;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::LivingEntity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_aware(&self,aware: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(aware.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setAware",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_aware(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAware",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn ambient_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Sound;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAmbientSound",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_eye_height(&self,ignore_pose: bool) 
-> Result<f64, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ignore_pose.into());
args.push(val_1);
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn eye_location(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEyeLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_line_of_sight(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_last_two_target_blocks(&self,transparent: impl Into<blackboxmc_java::util::JavaSet<'mc>>,max_distance: i32) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/Set;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transparent.into().jni_object().clone())});
args.push(val_1);
sig += "I";
let val_2 = jni::objects::JValueGen::Int(max_distance);
args.push(val_2);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastTwoTargetBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn get_target_block_exact_with_max_distance(&self,max_distance: i32,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/block/Block;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetBlockExact",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn ray_trace_blocks_with_max_distance(&self,max_distance: f64,fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>) 
-> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(max_distance);
args.push(val_1);
if let Some(a) = fluid_collision_mode {
sig += "Lorg/bukkit/FluidCollisionMode;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Lorg/bukkit/util/RayTraceResult;";
let res = self.jni_ref().call_method(&self.jni_object(),"rayTraceBlocks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::util::RayTraceResult::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remaining_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemainingAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_remaining_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemainingAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_air(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumAir",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_air(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumAir",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_in_use(&self) 
-> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUse",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn item_in_use_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getItemInUseTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_item_in_use_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItemInUseTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrow_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrow_cooldown(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn arrows_in_body(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getArrowsInBody",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_arrows_in_body(&self,count: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(count);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setArrowsInBody",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn maximum_no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaximumNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_maximum_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMaximumNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamage",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_last_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(damage);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_damage_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoDamageTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_damage_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoDamageTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn no_action_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getNoActionTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_no_action_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setNoActionTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn killer(&self) 
-> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Player;";
let res = self.jni_ref().call_method(&self.jni_object(),"getKiller",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Player::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn add_potion_effect_with_effect(&self,effect: impl Into<crate::potion::PotionEffect<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(effect.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn has_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<Option<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/potion/PotionEffect;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPotionEffect",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::potion::PotionEffect::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn remove_potion_effect(&self,val_type: impl Into<crate::potion::PotionEffectType<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/potion/PotionEffectType;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"removePotionEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn active_potion_effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Collection;";
let res = self.jni_ref().call_method(&self.jni_object(),"getActivePotionEffects",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_line_of_sight(&self,other: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(other.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasLineOfSight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_when_far_away(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getRemoveWhenFarAway",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_remove_when_far_away(&self,remove: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(remove.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRemoveWhenFarAway",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn equipment(&self) 
-> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/EntityEquipment;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEquipment",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::inventory::EntityEquipment::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_can_pickup_items(&self,pickup: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(pickup.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCanPickupItems",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn can_pickup_items(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getCanPickupItems",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_leashed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isLeashed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leash_holder(&self) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_leash_holder(&self,holder: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(holder.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setLeashHolder",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_gliding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGliding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gliding(&self,gliding: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gliding.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGliding",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_swimming(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSwimming",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_swimming(&self,swimming: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(swimming.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSwimming",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_riptiding(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isRiptiding",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_sleeping(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSleeping",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_climbing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isClimbing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_ai(&self,ai: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(ai.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAI",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_ai(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasAI",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attack(&self,target: impl Into<crate::entity::Entity<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(target.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"attack",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_main_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingMainHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn swing_off_hand(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"swingOffHand",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_hurt_animation(&self,yaw: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playHurtAnimation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_collidable(&self,collidable: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(collidable.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCollidable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_collidable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCollidable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn collidable_exemptions(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCollidableExemptions",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>) 
-> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += ")Ljava/lang/Object;";
let res = self.jni_ref().call_method(&self.jni_object(),"getMemory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
res.l()?
)
)}
	pub fn set_memory(&self,memory_key: impl Into<crate::entity::memory::MemoryKey<'mc>>,memory_value: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/memory/MemoryKey;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(memory_key.into().jni_object().clone())});
args.push(val_1);
sig += "Ljava/lang/Object;";
let val_2 = jni::objects::JValueGen::Object(memory_value);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMemory",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn hurt_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getHurtSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn death_sound(&self) 
-> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDeathSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn get_fall_damage_sound(&self,fall_height: i32) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(fall_height);
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_small(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundSmall",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn fall_damage_sound_big(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDamageSoundBig",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_drinking_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getDrinkingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn get_eating_sound(&self,item_stack: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item_stack.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getEatingSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn can_breathe_underwater(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreatheUnderwater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn category(&self) 
-> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_invisible(&self,invisible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(invisible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invisible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_loot_table(&self,table: impl Into<crate::loot::LootTable<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/loot/LootTable;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(table.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setLootTable",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn loot_table(&self) 
-> Result<Option<crate::loot::LootTable<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::loot::LootTable;");
let res = self.jni_ref().call_method(&self.jni_object(),"getLootTable",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::loot::LootTable::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_seed(&self,seed: i64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(J)L();");
let val_1 = jni::objects::JValueGen::Long(seed);
let res = self.jni_ref().call_method(&self.jni_object(),"setSeed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn seed(&self) 
-> Result<i64, Box<dyn std::error::Error>>

{let sig = String::from("()Li64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getSeed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.j()?
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Creature<'mc>> for Ageable<'mc>{

fn into(self) -> crate::entity::Creature<'mc> {

crate::entity::Creature::from_raw(&self.jni_ref(), self.1).expect("Error converting Ageable into crate::entity::Creature")

   }
}
#[repr(C)]
pub struct SplashPotion<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for SplashPotion<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for SplashPotion<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate SplashPotion from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SplashPotion")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a SplashPotion object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> SplashPotion<'mc> {
	pub fn effects(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()LVec;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEffects",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(),res.l()?)?;let iter = col.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item_with_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/util/Vector;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/Vector;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/BoundingBox;";
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/World;";
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += "F";
let val_2 = jni::objects::JValueGen::Float(pitch);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(x);
args.push(val_1);
sig += "D";
let val_2 = jni::objects::JValueGen::Double(y);
args.push(val_2);
sig += "D";
let val_3 = jni::objects::JValueGen::Double(z);
args.push(val_3);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(fire.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Server;";
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")F";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(distance);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/event/entity/EntityDamageEvent;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/event/entity/EntityDamageEvent;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/UUID;";
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(value);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/EntityEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityType;";
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(visible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(cooldown);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/PistonMoveReaction;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Pose;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/SpawnCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntitySnapshot;";
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::ThrownPotion<'mc>> for SplashPotion<'mc>{

fn into(self) -> crate::entity::ThrownPotion<'mc> {

crate::entity::ThrownPotion::from_raw(&self.jni_ref(), self.1).expect("Error converting SplashPotion into crate::entity::ThrownPotion")

   }
}
pub enum FrogVariant<'mc> {
	Temperate {inner: FrogVariantStruct<'mc>},
	Warm {inner: FrogVariantStruct<'mc>},
	Cold {inner: FrogVariantStruct<'mc>},
}
impl<'mc> std::fmt::Display for FrogVariant<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           FrogVariant::Temperate { .. } => f.write_str("TEMPERATE"),
           FrogVariant::Warm { .. } => f.write_str("WARM"),
           FrogVariant::Cold { .. } => f.write_str("COLD"),
       }
   }
}

        impl<'mc> FrogVariant<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<FrogVariant<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Frog/Variant");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Frog/Variant;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"TEMPERATE" => Ok(FrogVariant::Temperate { inner: FrogVariantStruct::from_raw(env,obj)?}),
"WARM" => Ok(FrogVariant::Warm { inner: FrogVariantStruct::from_raw(env,obj)?}),
"COLD" => Ok(FrogVariant::Cold { inner: FrogVariantStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct FrogVariantStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for FrogVariant<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Temperate { inner } => inner.0.clone(),
Self::Warm { inner } => inner.0.clone(),
Self::Cold { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Temperate { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Warm { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Cold { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for FrogVariant<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate FrogVariant from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Frog/Variant")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a FrogVariant object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "TEMPERATE" => Ok(FrogVariant::Temperate { inner: FrogVariantStruct::from_raw(env,obj)?}),"WARM" => Ok(FrogVariant::Warm { inner: FrogVariantStruct::from_raw(env,obj)?}),"COLD" => Ok(FrogVariant::Cold { inner: FrogVariantStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for FrogVariantStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for FrogVariantStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate FrogVariantStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Frog/Variant")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a FrogVariantStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> FrogVariantStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::FrogVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::FrogVariant;");
let cls = jni.find_class("org/bukkit/entity/Frog/Variant"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::FrogVariant::from_raw(&jni,obj
)}
	pub fn key(&self) 
-> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::NamespacedKey;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKey",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::NamespacedKey::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Display<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Display<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Display<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Display from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Display")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Display object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Display<'mc> {
	pub fn transformation(&self) 
-> Result<crate::util::Transformation<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Transformation;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTransformation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Transformation::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_transformation(&self,transformation: impl Into<crate::util::Transformation<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Transformation;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(transformation.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTransformation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_transformation_matrix(&self,transformation_matrix: jni::objects::JObject<'mc>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/joml/Matrix4f;)L();");
let val_1 = jni::objects::JValueGen::Object(transformation_matrix);
let res = self.jni_ref().call_method(&self.jni_object(),"setTransformationMatrix",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn interpolation_duration(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInterpolationDuration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_interpolation_duration(&self,duration: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(duration);
let res = self.jni_ref().call_method(&self.jni_object(),"setInterpolationDuration",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_duration(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTeleportDuration",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_teleport_duration(&self,duration: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(duration);
let res = self.jni_ref().call_method(&self.jni_object(),"setTeleportDuration",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn view_range(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getViewRange",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_view_range(&self,range: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(range);
let res = self.jni_ref().call_method(&self.jni_object(),"setViewRange",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shadow_radius(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShadowRadius",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_shadow_radius(&self,radius: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(radius);
let res = self.jni_ref().call_method(&self.jni_object(),"setShadowRadius",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shadow_strength(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShadowStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_shadow_strength(&self,strength: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setShadowStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn display_width(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayWidth",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_display_width(&self,width: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(width);
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayWidth",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn display_height(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDisplayHeight",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_display_height(&self,height: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(height);
let res = self.jni_ref().call_method(&self.jni_object(),"setDisplayHeight",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn interpolation_delay(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInterpolationDelay",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_interpolation_delay(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(ticks);
let res = self.jni_ref().call_method(&self.jni_object(),"setInterpolationDelay",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn billboard(&self) 
-> Result<crate::entity::DisplayBillboard<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::DisplayBillboard;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBillboard",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::DisplayBillboard::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_billboard(&self,billboard: impl Into<crate::entity::DisplayBillboard<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Display/Billboard;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(billboard.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBillboard",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn glow_color_override(&self) 
-> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Color;");
let res = self.jni_ref().call_method(&self.jni_object(),"getGlowColorOverride",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Color::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_glow_color_override(&self,color: impl Into<crate::Color<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Color;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowColorOverride",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn brightness(&self) 
-> Result<Option<crate::entity::DisplayBrightness<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::DisplayBrightness;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBrightness",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::DisplayBrightness::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_brightness(&self,brightness: impl Into<crate::entity::DisplayBrightness<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Display/Brightness;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(brightness.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBrightness",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/util/Vector;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/Vector;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/BoundingBox;";
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/World;";
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
sig += "F";
let val_2 = jni::objects::JValueGen::Float(pitch);
args.push(val_2);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(x);
args.push(val_1);
sig += "D";
let val_2 = jni::objects::JValueGen::Double(y);
args.push(val_2);
sig += "D";
let val_3 = jni::objects::JValueGen::Double(z);
args.push(val_3);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(fire.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Server;";
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")F";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(distance);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/event/entity/EntityDamageEvent;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/event/entity/EntityDamageEvent;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/UUID;";
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(value);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/EntityEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityType;";
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(visible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(cooldown);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/PistonMoveReaction;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Pose;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/SpawnCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntitySnapshot;";
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: impl Into<crate::metadata::MetadataValue<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/metadata/MetadataValue;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(new_metadata_value.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Display<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting Display into crate::entity::Entity")

   }
}
pub enum EnderDragonPhase<'mc> {
	Circling {inner: EnderDragonPhaseStruct<'mc>},
	Strafing {inner: EnderDragonPhaseStruct<'mc>},
	FlyToPortal {inner: EnderDragonPhaseStruct<'mc>},
	LandOnPortal {inner: EnderDragonPhaseStruct<'mc>},
	LeavePortal {inner: EnderDragonPhaseStruct<'mc>},
	BreathAttack {inner: EnderDragonPhaseStruct<'mc>},
	SearchForBreathAttackTarget {inner: EnderDragonPhaseStruct<'mc>},
	RoarBeforeAttack {inner: EnderDragonPhaseStruct<'mc>},
	ChargePlayer {inner: EnderDragonPhaseStruct<'mc>},
	Dying {inner: EnderDragonPhaseStruct<'mc>},
	Hover {inner: EnderDragonPhaseStruct<'mc>},
}
impl<'mc> std::fmt::Display for EnderDragonPhase<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           EnderDragonPhase::Circling { .. } => f.write_str("CIRCLING"),
           EnderDragonPhase::Strafing { .. } => f.write_str("STRAFING"),
           EnderDragonPhase::FlyToPortal { .. } => f.write_str("FLY_TO_PORTAL"),
           EnderDragonPhase::LandOnPortal { .. } => f.write_str("LAND_ON_PORTAL"),
           EnderDragonPhase::LeavePortal { .. } => f.write_str("LEAVE_PORTAL"),
           EnderDragonPhase::BreathAttack { .. } => f.write_str("BREATH_ATTACK"),
           EnderDragonPhase::SearchForBreathAttackTarget { .. } => f.write_str("SEARCH_FOR_BREATH_ATTACK_TARGET"),
           EnderDragonPhase::RoarBeforeAttack { .. } => f.write_str("ROAR_BEFORE_ATTACK"),
           EnderDragonPhase::ChargePlayer { .. } => f.write_str("CHARGE_PLAYER"),
           EnderDragonPhase::Dying { .. } => f.write_str("DYING"),
           EnderDragonPhase::Hover { .. } => f.write_str("HOVER"),
       }
   }
}

        impl<'mc> EnderDragonPhase<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<EnderDragonPhase<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/EnderDragon/Phase");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/EnderDragon/Phase;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"CIRCLING" => Ok(EnderDragonPhase::Circling { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),
"STRAFING" => Ok(EnderDragonPhase::Strafing { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),
"FLY_TO_PORTAL" => Ok(EnderDragonPhase::FlyToPortal { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),
"LAND_ON_PORTAL" => Ok(EnderDragonPhase::LandOnPortal { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),
"LEAVE_PORTAL" => Ok(EnderDragonPhase::LeavePortal { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),
"BREATH_ATTACK" => Ok(EnderDragonPhase::BreathAttack { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),
"SEARCH_FOR_BREATH_ATTACK_TARGET" => Ok(EnderDragonPhase::SearchForBreathAttackTarget { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),
"ROAR_BEFORE_ATTACK" => Ok(EnderDragonPhase::RoarBeforeAttack { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),
"CHARGE_PLAYER" => Ok(EnderDragonPhase::ChargePlayer { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),
"DYING" => Ok(EnderDragonPhase::Dying { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),
"HOVER" => Ok(EnderDragonPhase::Hover { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct EnderDragonPhaseStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for EnderDragonPhase<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Circling { inner } => inner.0.clone(),
Self::Strafing { inner } => inner.0.clone(),
Self::FlyToPortal { inner } => inner.0.clone(),
Self::LandOnPortal { inner } => inner.0.clone(),
Self::LeavePortal { inner } => inner.0.clone(),
Self::BreathAttack { inner } => inner.0.clone(),
Self::SearchForBreathAttackTarget { inner } => inner.0.clone(),
Self::RoarBeforeAttack { inner } => inner.0.clone(),
Self::ChargePlayer { inner } => inner.0.clone(),
Self::Dying { inner } => inner.0.clone(),
Self::Hover { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Circling { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Strafing { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::FlyToPortal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::LandOnPortal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::LeavePortal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::BreathAttack { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::SearchForBreathAttackTarget { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::RoarBeforeAttack { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::ChargePlayer { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Dying { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Hover { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for EnderDragonPhase<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EnderDragonPhase from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderDragon/Phase")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EnderDragonPhase object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "CIRCLING" => Ok(EnderDragonPhase::Circling { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),"STRAFING" => Ok(EnderDragonPhase::Strafing { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),"FLY_TO_PORTAL" => Ok(EnderDragonPhase::FlyToPortal { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),"LAND_ON_PORTAL" => Ok(EnderDragonPhase::LandOnPortal { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),"LEAVE_PORTAL" => Ok(EnderDragonPhase::LeavePortal { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),"BREATH_ATTACK" => Ok(EnderDragonPhase::BreathAttack { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),"SEARCH_FOR_BREATH_ATTACK_TARGET" => Ok(EnderDragonPhase::SearchForBreathAttackTarget { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),"ROAR_BEFORE_ATTACK" => Ok(EnderDragonPhase::RoarBeforeAttack { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),"CHARGE_PLAYER" => Ok(EnderDragonPhase::ChargePlayer { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),"DYING" => Ok(EnderDragonPhase::Dying { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),"HOVER" => Ok(EnderDragonPhase::Hover { inner: EnderDragonPhaseStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for EnderDragonPhaseStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for EnderDragonPhaseStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EnderDragonPhaseStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderDragon/Phase")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EnderDragonPhaseStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> EnderDragonPhaseStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::EnderDragonPhase<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EnderDragonPhase;");
let cls = jni.find_class("org/bukkit/entity/EnderDragon/Phase"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::EnderDragonPhase::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Piglin<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Piglin<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Piglin<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Piglin from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Piglin")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Piglin object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Piglin<'mc> {
	pub fn is_able_to_hunt(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAbleToHunt",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_is_able_to_hunt(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setIsAbleToHunt",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn add_barter_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Material;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addBarterMaterial",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_barter_material(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Material;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeBarterMaterial",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn add_material_of_interest(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Material;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"addMaterialOfInterest",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_material_of_interest(&self,material: impl Into<crate::Material<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Material;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(material.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMaterialOfInterest",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn interest_list(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInterestList",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn barter_list(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lblackboxmc_java::util::Set;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBarterList",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_immune_to_zombification(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isImmuneToZombification",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_immune_to_zombification(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(flag.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setImmuneToZombification",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn conversion_time(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getConversionTime",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_conversion_time(&self,time: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(time);
let res = self.jni_ref().call_method(&self.jni_object(),"setConversionTime",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_converting(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isConverting",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn is_baby(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isBaby",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_baby_with_flag(&self,flag: std::option::Option<bool>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = flag {
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(a.into());
args.push(val_1);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBaby",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn age(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAge",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_age(&self,age: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(age);
let res = self.jni_ref().call_method(&self.jni_object(),"setAge",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_age_lock(&self,lock: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(lock.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setAgeLock",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn age_lock(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"getAgeLock",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_adult(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("()L();");
let res = self.jni_ref().call_method(&self.jni_object(),"setAdult",sig.as_str(),vec![]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_adult(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isAdult",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn can_breed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"canBreed",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_breed(&self,breed: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(breed.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setBreed",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::Inventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::Inventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::PiglinAbstract<'mc>> for Piglin<'mc>{

fn into(self) -> crate::entity::PiglinAbstract<'mc> {

crate::entity::PiglinAbstract::from_raw(&self.jni_ref(), self.1).expect("Error converting Piglin into crate::entity::PiglinAbstract")

   }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for Piglin<'mc>{

fn into(self) -> crate::inventory::InventoryHolder<'mc> {

crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1).expect("Error converting Piglin into crate::inventory::InventoryHolder")

   }
}
#[repr(C)]
pub struct ChestedHorse<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for ChestedHorse<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for ChestedHorse<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate ChestedHorse from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ChestedHorse")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ChestedHorse object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> ChestedHorse<'mc> {
	pub fn is_carrying_chest(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCarryingChest",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_carrying_chest(&self,chest: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(chest.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCarryingChest",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn variant(&self) 
-> Result<crate::entity::HorseVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::HorseVariant;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVariant",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::HorseVariant::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_variant(&self,variant: impl Into<crate::entity::HorseVariant<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Horse/Variant;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(variant.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVariant",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn max_domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_max_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn jump_strength(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getJumpStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_jump_strength(&self,strength: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setJumpStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_eating_haystack(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEatingHaystack",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_eating_haystack(&self,eating_haystack: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(eating_haystack.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setEatingHaystack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::AbstractHorseInventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::AbstractHorseInventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::AbstractHorseInventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_velocity(&self,vel: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(vel.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_tamed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTamed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_tamed(&self,tame: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(tame.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setTamed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn owner(&self) 
-> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AnimalTamer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOwner",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::AnimalTamer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_owner(&self,tamer: impl Into<crate::entity::AnimalTamer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(tamer.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setOwner",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::AbstractHorse<'mc>> for ChestedHorse<'mc>{

fn into(self) -> crate::entity::AbstractHorse<'mc> {

crate::entity::AbstractHorse::from_raw(&self.jni_ref(), self.1).expect("Error converting ChestedHorse into crate::entity::AbstractHorse")

   }
}
pub enum HorseVariant<'mc> {
	Horse {inner: HorseVariantStruct<'mc>},
	Donkey {inner: HorseVariantStruct<'mc>},
	Mule {inner: HorseVariantStruct<'mc>},
	UndeadHorse {inner: HorseVariantStruct<'mc>},
	SkeletonHorse {inner: HorseVariantStruct<'mc>},
	Llama {inner: HorseVariantStruct<'mc>},
	Camel {inner: HorseVariantStruct<'mc>},
}
impl<'mc> std::fmt::Display for HorseVariant<'mc> {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       match self {
           HorseVariant::Horse { .. } => f.write_str("HORSE"),
           HorseVariant::Donkey { .. } => f.write_str("DONKEY"),
           HorseVariant::Mule { .. } => f.write_str("MULE"),
           HorseVariant::UndeadHorse { .. } => f.write_str("UNDEAD_HORSE"),
           HorseVariant::SkeletonHorse { .. } => f.write_str("SKELETON_HORSE"),
           HorseVariant::Llama { .. } => f.write_str("LLAMA"),
           HorseVariant::Camel { .. } => f.write_str("CAMEL"),
       }
   }
}

        impl<'mc> HorseVariant<'mc> {
            pub fn value_of(
                env: &blackboxmc_general::SharedJNIEnv<'mc>,
                arg0: impl Into<String>,
            ) -> Result<HorseVariant<'mc>, Box<dyn std::error::Error>> {
                let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
                let cls = env.find_class("org/bukkit/entity/Horse/Variant");
                let cls = env.translate_error_with_class(cls)?;
                let res = env.call_static_method(
                    cls,
                    "valueOf",
                    "(Ljava/lang/String;)Lorg/bukkit/entity/Horse/Variant;",
                    vec![jni::objects::JValueGen::from(val_1)],
                );
                let res = env.translate_error(res)?;
                let obj = res.l()?;
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    
"HORSE" => Ok(HorseVariant::Horse { inner: HorseVariantStruct::from_raw(env,obj)?}),
"DONKEY" => Ok(HorseVariant::Donkey { inner: HorseVariantStruct::from_raw(env,obj)?}),
"MULE" => Ok(HorseVariant::Mule { inner: HorseVariantStruct::from_raw(env,obj)?}),
"UNDEAD_HORSE" => Ok(HorseVariant::UndeadHorse { inner: HorseVariantStruct::from_raw(env,obj)?}),
"SKELETON_HORSE" => Ok(HorseVariant::SkeletonHorse { inner: HorseVariantStruct::from_raw(env,obj)?}),
"LLAMA" => Ok(HorseVariant::Llama { inner: HorseVariantStruct::from_raw(env,obj)?}),
"CAMEL" => Ok(HorseVariant::Camel { inner: HorseVariantStruct::from_raw(env,obj)?}),

                    _ => Err(eyre::eyre!("String gaven for variant was invalid").into())
                }
            }
        }
        
#[repr(C)]
pub struct HorseVariantStruct<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for HorseVariant<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
match self {
Self::Horse { inner } => inner.0.clone(),
Self::Donkey { inner } => inner.0.clone(),
Self::Mule { inner } => inner.0.clone(),
Self::UndeadHorse { inner } => inner.0.clone(),
Self::SkeletonHorse { inner } => inner.0.clone(),
Self::Llama { inner } => inner.0.clone(),
Self::Camel { inner } => inner.0.clone(),
}
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
match self {
Self::Horse { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Donkey { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Mule { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::UndeadHorse { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::SkeletonHorse { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Llama { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
Self::Camel { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
}
}
}
impl<'mc> JNIInstantiatable<'mc> for HorseVariant<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate HorseVariant from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse/Variant")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a HorseVariant object, got {}",
                    name
                )
                .into())
            } else {
    
                let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
                let variant = env.translate_error(variant)?;
                let variant_str = env
                    .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                    .to_string_lossy()
                    .to_string();
                match variant_str.as_str() {
                    "HORSE" => Ok(HorseVariant::Horse { inner: HorseVariantStruct::from_raw(env,obj)?}),"DONKEY" => Ok(HorseVariant::Donkey { inner: HorseVariantStruct::from_raw(env,obj)?}),"MULE" => Ok(HorseVariant::Mule { inner: HorseVariantStruct::from_raw(env,obj)?}),"UNDEAD_HORSE" => Ok(HorseVariant::UndeadHorse { inner: HorseVariantStruct::from_raw(env,obj)?}),"SKELETON_HORSE" => Ok(HorseVariant::SkeletonHorse { inner: HorseVariantStruct::from_raw(env,obj)?}),"LLAMA" => Ok(HorseVariant::Llama { inner: HorseVariantStruct::from_raw(env,obj)?}),"CAMEL" => Ok(HorseVariant::Camel { inner: HorseVariantStruct::from_raw(env,obj)?}),_ => Err(eyre::eyre!("String gaven for variant was invalid").into())}
            }
        }
    }
    

    impl<'mc> JNIRaw<'mc> for HorseVariantStruct<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for HorseVariantStruct<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate HorseVariantStruct from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse/Variant")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a HorseVariantStruct object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> HorseVariantStruct<'mc> {
	pub fn values(jni: &blackboxmc_general::SharedJNIEnv<'mc>) 
-> Result<crate::entity::HorseVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::HorseVariant;");
let cls = jni.find_class("org/bukkit/entity/Horse/Variant"); let cls = jni.translate_error_with_class(cls)?;
let res = jni.call_static_method(cls,"values",
sig.as_str(),vec![]);
let res = 
jni.translate_error(res)?;
let obj = res.l()?;
crate::entity::HorseVariant::from_raw(&jni,obj
)}
// SUPER CLASS: Enum

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct GlowItemFrame<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for GlowItemFrame<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for GlowItemFrame<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate GlowItemFrame from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/GlowItemFrame")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a GlowItemFrame object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> GlowItemFrame<'mc> {
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item_with_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>,play_sound: std::option::Option<bool>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = play_sound {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item_drop_chance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let sig = String::from("()Lf32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItemDropChance",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_item_drop_chance(&self,chance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(F)L();");
let val_1 = jni::objects::JValueGen::Float(chance);
let res = self.jni_ref().call_method(&self.jni_object(),"setItemDropChance",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn rotation(&self) 
-> Result<crate::Rotation<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Rotation;");
let res = self.jni_ref().call_method(&self.jni_object(),"getRotation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Rotation::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation_with_yaw(&self,yaw: f32,pitch: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
if let Some(a) = pitch {
sig += "F";
let val_2 = jni::objects::JValueGen::Float(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isVisible",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(visible.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setVisible",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_fixed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isFixed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_fixed(&self,fixed: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(fixed.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setFixed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_facing_direction_with_face(&self,face: impl Into<crate::block::BlockFace<'mc>>,force: std::option::Option<bool>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/block/BlockFace;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(face.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = force {
sig += "Z";
let val_2 = jni::objects::JValueGen::Bool(a.into());
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setFacingDirection",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/util/Vector;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/Vector;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/BoundingBox;";
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/World;";
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(x);
args.push(val_1);
sig += "D";
let val_2 = jni::objects::JValueGen::Double(y);
args.push(val_2);
sig += "D";
let val_3 = jni::objects::JValueGen::Double(z);
args.push(val_3);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(fire.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Server;";
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")F";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(distance);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/event/entity/EntityDamageEvent;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/event/entity/EntityDamageEvent;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/UUID;";
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(value);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/EntityEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityType;";
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(visible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(cooldown);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/PistonMoveReaction;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Pose;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/SpawnCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntitySnapshot;";
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn attached_face(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::BlockFace;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAttachedFace",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::ItemFrame<'mc>> for GlowItemFrame<'mc>{

fn into(self) -> crate::entity::ItemFrame<'mc> {

crate::entity::ItemFrame::from_raw(&self.jni_ref(), self.1).expect("Error converting GlowItemFrame into crate::entity::ItemFrame")

   }
}
#[repr(C)]
pub struct EntitySnapshot<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for EntitySnapshot<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for EntitySnapshot<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EntitySnapshot from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EntitySnapshot")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EntitySnapshot object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> EntitySnapshot<'mc> {
	pub fn create_entity_with_to(&self,to: impl Into<crate::Location<'mc>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(to.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"createEntity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn entity_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::EntityType;");
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityType",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
#[repr(C)]
pub struct Snowball<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Snowball<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Snowball<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Snowball from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Snowball")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Snowball object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Snowball<'mc> {
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/util/Vector;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/Vector;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/BoundingBox;";
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/World;";
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
if let Some(a) = pitch {
sig += "F";
let val_2 = jni::objects::JValueGen::Float(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(x);
args.push(val_1);
sig += "D";
let val_2 = jni::objects::JValueGen::Double(y);
args.push(val_2);
sig += "D";
let val_3 = jni::objects::JValueGen::Double(z);
args.push(val_3);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(fire.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Server;";
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")F";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(distance);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/event/entity/EntityDamageEvent;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/event/entity/EntityDamageEvent;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/UUID;";
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(value);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/EntityEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityType;";
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(visible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(cooldown);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/PistonMoveReaction;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Pose;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/SpawnCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntitySnapshot;";
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::ThrowableProjectile<'mc>> for Snowball<'mc>{

fn into(self) -> crate::entity::ThrowableProjectile<'mc> {

crate::entity::ThrowableProjectile::from_raw(&self.jni_ref(), self.1).expect("Error converting Snowball into crate::entity::ThrowableProjectile")

   }
}
#[repr(C)]
pub struct EnderSignal<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for EnderSignal<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for EnderSignal<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EnderSignal from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderSignal")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EnderSignal object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> EnderSignal<'mc> {
	pub fn tarlocation(&self) 
-> Result<crate::Location<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getTargetLocation",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_target_location(&self,location: impl Into<crate::Location<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setTargetLocation",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn drop_item(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDropItem",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_drop_item(&self,drop: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(drop.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setDropItem",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::ItemStack;");
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn despawn_timer(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDespawnTimer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_despawn_timer(&self,timer: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(timer);
let res = self.jni_ref().call_method(&self.jni_object(),"setDespawnTimer",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/util/Vector;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/Vector;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/BoundingBox;";
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/World;";
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
if let Some(a) = pitch {
sig += "F";
let val_2 = jni::objects::JValueGen::Float(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(x);
args.push(val_1);
sig += "D";
let val_2 = jni::objects::JValueGen::Double(y);
args.push(val_2);
sig += "D";
let val_3 = jni::objects::JValueGen::Double(z);
args.push(val_3);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(fire.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Server;";
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")F";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(distance);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/event/entity/EntityDamageEvent;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/event/entity/EntityDamageEvent;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/UUID;";
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(value);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/EntityEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityType;";
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(visible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(cooldown);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/PistonMoveReaction;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Pose;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/SpawnCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntitySnapshot;";
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: std::option::Option<impl Into<crate::metadata::MetadataValue<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
args.push(val_1);
if let Some(a) = new_metadata_value {
sig += "Lorg/bukkit/metadata/MetadataValue;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/lang/String;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for EnderSignal<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting EnderSignal into crate::entity::Entity")

   }
}
#[repr(C)]
pub struct Snowman<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Snowman<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Snowman<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Snowman from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Snowman")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Snowman object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Snowman<'mc> {
	pub fn is_derp(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isDerp",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_derp(&self,derp_mode: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(derp_mode.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setDerp",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Golem<'mc>> for Snowman<'mc>{

fn into(self) -> crate::entity::Golem<'mc> {

crate::entity::Golem::from_raw(&self.jni_ref(), self.1).expect("Error converting Snowman into crate::entity::Golem")

   }
}
#[repr(C)]
pub struct EnderCrystal<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for EnderCrystal<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for EnderCrystal<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate EnderCrystal from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderCrystal")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a EnderCrystal object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> EnderCrystal<'mc> {
	pub fn is_showing_bottom(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isShowingBottom",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_showing_bottom(&self,showing: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(showing.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setShowingBottom",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn beam_target(&self) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::Location;");
let res = self.jni_ref().call_method(&self.jni_object(),"getBeamTarget",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_beam_target(&self,location: impl Into<crate::Location<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/Location;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setBeamTarget",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/util/Vector;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/Vector;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/BoundingBox;";
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/World;";
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
if let Some(a) = pitch {
sig += "F";
let val_2 = jni::objects::JValueGen::Float(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(x);
args.push(val_1);
sig += "D";
let val_2 = jni::objects::JValueGen::Double(y);
args.push(val_2);
sig += "D";
let val_3 = jni::objects::JValueGen::Double(z);
args.push(val_3);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(fire.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Server;";
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")F";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(distance);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/event/entity/EntityDamageEvent;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/event/entity/EntityDamageEvent;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/UUID;";
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(value);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/EntityEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityType;";
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(visible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(cooldown);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/PistonMoveReaction;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Pose;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/SpawnCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntitySnapshot;";
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_metadata(&self,metadata_key: impl Into<String>,new_metadata_value: std::option::Option<impl Into<crate::metadata::MetadataValue<'mc>>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
args.push(val_1);
if let Some(a) = new_metadata_value {
sig += "Lorg/bukkit/metadata/MetadataValue;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setMetadata",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_metadata(&self,metadata_key: impl Into<String>) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)LVec;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"getMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn has_metadata(&self,metadata_key: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;)Lbool;");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let res = self.jni_ref().call_method(&self.jni_object(),"hasMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_metadata(&self,metadata_key: impl Into<String>,owning_plugin: impl Into<crate::plugin::Plugin<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Ljava/lang/String;Lorg/bukkit/plugin/Plugin;)L();");
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(metadata_key.into())?));
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"removeMetadata",sig.as_str(),vec![jni::objects::JValueGen::from(val_1),jni::objects::JValueGen::from(val_2)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_messages(&self,messages: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(messages.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn send_message_with_sender(&self,sender: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,messages: std::option::Option<impl Into<String>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/util/UUID;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(sender.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = messages {
sig += "Ljava/lang/String;";
let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(a.into())?));
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"sendMessage",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn name(&self) 
-> Result<String, Box<dyn std::error::Error>>

{let sig = String::from("()LString;");
let res = self.jni_ref().call_method(&self.jni_object(),"getName",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)}
	pub fn custom_name(&self) 
-> Result<Option<String>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/lang/String;";
let res = self.jni_ref().call_method(&self.jni_object(),"getCustomName",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
self.jni_ref().get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?.to_string_lossy().to_string()
)
)}
	pub fn set_custom_name(&self,name: impl Into<String>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(name.into())?));
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomName",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn persistent_data_container(&self) 
-> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::persistence::PersistentDataContainer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPersistentDataContainer",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Entity<'mc>> for EnderCrystal<'mc>{

fn into(self) -> crate::entity::Entity<'mc> {

crate::entity::Entity::from_raw(&self.jni_ref(), self.1).expect("Error converting EnderCrystal into crate::entity::Entity")

   }
}
#[repr(C)]
pub struct Llama<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for Llama<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for Llama<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate Llama from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Llama")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a Llama object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> Llama<'mc> {
	pub fn color(&self) 
-> Result<crate::entity::LlamaColor<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::LlamaColor;");
let res = self.jni_ref().call_method(&self.jni_object(),"getColor",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::LlamaColor::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_color(&self,color: impl Into<crate::entity::LlamaColor<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Llama/Color;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(color.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setColor",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn strength(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_strength(&self,strength: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_carrying_chest(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCarryingChest",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_carrying_chest(&self,chest: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(chest.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCarryingChest",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn variant(&self) 
-> Result<crate::entity::HorseVariant<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::HorseVariant;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVariant",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::HorseVariant::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
#[deprecated]

	pub fn set_variant(&self,variant: impl Into<crate::entity::HorseVariant<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/Horse/Variant;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(variant.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVariant",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn max_domestication(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxDomestication",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_max_domestication(&self,level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(level);
let res = self.jni_ref().call_method(&self.jni_object(),"setMaxDomestication",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn jump_strength(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getJumpStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_jump_strength(&self,strength: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setJumpStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_eating_haystack(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isEatingHaystack",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_eating_haystack(&self,eating_haystack: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(eating_haystack.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setEatingHaystack",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn inventory(&self) 
-> Result<crate::inventory::AbstractHorseInventory<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::inventory::AbstractHorseInventory;");
let res = self.jni_ref().call_method(&self.jni_object(),"getInventory",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::AbstractHorseInventory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::util::Vector;");
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_velocity(&self,vel: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/util/Vector;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(vel.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_tamed(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isTamed",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_tamed(&self,tame: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(tame.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setTamed",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn owner(&self) 
-> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AnimalTamer;");
let res = self.jni_ref().call_method(&self.jni_object(),"getOwner",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::AnimalTamer::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_owner(&self,tamer: impl Into<crate::entity::AnimalTamer<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(tamer.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setOwner",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::ChestedHorse<'mc>> for Llama<'mc>{

fn into(self) -> crate::entity::ChestedHorse<'mc> {

crate::entity::ChestedHorse::from_raw(&self.jni_ref(), self.1).expect("Error converting Llama into crate::entity::ChestedHorse")

   }
}
#[repr(C)]
pub struct AbstractArrow<'mc>(pub(crate) blackboxmc_general::SharedJNIEnv<'mc>, pub(crate) jni::objects::JObject<'mc>);

    impl<'mc> JNIRaw<'mc> for AbstractArrow<'mc> {
        fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        
self.0.clone()
}
fn jni_object(&self) -> jni::objects::JObject<'mc> {
unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
}
}
impl<'mc> JNIInstantiatable<'mc> for AbstractArrow<'mc> {
        fn from_raw(
            env: &blackboxmc_general::SharedJNIEnv<'mc>,
            obj: jni::objects::JObject<'mc>,
        ) -> Result<Self, Box<dyn std::error::Error>> {
            if obj.is_null() {
                return Err(eyre::eyre!(
                    "Tried to instantiate AbstractArrow from null object.")
                .into());
            }
            let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AbstractArrow")?;
            if !valid {
                Err(eyre::eyre!(
                    "Invalid argument passed. Expected a AbstractArrow object, got {}",
                    name
                )
                .into())
            } else {
    Ok(Self(env.clone(), obj))
            }
        }
    }
    
impl<'mc> AbstractArrow<'mc> {
	pub fn knockback_strength(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getKnockbackStrength",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_knockback_strength(&self,knockback_strength: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(knockback_strength);
let res = self.jni_ref().call_method(&self.jni_object(),"setKnockbackStrength",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn damage(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let sig = String::from("()Lf64;");
let res = self.jni_ref().call_method(&self.jni_object(),"getDamage",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn set_damage(&self,damage: f64) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(D)L();");
let val_1 = jni::objects::JValueGen::Double(damage);
let res = self.jni_ref().call_method(&self.jni_object(),"setDamage",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn pierce_level(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let sig = String::from("()Li32;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPierceLevel",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_pierce_level(&self,pierce_level: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(I)L();");
let val_1 = jni::objects::JValueGen::Int(pierce_level);
let res = self.jni_ref().call_method(&self.jni_object(),"setPierceLevel",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_critical(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isCritical",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_critical(&self,critical: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(critical.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setCritical",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_in_block(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isInBlock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn attached_block(&self) 
-> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::block::Block;");
let res = self.jni_ref().call_method(&self.jni_object(),"getAttachedBlock",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::block::Block::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn pickup_status(&self) 
-> Result<crate::entity::AbstractArrowPickupStatus<'mc>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::entity::AbstractArrowPickupStatus;");
let res = self.jni_ref().call_method(&self.jni_object(),"getPickupStatus",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::AbstractArrowPickupStatus::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_pickup_status(&self,status: impl Into<crate::entity::AbstractArrowPickupStatus<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/entity/AbstractArrow/PickupStatus;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(status.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setPickupStatus",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_shot_from_crossbow(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"isShotFromCrossbow",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_shot_from_crossbow(&self,shot_from_crossbow: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(shot_from_crossbow.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setShotFromCrossbow",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn item(&self) 
-> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/inventory/ItemStack;";
let res = self.jni_ref().call_method(&self.jni_object(),"getItem",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::inventory::ItemStack::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_item(&self,item: impl Into<crate::inventory::ItemStack<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/inventory/ItemStack;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(item.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setItem",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn shooter(&self) 
-> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>>

{let sig = String::from("()Lcrate::projectiles::ProjectileSource;");
let res = self.jni_ref().call_method(&self.jni_object(),"getShooter",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_shooter(&self,source: impl Into<crate::projectiles::ProjectileSource<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)L();");
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(source.into().jni_object().clone())});
let res = self.jni_ref().call_method(&self.jni_object(),"setShooter",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn does_bounce(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let sig = String::from("()Lbool;");
let res = self.jni_ref().call_method(&self.jni_object(),"doesBounce",sig.as_str(),vec![]);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
#[deprecated]

	pub fn set_bounce(&self,does_bounce: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let sig = String::from("(Z)L();");
let val_1 = jni::objects::JValueGen::Bool(does_bounce.into());
let res = self.jni_ref().call_method(&self.jni_object(),"setBounce",sig.as_str(),vec![jni::objects::JValueGen::from(val_1)]);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_location(&self,loc: impl Into<crate::Location<'mc>>) 
-> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(loc.into().jni_object().clone())});
args.push(val_1);
sig += ")Lorg/bukkit/Location;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLocation",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::Location::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_velocity(&self,velocity: impl Into<crate::util::Vector<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/util/Vector;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(velocity.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVelocity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn velocity(&self) 
-> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/Vector;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVelocity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::Vector::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn height(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getHeight",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn width(&self) 
-> Result<f64, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")D";
let res = self.jni_ref().call_method(&self.jni_object(),"getWidth",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.d()?
)}
	pub fn bounding_box(&self) 
-> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/util/BoundingBox;";
let res = self.jni_ref().call_method(&self.jni_object(),"getBoundingBox",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::util::BoundingBox::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_on_ground(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isOnGround",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_in_water(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWater",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn world(&self) 
-> Result<crate::World<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/World;";
let res = self.jni_ref().call_method(&self.jni_object(),"getWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::World::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_rotation(&self,yaw: f32,pitch: std::option::Option<f32>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(yaw);
args.push(val_1);
if let Some(a) = pitch {
sig += "F";
let val_2 = jni::objects::JValueGen::Float(a);
args.push(val_2);
}
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setRotation",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn teleport_with_destination(&self,destination: impl Into<crate::entity::Entity<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(destination.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn teleport_with_location(&self,location: impl Into<crate::Location<'mc>>,cause: std::option::Option<impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(location.into().jni_object().clone())});
args.push(val_1);
if let Some(a) = cause {
sig += "Lorg/bukkit/event/player/PlayerTeleportEvent/TeleportCause;";
let val_2 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_2);
}
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"teleport",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn get_nearby_entities(&self,x: f64,y: f64,z: f64) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "D";
let val_1 = jni::objects::JValueGen::Double(x);
args.push(val_1);
sig += "D";
let val_2 = jni::objects::JValueGen::Double(y);
args.push(val_2);
sig += "D";
let val_3 = jni::objects::JValueGen::Double(z);
args.push(val_3);
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getNearbyEntities",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn entity_id(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getEntityId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_fire_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFireTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_fire_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFireTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn set_visual_fire(&self,fire: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(fire.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisualFire",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visual_fire(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisualFire",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn max_freeze_ticks(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getMaxFreezeTicks",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_freeze_ticks(&self,ticks: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(ticks);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFreezeTicks",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_frozen(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isFrozen",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove(&self) 
-> Result<(), Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"remove",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_dead(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isDead",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_valid(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isValid",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn server(&self) 
-> Result<crate::Server<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Server;";
let res = self.jni_ref().call_method(&self.jni_object(),"getServer",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Server::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_persistent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isPersistent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_persistent(&self,persistent: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(persistent.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPersistent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn passenger(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
#[deprecated]

	pub fn set_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"setPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn passengers(&self) 
-> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/List;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPassengers",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
let mut new_vec = Vec::new();
let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;let iter = list.iterator()?;
while iter.has_next()? {            let obj = iter.next()?;
new_vec.push(obj);
};
Ok(
new_vec
)}
	pub fn add_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addPassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_passenger(&self,passenger: impl Into<crate::entity::Entity<'mc>>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/entity/Entity;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(passenger.into().jni_object().clone())});
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removePassenger",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_empty(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isEmpty",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn eject(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"eject",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn fall_distance(&self) 
-> Result<f32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")F";
let res = self.jni_ref().call_method(&self.jni_object(),"getFallDistance",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.f()?
)}
	pub fn set_fall_distance(&self,distance: f32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "F";
let val_1 = jni::objects::JValueGen::Float(distance);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setFallDistance",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
#[deprecated]

	pub fn set_last_damage_cause(&self,event: impl Into<crate::event::entity::EntityDamageEvent<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/event/entity/EntityDamageEvent;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(event.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setLastDamageCause",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn last_damage_cause(&self) 
-> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/event/entity/EntityDamageEvent;";
let res = self.jni_ref().call_method(&self.jni_object(),"getLastDamageCause",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::event::entity::EntityDamageEvent::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn unique_id(&self) 
-> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/UUID;";
let res = self.jni_ref().call_method(&self.jni_object(),"getUniqueId",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn ticks_lived(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getTicksLived",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_ticks_lived(&self,value: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(value);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setTicksLived",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn play_effect(&self,val_type: impl Into<crate::EntityEffect<'mc>>) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Lorg/bukkit/EntityEffect;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(val_type.into().jni_object().clone())});
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"playEffect",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn get_type(&self) 
-> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntityType;";
let res = self.jni_ref().call_method(&self.jni_object(),"getType",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::EntityType::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn swim_high_speed_splash_sound(&self) 
-> Result<crate::Sound<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/Sound;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSwimHighSpeedSplashSound",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::Sound::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_inside_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInsideVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn leave_vehicle(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"leaveVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn vehicle(&self) 
-> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"getVehicle",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn set_custom_name_visible(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setCustomNameVisible",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_custom_name_visible(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isCustomNameVisible",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_visible_by_default(&self,visible: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(visible.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setVisibleByDefault",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_visible_by_default(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isVisibleByDefault",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn tracked_by(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getTrackedBy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn set_glowing(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGlowing",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_glowing(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isGlowing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_invulnerable(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setInvulnerable",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn is_invulnerable(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInvulnerable",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn is_silent(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isSilent",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_silent(&self,flag: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(flag.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setSilent",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn has_gravity(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"hasGravity",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn set_gravity(&self,gravity: bool) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Z";
let val_1 = jni::objects::JValueGen::Bool(gravity.into());
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setGravity",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn portal_cooldown(&self) 
-> Result<i32, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")I";
let res = self.jni_ref().call_method(&self.jni_object(),"getPortalCooldown",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.i()?
)}
	pub fn set_portal_cooldown(&self,cooldown: i32) 
-> Result<(), Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "I";
let val_1 = jni::objects::JValueGen::Int(cooldown);
args.push(val_1);
sig += ")V";
let res = self.jni_ref().call_method(&self.jni_object(),"setPortalCooldown",sig.as_str(),args);
self.jni_ref().translate_error(res)?;
Ok(
()
)}
	pub fn scoreboard_tags(&self) 
-> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Ljava/util/Set;";
let res = self.jni_ref().call_method(&self.jni_object(),"getScoreboardTags",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn add_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"addScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn remove_scoreboard_tag(&self,tag: impl Into<String>) 
-> Result<bool, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
sig += "Ljava/lang/String;";
let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(self.jni_ref().new_string(tag.into())?));
args.push(val_1);
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"removeScoreboardTag",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn piston_move_reaction(&self) 
-> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/PistonMoveReaction;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPistonMoveReaction",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::PistonMoveReaction::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn facing(&self) 
-> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/block/BlockFace;";
let res = self.jni_ref().call_method(&self.jni_object(),"getFacing",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::block::BlockFace::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn pose(&self) 
-> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/Pose;";
let res = self.jni_ref().call_method(&self.jni_object(),"getPose",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Pose::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn spawn_category(&self) 
-> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/SpawnCategory;";
let res = self.jni_ref().call_method(&self.jni_object(),"getSpawnCategory",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::SpawnCategory::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}
	pub fn is_in_world(&self) 
-> Result<bool, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Z";
let res = self.jni_ref().call_method(&self.jni_object(),"isInWorld",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
Ok(
res.z()?
)}
	pub fn create_snapshot(&self) 
-> Result<Option<crate::entity::EntitySnapshot<'mc>>, Box<dyn std::error::Error>>

{let args = Vec::new();
let mut sig = String::from("(");
sig += ")Lorg/bukkit/entity/EntitySnapshot;";
let res = self.jni_ref().call_method(&self.jni_object(),"createSnapshot",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {return Ok(None);}
Ok(
Some(
crate::entity::EntitySnapshot::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)?
)
)}
	pub fn copy_with_to(&self,to: std::option::Option<impl Into<crate::Location<'mc>>>) 
-> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>>

{let mut args = Vec::new();
let mut sig = String::from("(");
if let Some(a) = to {
sig += "Lorg/bukkit/Location;";
let val_1 = jni::objects::JValueGen::Object(unsafe { jni::objects::JObject::from_raw(a.into().jni_object().clone())});
args.push(val_1);
}
sig += ")Lorg/bukkit/entity/Entity;";
let res = self.jni_ref().call_method(&self.jni_object(),"copy",sig.as_str(),args);
let res = 
self.jni_ref().translate_error(res)?;
crate::entity::Entity::from_raw(&self.jni_ref(),unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) }
)}

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error>  {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
    
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for AbstractArrow<'mc>{

fn into(self) -> crate::entity::Projectile<'mc> {

crate::entity::Projectile::from_raw(&self.jni_ref(), self.1).expect("Error converting AbstractArrow into crate::entity::Projectile")

   }
}
pub mod minecart;
pub mod memory;
