#![allow(deprecated)]
use blackboxmc_general::JNIInstantiatable;
use blackboxmc_general::JNIRaw;
use color_eyre::eyre::Result;
/// Represents a base entity in the world
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Entity<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Entity<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Entity<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Entity from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Entity")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Entity object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Entity<'mc> {
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/block/BlockFace;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getFacing", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::BlockFace::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/World;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getWorld", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::World::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isSilent", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPortalCooldown",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/block/PistonMoveReaction;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPistonMoveReaction",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::block::PistonMoveReaction::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isValid", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Returns a list of entities within a bounding box centered around this entity
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Sets the entity's rotation.
    /// <p>Note that if the entity is affected by AI, it may override this rotation.</p>
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(FF)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let val_2 = jni::objects::JValueGen::Float(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRotation",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/Vector;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVelocity",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/Vector;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getVelocity", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::Vector::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getHeight", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }

    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getWidth", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }

    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/BoundingBox;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBoundingBox", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::BoundingBox::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isOnGround", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isInWater", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getEntityId", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the entity's current fire ticks (ticks before the entity stops being on fire).
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets if the entity has visual fire (it will always appear to be on fire).
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVisualFire",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isVisualFire", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the entity's current freeze ticks (amount of ticks the entity has been in powdered snow).
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isDead", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Server;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getServer", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Server::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isPersistent", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether or not the entity gets persisted.
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPersistent",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Entity;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassenger", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Entity::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPassenger",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }

    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "addPassenger",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removePassenger",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "eject", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFallDistance", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the fall distance for this entity
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFallDistance",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/event/entity/EntityDamageEvent;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLastDamageCause",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let sig = String::from("()Lorg/bukkit/event/entity/EntityDamageEvent;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLastDamageCause",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::event::entity::EntityDamageEvent::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/UUID;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getUniqueId", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getTicksLived", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the amount of ticks this entity has lived for.
    /// <p>This is the equivalent to "age" in entities. May not be less than one tick.</p>
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTicksLived",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/EntityEffect;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "playEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getSwimSound", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getSwimSplashSound",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getSwimHighSpeedSplashSound",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isInsideVehicle", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "leaveVehicle", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Entity;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getVehicle", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Entity::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Sets whether or not to display the mob's custom name client side. The name will be displayed above the mob similarly to a player.
    /// <p>This value has no effect on players, they will always display their name.</p>
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCustomNameVisible",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isCustomNameVisible",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether or not this entity is visible by default. If this entity is not visible by default, then <a href="Player.html#showEntity(org.bukkit.plugin.Plugin,org.bukkit.entity.Entity)"><code>Player.showEntity(org.bukkit.plugin.Plugin, org.bukkit.entity.Entity)</code></a> will need to be called before the entity is visible to a given player.
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVisibleByDefault",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isVisibleByDefault",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the entity has a team colored (default: white) glow. <b>nb: this refers to the 'Glowing' entity property, not whether a glowing potion effect is applied</b>
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setGlowing",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isGlowing", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the entity is invulnerable or not.
    /// <p>When an entity is invulnerable it can only be damaged by players in creative mode.</p>
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setInvulnerable",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isInvulnerable", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the entity is silent or not.
    /// <p>When an entity is silent it will not produce any sound.</p>
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSilent",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "hasGravity", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether gravity applies to this entity.
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setGravity",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets the period of time (in ticks) before this entity can use a portal.
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPortalCooldown",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Z");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "addScoreboardTag",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Z");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removeScoreboardTag",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Pose;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getPose", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::Pose::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/SpawnCategory;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getSpawnCategory",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::SpawnCategory::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Lorg/bukkit/command/CommandSender$Spigot;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "spigot", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::command::CommandSenderSpigot::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "remove", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isEmpty", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLocation", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/EntityType;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::EntityType::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isFrozen", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn set_metadata(
        &self,
        arg0: impl Into<String>,
        arg1: impl Into<crate::metadata::MetadataValue<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Entity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::metadata::Metadatable = temp_clone.into();
        real.set_metadata(arg0, arg1)
    }
    pub fn get_metadata(
        &self,
        arg0: impl Into<String>,
    ) -> Result<Vec<crate::metadata::MetadataValue<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Entity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::metadata::Metadatable = temp_clone.into();
        real.get_metadata(arg0)
    }
    pub fn has_metadata(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Entity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::metadata::Metadatable = temp_clone.into();
        real.has_metadata(arg0)
    }
    pub fn remove_metadata(
        &self,
        arg0: impl Into<String>,
        arg1: impl Into<crate::plugin::Plugin<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Entity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::metadata::Metadatable = temp_clone.into();
        real.remove_metadata(arg0, arg1)
    }
    pub fn send_message_with_strings(
        &self,
        arg0: Vec<String>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "[Ljava/lang/String;";
        let arr = self.jni_ref().new_object_array(
            arg0.len() as i32,
            "java/lang/String",
            jni::objects::JObject::null(),
        );
        let arr = self.jni_ref().translate_error_no_gen(arr)?;
        for i in 0..arg0.len() {
            let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                self.jni_ref().new_string(arg0.get(i).unwrap().clone())?,
            ));
            self.jni_ref()
                .set_object_array_element(&arr, i as i32, val_1.l()?)?;
        }
        let val_1 = jni::objects::JValueGen::Object(arr);
        args.push(val_1.l()?.into());
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "sendMessage", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn send_message_with_uuid(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
        arg1: std::option::Option<impl Into<String>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/util/UUID;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Ljava/lang/String;";
            let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                self.jni_ref().new_string(a.into())?,
            ));
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "sendMessage", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn name(&self) -> Result<String, Box<dyn std::error::Error>> {
        let temp_clone = Entity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::command::CommandSender = temp_clone.into();
        real.name()
    }
    pub fn custom_name(&self) -> Result<Option<String>, Box<dyn std::error::Error>> {
        let temp_clone = Entity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::Nameable = temp_clone.into();
        real.custom_name()
    }
    pub fn set_custom_name(
        &self,
        arg0: impl Into<String>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Entity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::Nameable = temp_clone.into();
        real.set_custom_name(arg0)
    }
    pub fn persistent_data_container(
        &self,
    ) -> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Entity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::persistence::PersistentDataHolder = temp_clone.into();
        real.persistent_data_container()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::metadata::Metadatable<'mc>> for Entity<'mc> {
    fn into(self) -> crate::metadata::Metadatable<'mc> {
        crate::metadata::Metadatable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Entity into crate::metadata::Metadatable")
    }
}
impl<'mc> Into<crate::command::CommandSender<'mc>> for Entity<'mc> {
    fn into(self) -> crate::command::CommandSender<'mc> {
        crate::command::CommandSender::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Entity into crate::command::CommandSender")
    }
}
impl<'mc> Into<crate::Nameable<'mc>> for Entity<'mc> {
    fn into(self) -> crate::Nameable<'mc> {
        crate::Nameable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Entity into crate::Nameable")
    }
}
impl<'mc> Into<crate::persistence::PersistentDataHolder<'mc>> for Entity<'mc> {
    fn into(self) -> crate::persistence::PersistentDataHolder<'mc> {
        crate::persistence::PersistentDataHolder::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Entity into crate::persistence::PersistentDataHolder")
    }
}
/// Represents a Creature. Creatures are non-intelligent monsters or animals which have very simple abilities.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Creature<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Creature<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Creature<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Creature from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Creature")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Creature object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Creature<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Mob<'mc>> for Creature<'mc> {
    fn into(self) -> crate::entity::Mob<'mc> {
        crate::entity::Mob::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Creature into crate::entity::Mob")
    }
}
/// Represents a Donkey - variant of <a href="ChestedHorse.html" title="interface in org.bukkit.entity"><code>ChestedHorse</code></a>.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Donkey<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Donkey<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Donkey<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Donkey from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Donkey")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Donkey object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Donkey<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::ChestedHorse<'mc>> for Donkey<'mc> {
    fn into(self) -> crate::entity::ChestedHorse<'mc> {
        crate::entity::ChestedHorse::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Donkey into crate::entity::ChestedHorse")
    }
}
/// Represents a state in which a fishing hook may be.
pub enum FishHookHookState<'mc> {
    Unhooked { inner: FishHookHookStateStruct<'mc> },
    HookedEntity { inner: FishHookHookStateStruct<'mc> },
    Bobbing { inner: FishHookHookStateStruct<'mc> },
}
impl<'mc> std::fmt::Display for FishHookHookState<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FishHookHookState::Unhooked { .. } => f.write_str("UNHOOKED"),
            FishHookHookState::HookedEntity { .. } => f.write_str("HOOKED_ENTITY"),
            FishHookHookState::Bobbing { .. } => f.write_str("BOBBING"),
        }
    }
}

impl<'mc> FishHookHookState<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<FishHookHookState<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/FishHook$HookState");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/FishHook$HookState;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "UNHOOKED" => Ok(FishHookHookState::Unhooked {
                inner: FishHookHookStateStruct::from_raw(env, obj)?,
            }),
            "HOOKED_ENTITY" => Ok(FishHookHookState::HookedEntity {
                inner: FishHookHookStateStruct::from_raw(env, obj)?,
            }),
            "BOBBING" => Ok(FishHookHookState::Bobbing {
                inner: FishHookHookStateStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct FishHookHookStateStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for FishHookHookState<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Unhooked { inner } => inner.0.clone(),
            Self::HookedEntity { inner } => inner.0.clone(),
            Self::Bobbing { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Unhooked { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::HookedEntity { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Bobbing { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FishHookHookState<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate FishHookHookState from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/FishHook$HookState")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FishHookHookState object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "UNHOOKED" => Ok(FishHookHookState::Unhooked {
                    inner: FishHookHookStateStruct::from_raw(env, obj)?,
                }),
                "HOOKED_ENTITY" => Ok(FishHookHookState::HookedEntity {
                    inner: FishHookHookStateStruct::from_raw(env, obj)?,
                }),
                "BOBBING" => Ok(FishHookHookState::Bobbing {
                    inner: FishHookHookStateStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for FishHookHookStateStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FishHookHookStateStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate FishHookHookStateStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/FishHook$HookState")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FishHookHookStateStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> FishHookHookStateStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum VariantVariant<'mc> {
    Temperate { inner: VariantVariantStruct<'mc> },
    Warm { inner: VariantVariantStruct<'mc> },
    Cold { inner: VariantVariantStruct<'mc> },
}
impl<'mc> std::fmt::Display for VariantVariant<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VariantVariant::Temperate { .. } => f.write_str("TEMPERATE"),
            VariantVariant::Warm { .. } => f.write_str("WARM"),
            VariantVariant::Cold { .. } => f.write_str("COLD"),
        }
    }
}

impl<'mc> VariantVariant<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<VariantVariant<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Variant$Variant");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Variant$Variant;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "TEMPERATE" => Ok(VariantVariant::Temperate {
                inner: VariantVariantStruct::from_raw(env, obj)?,
            }),
            "WARM" => Ok(VariantVariant::Warm {
                inner: VariantVariantStruct::from_raw(env, obj)?,
            }),
            "COLD" => Ok(VariantVariant::Cold {
                inner: VariantVariantStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct VariantVariantStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for VariantVariant<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Temperate { inner } => inner.0.clone(),
            Self::Warm { inner } => inner.0.clone(),
            Self::Cold { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Temperate { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Warm { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cold { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for VariantVariant<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate VariantVariant from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Variant$Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a VariantVariant object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "TEMPERATE" => Ok(VariantVariant::Temperate {
                    inner: VariantVariantStruct::from_raw(env, obj)?,
                }),
                "WARM" => Ok(VariantVariant::Warm {
                    inner: VariantVariantStruct::from_raw(env, obj)?,
                }),
                "COLD" => Ok(VariantVariant::Cold {
                    inner: VariantVariantStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for VariantVariantStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for VariantVariantStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate VariantVariantStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Variant$Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a VariantVariantStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> VariantVariantStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// A mechanical creature that may harm enemies.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Golem<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Golem<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Golem<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Golem from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Golem")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Golem object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Golem<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Creature<'mc>> for Golem<'mc> {
    fn into(self) -> crate::entity::Creature<'mc> {
        crate::entity::Creature::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Golem into crate::entity::Creature")
    }
}
/// Represents an Ender Dragon
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct EnderDragon<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EnderDragon<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EnderDragon<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate EnderDragon from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderDragon")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EnderDragon object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EnderDragon<'mc> {
    pub fn phase(
        &self,
    ) -> Result<crate::entity::EnderDragonPhase<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/EnderDragon$Phase;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getPhase", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::EnderDragonPhase::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_phase(
        &self,
        arg0: impl Into<crate::entity::EnderDragonPhase<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/EnderDragon$Phase;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPhase",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn death_animation_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDeathAnimationTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn dragon_battle(
        &self,
    ) -> Result<Option<crate::boss::DragonBattle<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/boss/DragonBattle;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDragonBattle", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::boss::DragonBattle::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    pub fn parts(&self) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getParts", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn boss_bar(
        &self,
    ) -> Result<Option<crate::boss::BossBar<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = EnderDragon::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Boss = temp_clone.into();
        real.boss_bar()
    }
    pub fn set_aware(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderDragon::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Mob = temp_clone.into();
        real.set_aware(arg0)
    }
    pub fn is_aware(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderDragon::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Mob = temp_clone.into();
        real.is_aware()
    }
    pub fn ambient_sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = EnderDragon::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Mob = temp_clone.into();
        real.ambient_sound()
    }
    pub fn target(
        &self,
    ) -> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = EnderDragon::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Mob = temp_clone.into();
        real.target()
    }
    pub fn set_target(
        &self,
        arg0: impl Into<crate::entity::LivingEntity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderDragon::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Mob = temp_clone.into();
        real.set_target(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::ComplexLivingEntity<'mc>> for EnderDragon<'mc> {
    fn into(self) -> crate::entity::ComplexLivingEntity<'mc> {
        crate::entity::ComplexLivingEntity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting EnderDragon into crate::entity::ComplexLivingEntity")
    }
}
impl<'mc> Into<crate::entity::Boss<'mc>> for EnderDragon<'mc> {
    fn into(self) -> crate::entity::Boss<'mc> {
        crate::entity::Boss::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting EnderDragon into crate::entity::Boss")
    }
}
impl<'mc> Into<crate::entity::Mob<'mc>> for EnderDragon<'mc> {
    fn into(self) -> crate::entity::Mob<'mc> {
        crate::entity::Mob::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting EnderDragon into crate::entity::Mob")
    }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for EnderDragon<'mc> {
    fn into(self) -> crate::entity::Enemy<'mc> {
        crate::entity::Enemy::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting EnderDragon into crate::entity::Enemy")
    }
}
/// Represents a thrown trident.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Trident<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Trident<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Trident<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Trident from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Trident")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Trident object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Trident<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::AbstractArrow<'mc>> for Trident<'mc> {
    fn into(self) -> crate::entity::AbstractArrow<'mc> {
        crate::entity::AbstractArrow::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Trident into crate::entity::AbstractArrow")
    }
}
impl<'mc> Into<crate::entity::ThrowableProjectile<'mc>> for Trident<'mc> {
    fn into(self) -> crate::entity::ThrowableProjectile<'mc> {
        crate::entity::ThrowableProjectile::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Trident into crate::entity::ThrowableProjectile")
    }
}
/// Represents a phantom.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Phantom<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Phantom<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Phantom<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Phantom from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Phantom")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Phantom object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Phantom<'mc> {
    pub fn set_size(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSize",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn size(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getSize", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Flying<'mc>> for Phantom<'mc> {
    fn into(self) -> crate::entity::Flying<'mc> {
        crate::entity::Flying::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Phantom into crate::entity::Flying")
    }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for Phantom<'mc> {
    fn into(self) -> crate::entity::Enemy<'mc> {
        crate::entity::Enemy::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Phantom into crate::entity::Enemy")
    }
}
/// Represents a Piglin.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Piglin<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Piglin<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Piglin<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Piglin from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Piglin")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Piglin object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Piglin<'mc> {
    pub fn remove_barter_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Material;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removeBarterMaterial",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn is_able_to_hunt(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isAbleToHunt", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the piglin is able to hunt hoglins.
    pub fn set_is_able_to_hunt(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setIsAbleToHunt",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn add_barter_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Material;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "addBarterMaterial",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn add_material_of_interest(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Material;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "addMaterialOfInterest",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn remove_material_of_interest(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Material;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removeMaterialOfInterest",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn interest_list(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getInterestList", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn barter_list(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBarterList", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn is_immune_to_zombification(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Piglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::PiglinAbstract = temp_clone.into();
        real.is_immune_to_zombification()
    }
    pub fn set_immune_to_zombification(
        &self,
        arg0: bool,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Piglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::PiglinAbstract = temp_clone.into();
        real.set_immune_to_zombification(arg0)
    }

    pub fn set_baby(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Piglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::PiglinAbstract = temp_clone.into();
        real.set_baby(arg0)
    }

    pub fn is_baby(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Piglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::PiglinAbstract = temp_clone.into();
        real.is_baby()
    }
    pub fn is_converting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Piglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::PiglinAbstract = temp_clone.into();
        real.is_converting()
    }
    pub fn conversion_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Piglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::PiglinAbstract = temp_clone.into();
        real.conversion_time()
    }
    pub fn set_conversion_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Piglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::PiglinAbstract = temp_clone.into();
        real.set_conversion_time(arg0)
    }
    pub fn inventory(
        &self,
    ) -> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Piglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::inventory::InventoryHolder = temp_clone.into();
        real.inventory()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::PiglinAbstract<'mc>> for Piglin<'mc> {
    fn into(self) -> crate::entity::PiglinAbstract<'mc> {
        crate::entity::PiglinAbstract::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Piglin into crate::entity::PiglinAbstract")
    }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for Piglin<'mc> {
    fn into(self) -> crate::inventory::InventoryHolder<'mc> {
        crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Piglin into crate::inventory::InventoryHolder")
    }
}
/// Represents a villager NPC
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct AbstractVillager<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for AbstractVillager<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for AbstractVillager<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate AbstractVillager from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AbstractVillager")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a AbstractVillager object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> AbstractVillager<'mc> {
    pub fn inventory(
        &self,
    ) -> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/Inventory;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getInventory", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::Inventory::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_age_lock(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AbstractVillager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Breedable = temp_clone.into();
        real.set_age_lock(arg0)
    }

    pub fn age_lock(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AbstractVillager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Breedable = temp_clone.into();
        real.age_lock()
    }

    pub fn can_breed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AbstractVillager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Breedable = temp_clone.into();
        real.can_breed()
    }

    pub fn set_breed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AbstractVillager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Breedable = temp_clone.into();
        real.set_breed(arg0)
    }
    pub fn recipes(
        &self,
    ) -> Result<Vec<crate::inventory::MerchantRecipe<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getRecipes", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::inventory::MerchantRecipe::from_raw(
                &self.jni_ref(),
                obj,
            )?);
        }
        Ok(new_vec)
    }
    pub fn set_recipes(
        &self,
        arg0: Vec<impl Into<crate::inventory::MerchantRecipe<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/List;)V");
        let raw_val_1 = self
            .jni_ref()
            .new_object("java/util/ArrayList", "()V", vec![])?;
        for v in arg0 {
            let map_val_0 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(v.into().jni_object().clone())
            });
            self.jni_ref().call_method(
                &raw_val_1,
                "add",
                "(Lorg/bukkit/inventory/crate::inventory::MerchantRecipe)V",
                vec![jni::objects::JValueGen::from(map_val_0)],
            )?;
        }
        let val_1 = jni::objects::JValueGen::Object(raw_val_1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRecipes",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn get_recipe(
        &self,
        arg0: i32,
    ) -> Result<crate::inventory::MerchantRecipe<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AbstractVillager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::inventory::Merchant = temp_clone.into();
        real.get_recipe(arg0)
    }
    pub fn set_recipe(
        &self,
        arg0: i32,
        arg1: impl Into<crate::inventory::MerchantRecipe<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AbstractVillager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::inventory::Merchant = temp_clone.into();
        real.set_recipe(arg0, arg1)
    }
    pub fn recipe_count(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = AbstractVillager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::inventory::Merchant = temp_clone.into();
        real.recipe_count()
    }
    pub fn is_trading(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AbstractVillager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::inventory::Merchant = temp_clone.into();
        real.is_trading()
    }
    pub fn trader(
        &self,
    ) -> Result<Option<crate::entity::HumanEntity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = AbstractVillager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::inventory::Merchant = temp_clone.into();
        real.trader()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Breedable<'mc>> for AbstractVillager<'mc> {
    fn into(self) -> crate::entity::Breedable<'mc> {
        crate::entity::Breedable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting AbstractVillager into crate::entity::Breedable")
    }
}
impl<'mc> Into<crate::entity::NPC<'mc>> for AbstractVillager<'mc> {
    fn into(self) -> crate::entity::NPC<'mc> {
        crate::entity::NPC::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting AbstractVillager into crate::entity::NPC")
    }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for AbstractVillager<'mc> {
    fn into(self) -> crate::inventory::InventoryHolder<'mc> {
        crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting AbstractVillager into crate::inventory::InventoryHolder")
    }
}
impl<'mc> Into<crate::inventory::Merchant<'mc>> for AbstractVillager<'mc> {
    fn into(self) -> crate::inventory::Merchant<'mc> {
        crate::inventory::Merchant::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting AbstractVillager into crate::inventory::Merchant")
    }
}
pub enum HookState<'mc> {
    Unhooked { inner: HookStateStruct<'mc> },
    HookedEntity { inner: HookStateStruct<'mc> },
    Bobbing { inner: HookStateStruct<'mc> },
}
impl<'mc> std::fmt::Display for HookState<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HookState::Unhooked { .. } => f.write_str("UNHOOKED"),
            HookState::HookedEntity { .. } => f.write_str("HOOKED_ENTITY"),
            HookState::Bobbing { .. } => f.write_str("BOBBING"),
        }
    }
}

impl<'mc> HookState<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<HookState<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/HookState");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/HookState;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "UNHOOKED" => Ok(HookState::Unhooked {
                inner: HookStateStruct::from_raw(env, obj)?,
            }),
            "HOOKED_ENTITY" => Ok(HookState::HookedEntity {
                inner: HookStateStruct::from_raw(env, obj)?,
            }),
            "BOBBING" => Ok(HookState::Bobbing {
                inner: HookStateStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct HookStateStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for HookState<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Unhooked { inner } => inner.0.clone(),
            Self::HookedEntity { inner } => inner.0.clone(),
            Self::Bobbing { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Unhooked { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::HookedEntity { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Bobbing { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for HookState<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate HookState from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/HookState")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a HookState object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "UNHOOKED" => Ok(HookState::Unhooked {
                    inner: HookStateStruct::from_raw(env, obj)?,
                }),
                "HOOKED_ENTITY" => Ok(HookState::HookedEntity {
                    inner: HookStateStruct::from_raw(env, obj)?,
                }),
                "BOBBING" => Ok(HookState::Bobbing {
                    inner: HookStateStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for HookStateStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for HookStateStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate HookStateStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/HookState")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a HookStateStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> HookStateStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Arrow<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Arrow<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Arrow<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Arrow from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Arrow")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Arrow object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Arrow<'mc> {
    pub fn set_color(
        &self,
        arg0: impl Into<crate::Color<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Color;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setColor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn color(&self) -> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Color;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getColor", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn has_custom_effects(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasCustomEffects",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn custom_effects(
        &self,
    ) -> Result<Vec<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCustomEffects",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::potion::PotionEffect::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }

    pub fn add_custom_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffect<'mc>>,
        arg1: bool,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionEffect;Z)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Bool(arg1.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "addCustomEffect",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn remove_custom_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removeCustomEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn has_custom_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasCustomEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn clear_custom_effects(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "clearCustomEffects",
            sig.as_str(),
            vec![],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_base_potion_data(
        &self,
        arg0: impl Into<crate::potion::PotionData<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionData;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBasePotionData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn base_potion_data(
        &self,
    ) -> Result<crate::potion::PotionData<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/potion/PotionData;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBasePotionData",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::potion::PotionData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn set_damage(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Arrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.set_damage(arg0)
    }
    pub fn damage(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Arrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.damage()
    }
    pub fn knockback_strength(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Arrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.knockback_strength()
    }
    pub fn set_knockback_strength(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Arrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.set_knockback_strength(arg0)
    }
    pub fn pierce_level(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Arrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.pierce_level()
    }
    pub fn set_pierce_level(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Arrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.set_pierce_level(arg0)
    }
    pub fn is_critical(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Arrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.is_critical()
    }
    pub fn set_critical(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Arrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.set_critical(arg0)
    }
    pub fn is_in_block(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Arrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.is_in_block()
    }
    pub fn attached_block(
        &self,
    ) -> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Arrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.attached_block()
    }
    pub fn pickup_status(
        &self,
    ) -> Result<crate::entity::AbstractArrowPickupStatus<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/AbstractArrow$PickupStatus;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPickupStatus", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::AbstractArrowPickupStatus::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn set_pickup_status(
        &self,
        arg0: impl Into<crate::entity::AbstractArrowPickupStatus<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/AbstractArrow$PickupStatus;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPickupStatus",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_shot_from_crossbow(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Arrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.is_shot_from_crossbow()
    }
    pub fn set_shot_from_crossbow(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Arrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.set_shot_from_crossbow(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::AbstractArrow<'mc>> for Arrow<'mc> {
    fn into(self) -> crate::entity::AbstractArrow<'mc> {
        crate::entity::AbstractArrow::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Arrow into crate::entity::AbstractArrow")
    }
}
/// Represents an instance of a lightning strike. May or may not do damage.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct LightningStrike<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for LightningStrike<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for LightningStrike<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate LightningStrike from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LightningStrike")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a LightningStrike object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> LightningStrike<'mc> {
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Lorg/bukkit/command/CommandSender$Spigot;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "spigot", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::command::CommandSenderSpigot::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn is_effect(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isEffect", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = LightningStrike::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for LightningStrike<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting LightningStrike into crate::entity::Entity")
    }
}
pub enum Status<'mc> {
    InWater { inner: StatusStruct<'mc> },
    UnderWater { inner: StatusStruct<'mc> },
    UnderFlowingWater { inner: StatusStruct<'mc> },
    OnLand { inner: StatusStruct<'mc> },
    InAir { inner: StatusStruct<'mc> },
}
impl<'mc> std::fmt::Display for Status<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Status::InWater { .. } => f.write_str("IN_WATER"),
            Status::UnderWater { .. } => f.write_str("UNDER_WATER"),
            Status::UnderFlowingWater { .. } => f.write_str("UNDER_FLOWING_WATER"),
            Status::OnLand { .. } => f.write_str("ON_LAND"),
            Status::InAir { .. } => f.write_str("IN_AIR"),
        }
    }
}

impl<'mc> Status<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Status<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Status");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Status;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "IN_WATER" => Ok(Status::InWater {
                inner: StatusStruct::from_raw(env, obj)?,
            }),
            "UNDER_WATER" => Ok(Status::UnderWater {
                inner: StatusStruct::from_raw(env, obj)?,
            }),
            "UNDER_FLOWING_WATER" => Ok(Status::UnderFlowingWater {
                inner: StatusStruct::from_raw(env, obj)?,
            }),
            "ON_LAND" => Ok(Status::OnLand {
                inner: StatusStruct::from_raw(env, obj)?,
            }),
            "IN_AIR" => Ok(Status::InAir {
                inner: StatusStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct StatusStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Status<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::InWater { inner } => inner.0.clone(),
            Self::UnderWater { inner } => inner.0.clone(),
            Self::UnderFlowingWater { inner } => inner.0.clone(),
            Self::OnLand { inner } => inner.0.clone(),
            Self::InAir { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::InWater { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::UnderWater { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::UnderFlowingWater { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::OnLand { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::InAir { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Status<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Status from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Status")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Status object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "IN_WATER" => Ok(Status::InWater {
                    inner: StatusStruct::from_raw(env, obj)?,
                }),
                "UNDER_WATER" => Ok(Status::UnderWater {
                    inner: StatusStruct::from_raw(env, obj)?,
                }),
                "UNDER_FLOWING_WATER" => Ok(Status::UnderFlowingWater {
                    inner: StatusStruct::from_raw(env, obj)?,
                }),
                "ON_LAND" => Ok(Status::OnLand {
                    inner: StatusStruct::from_raw(env, obj)?,
                }),
                "IN_AIR" => Ok(Status::InAir {
                    inner: StatusStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for StatusStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for StatusStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate StatusStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Status")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a StatusStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> StatusStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// A Glow Squid.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct GlowSquid<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for GlowSquid<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for GlowSquid<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate GlowSquid from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/GlowSquid")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a GlowSquid object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> GlowSquid<'mc> {
    pub fn dark_ticks_remaining(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDarkTicksRemaining",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the number of dark ticks remaining for this squid. Bravo Six will go dark for 100 ticks (5 seconds) if damaged.
    pub fn set_dark_ticks_remaining(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDarkTicksRemaining",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Squid<'mc>> for GlowSquid<'mc> {
    fn into(self) -> crate::entity::Squid<'mc> {
        crate::entity::Squid::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting GlowSquid into crate::entity::Squid")
    }
}
/// Represents one of the Wither's heads.
pub enum WitherHead<'mc> {
    Center { inner: WitherHeadStruct<'mc> },
    Left { inner: WitherHeadStruct<'mc> },
    Right { inner: WitherHeadStruct<'mc> },
}
impl<'mc> std::fmt::Display for WitherHead<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            WitherHead::Center { .. } => f.write_str("CENTER"),
            WitherHead::Left { .. } => f.write_str("LEFT"),
            WitherHead::Right { .. } => f.write_str("RIGHT"),
        }
    }
}

impl<'mc> WitherHead<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<WitherHead<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Wither$Head");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Wither$Head;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "CENTER" => Ok(WitherHead::Center {
                inner: WitherHeadStruct::from_raw(env, obj)?,
            }),
            "LEFT" => Ok(WitherHead::Left {
                inner: WitherHeadStruct::from_raw(env, obj)?,
            }),
            "RIGHT" => Ok(WitherHead::Right {
                inner: WitherHeadStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct WitherHeadStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for WitherHead<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Center { inner } => inner.0.clone(),
            Self::Left { inner } => inner.0.clone(),
            Self::Right { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Center { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Left { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Right { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WitherHead<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate WitherHead from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Wither$Head")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WitherHead object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "CENTER" => Ok(WitherHead::Center {
                    inner: WitherHeadStruct::from_raw(env, obj)?,
                }),
                "LEFT" => Ok(WitherHead::Left {
                    inner: WitherHeadStruct::from_raw(env, obj)?,
                }),
                "RIGHT" => Ok(WitherHead::Right {
                    inner: WitherHeadStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for WitherHeadStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WitherHeadStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate WitherHeadStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Wither$Head")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WitherHeadStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> WitherHeadStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum Head<'mc> {
    Center { inner: HeadStruct<'mc> },
    Left { inner: HeadStruct<'mc> },
    Right { inner: HeadStruct<'mc> },
}
impl<'mc> std::fmt::Display for Head<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Head::Center { .. } => f.write_str("CENTER"),
            Head::Left { .. } => f.write_str("LEFT"),
            Head::Right { .. } => f.write_str("RIGHT"),
        }
    }
}

impl<'mc> Head<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Head<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Head");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Head;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "CENTER" => Ok(Head::Center {
                inner: HeadStruct::from_raw(env, obj)?,
            }),
            "LEFT" => Ok(Head::Left {
                inner: HeadStruct::from_raw(env, obj)?,
            }),
            "RIGHT" => Ok(Head::Right {
                inner: HeadStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct HeadStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Head<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Center { inner } => inner.0.clone(),
            Self::Left { inner } => inner.0.clone(),
            Self::Right { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Center { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Left { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Right { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Head<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Head from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Head")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Head object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "CENTER" => Ok(Head::Center {
                    inner: HeadStruct::from_raw(env, obj)?,
                }),
                "LEFT" => Ok(Head::Left {
                    inner: HeadStruct::from_raw(env, obj)?,
                }),
                "RIGHT" => Ok(Head::Right {
                    inner: HeadStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for HeadStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for HeadStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate HeadStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Head")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a HeadStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> HeadStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents an ElderGuardian - variant of <a href="Guardian.html" title="interface in org.bukkit.entity"><code>Guardian</code></a>.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ElderGuardian<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ElderGuardian<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ElderGuardian<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ElderGuardian from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ElderGuardian")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ElderGuardian object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ElderGuardian<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Guardian<'mc>> for ElderGuardian<'mc> {
    fn into(self) -> crate::entity::Guardian<'mc> {
        crate::entity::Guardian::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ElderGuardian into crate::entity::Guardian")
    }
}
/// Represents Evoker Fangs.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct EvokerFangs<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EvokerFangs<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EvokerFangs<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate EvokerFangs from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EvokerFangs")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EvokerFangs object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EvokerFangs<'mc> {
    pub fn owner(
        &self,
    ) -> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/LivingEntity;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getOwner", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::LivingEntity::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_owner(
        &self,
        arg0: impl Into<crate::entity::LivingEntity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/LivingEntity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setOwner",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EvokerFangs::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for EvokerFangs<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting EvokerFangs into crate::entity::Entity")
    }
}
/// Illager beast.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Ravager<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Ravager<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Ravager<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Ravager from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ravager")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Ravager object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Ravager<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Raider<'mc>> for Ravager<'mc> {
    fn into(self) -> crate::entity::Raider<'mc> {
        crate::entity::Raider::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Ravager into crate::entity::Raider")
    }
}
/// Represents a WitherSkeleton - variant of <a href="AbstractSkeleton.html" title="interface in org.bukkit.entity"><code>AbstractSkeleton</code></a>.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct WitherSkeleton<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for WitherSkeleton<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WitherSkeleton<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate WitherSkeleton from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/WitherSkeleton")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WitherSkeleton object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> WitherSkeleton<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::AbstractSkeleton<'mc>> for WitherSkeleton<'mc> {
    fn into(self) -> crate::entity::AbstractSkeleton<'mc> {
        crate::entity::AbstractSkeleton::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting WitherSkeleton into crate::entity::AbstractSkeleton")
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Firework<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Firework<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Firework<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Firework from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Firework")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Firework object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Firework<'mc> {
    pub fn firework_meta(
        &self,
    ) -> Result<crate::inventory::meta::FireworkMeta<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/meta/FireworkMeta;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireworkMeta", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::meta::FireworkMeta::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_firework_meta(
        &self,
        arg0: impl Into<crate::inventory::meta::FireworkMeta<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/meta/FireworkMeta;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireworkMeta",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_attached_to(
        &self,
        arg0: impl Into<crate::entity::LivingEntity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/LivingEntity;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAttachedTo",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn attached_to(
        &self,
    ) -> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/LivingEntity;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getAttachedTo", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::LivingEntity::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Set the ticks that this firework has been alive. If this value exceeds <a href="#getMaxLife()"><code>getMaxLife()</code></a>, the firework will detonate.
    pub fn set_life(&self, arg0: i32) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Z");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLife",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn life(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getLife", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the time in ticks this firework will exist until it is detonated.
    pub fn set_max_life(&self, arg0: i32) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Z");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaxLife",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn max_life(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxLife", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn detonate(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "detonate", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_detonated(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isDetonated", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn is_shot_at_angle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isShotAtAngle", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if the firework was shot at an angle (i.e. from a crossbow). A firework which was not shot at an angle will fly straight upwards.
    pub fn set_shot_at_angle(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setShotAtAngle",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn shooter(
        &self,
    ) -> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Firework::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.shooter()
    }
    pub fn set_shooter(
        &self,
        arg0: impl Into<crate::projectiles::ProjectileSource<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Firework::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.set_shooter(arg0)
    }
    pub fn does_bounce(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Firework::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.does_bounce()
    }
    pub fn set_bounce(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Firework::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.set_bounce(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for Firework<'mc> {
    fn into(self) -> crate::entity::Projectile<'mc> {
        crate::entity::Projectile::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Firework into crate::entity::Projectile")
    }
}
/// Represents a Chicken.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Chicken<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Chicken<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Chicken<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Chicken from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Chicken")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Chicken object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Chicken<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Chicken<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Chicken into crate::entity::Animals")
    }
}
pub enum SpawnCategory<'mc> {
    Monster { inner: SpawnCategoryStruct<'mc> },
    Animal { inner: SpawnCategoryStruct<'mc> },
    WaterAnimal { inner: SpawnCategoryStruct<'mc> },
    WaterAmbient { inner: SpawnCategoryStruct<'mc> },
    WaterUndergroundCreature { inner: SpawnCategoryStruct<'mc> },
    Ambient { inner: SpawnCategoryStruct<'mc> },
    Axolotl { inner: SpawnCategoryStruct<'mc> },
    Misc { inner: SpawnCategoryStruct<'mc> },
}
impl<'mc> std::fmt::Display for SpawnCategory<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SpawnCategory::Monster { .. } => f.write_str("MONSTER"),
            SpawnCategory::Animal { .. } => f.write_str("ANIMAL"),
            SpawnCategory::WaterAnimal { .. } => f.write_str("WATER_ANIMAL"),
            SpawnCategory::WaterAmbient { .. } => f.write_str("WATER_AMBIENT"),
            SpawnCategory::WaterUndergroundCreature { .. } => {
                f.write_str("WATER_UNDERGROUND_CREATURE")
            }
            SpawnCategory::Ambient { .. } => f.write_str("AMBIENT"),
            SpawnCategory::Axolotl { .. } => f.write_str("AXOLOTL"),
            SpawnCategory::Misc { .. } => f.write_str("MISC"),
        }
    }
}

impl<'mc> SpawnCategory<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/SpawnCategory");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/SpawnCategory;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "MONSTER" => Ok(SpawnCategory::Monster {
                inner: SpawnCategoryStruct::from_raw(env, obj)?,
            }),
            "ANIMAL" => Ok(SpawnCategory::Animal {
                inner: SpawnCategoryStruct::from_raw(env, obj)?,
            }),
            "WATER_ANIMAL" => Ok(SpawnCategory::WaterAnimal {
                inner: SpawnCategoryStruct::from_raw(env, obj)?,
            }),
            "WATER_AMBIENT" => Ok(SpawnCategory::WaterAmbient {
                inner: SpawnCategoryStruct::from_raw(env, obj)?,
            }),
            "WATER_UNDERGROUND_CREATURE" => Ok(SpawnCategory::WaterUndergroundCreature {
                inner: SpawnCategoryStruct::from_raw(env, obj)?,
            }),
            "AMBIENT" => Ok(SpawnCategory::Ambient {
                inner: SpawnCategoryStruct::from_raw(env, obj)?,
            }),
            "AXOLOTL" => Ok(SpawnCategory::Axolotl {
                inner: SpawnCategoryStruct::from_raw(env, obj)?,
            }),
            "MISC" => Ok(SpawnCategory::Misc {
                inner: SpawnCategoryStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct SpawnCategoryStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SpawnCategory<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Monster { inner } => inner.0.clone(),
            Self::Animal { inner } => inner.0.clone(),
            Self::WaterAnimal { inner } => inner.0.clone(),
            Self::WaterAmbient { inner } => inner.0.clone(),
            Self::WaterUndergroundCreature { inner } => inner.0.clone(),
            Self::Ambient { inner } => inner.0.clone(),
            Self::Axolotl { inner } => inner.0.clone(),
            Self::Misc { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Monster { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Animal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::WaterAnimal { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::WaterAmbient { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::WaterUndergroundCreature { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Ambient { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Axolotl { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Misc { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SpawnCategory<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SpawnCategory from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SpawnCategory")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SpawnCategory object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "MONSTER" => Ok(SpawnCategory::Monster {
                    inner: SpawnCategoryStruct::from_raw(env, obj)?,
                }),
                "ANIMAL" => Ok(SpawnCategory::Animal {
                    inner: SpawnCategoryStruct::from_raw(env, obj)?,
                }),
                "WATER_ANIMAL" => Ok(SpawnCategory::WaterAnimal {
                    inner: SpawnCategoryStruct::from_raw(env, obj)?,
                }),
                "WATER_AMBIENT" => Ok(SpawnCategory::WaterAmbient {
                    inner: SpawnCategoryStruct::from_raw(env, obj)?,
                }),
                "WATER_UNDERGROUND_CREATURE" => Ok(SpawnCategory::WaterUndergroundCreature {
                    inner: SpawnCategoryStruct::from_raw(env, obj)?,
                }),
                "AMBIENT" => Ok(SpawnCategory::Ambient {
                    inner: SpawnCategoryStruct::from_raw(env, obj)?,
                }),
                "AXOLOTL" => Ok(SpawnCategory::Axolotl {
                    inner: SpawnCategoryStruct::from_raw(env, obj)?,
                }),
                "MISC" => Ok(SpawnCategory::Misc {
                    inner: SpawnCategoryStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for SpawnCategoryStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SpawnCategoryStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate SpawnCategoryStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SpawnCategory")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SpawnCategoryStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SpawnCategoryStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents the style, or markings, that the horse has.
pub enum HorseStyle<'mc> {
    None { inner: HorseStyleStruct<'mc> },
    White { inner: HorseStyleStruct<'mc> },
    Whitefield { inner: HorseStyleStruct<'mc> },
    WhiteDots { inner: HorseStyleStruct<'mc> },
    BlackDots { inner: HorseStyleStruct<'mc> },
}
impl<'mc> std::fmt::Display for HorseStyle<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HorseStyle::None { .. } => f.write_str("NONE"),
            HorseStyle::White { .. } => f.write_str("WHITE"),
            HorseStyle::Whitefield { .. } => f.write_str("WHITEFIELD"),
            HorseStyle::WhiteDots { .. } => f.write_str("WHITE_DOTS"),
            HorseStyle::BlackDots { .. } => f.write_str("BLACK_DOTS"),
        }
    }
}

impl<'mc> HorseStyle<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<HorseStyle<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Horse$Style");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Horse$Style;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NONE" => Ok(HorseStyle::None {
                inner: HorseStyleStruct::from_raw(env, obj)?,
            }),
            "WHITE" => Ok(HorseStyle::White {
                inner: HorseStyleStruct::from_raw(env, obj)?,
            }),
            "WHITEFIELD" => Ok(HorseStyle::Whitefield {
                inner: HorseStyleStruct::from_raw(env, obj)?,
            }),
            "WHITE_DOTS" => Ok(HorseStyle::WhiteDots {
                inner: HorseStyleStruct::from_raw(env, obj)?,
            }),
            "BLACK_DOTS" => Ok(HorseStyle::BlackDots {
                inner: HorseStyleStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct HorseStyleStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for HorseStyle<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::None { inner } => inner.0.clone(),
            Self::White { inner } => inner.0.clone(),
            Self::Whitefield { inner } => inner.0.clone(),
            Self::WhiteDots { inner } => inner.0.clone(),
            Self::BlackDots { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::White { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Whitefield { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::WhiteDots { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlackDots { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for HorseStyle<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate HorseStyle from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse$Style")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a HorseStyle object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NONE" => Ok(HorseStyle::None {
                    inner: HorseStyleStruct::from_raw(env, obj)?,
                }),
                "WHITE" => Ok(HorseStyle::White {
                    inner: HorseStyleStruct::from_raw(env, obj)?,
                }),
                "WHITEFIELD" => Ok(HorseStyle::Whitefield {
                    inner: HorseStyleStruct::from_raw(env, obj)?,
                }),
                "WHITE_DOTS" => Ok(HorseStyle::WhiteDots {
                    inner: HorseStyleStruct::from_raw(env, obj)?,
                }),
                "BLACK_DOTS" => Ok(HorseStyle::BlackDots {
                    inner: HorseStyleStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for HorseStyleStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for HorseStyleStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate HorseStyleStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse$Style")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a HorseStyleStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> HorseStyleStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents an arrow.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct AbstractArrow<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for AbstractArrow<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for AbstractArrow<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate AbstractArrow from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AbstractArrow")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a AbstractArrow object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> AbstractArrow<'mc> {
    /// Sets the base amount of damage this arrow will do.
    pub fn set_damage(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDamage",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn damage(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getDamage", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }

    pub fn knockback_strength(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getKnockbackStrength",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the knockback strength for an arrow.
    pub fn set_knockback_strength(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setKnockbackStrength",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn pierce_level(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPierceLevel", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the number of times this arrow can pierce through an entity. Must be between 0 and 127 times.
    pub fn set_pierce_level(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPierceLevel",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_critical(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isCritical", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether or not this arrow should be critical.
    pub fn set_critical(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCritical",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_in_block(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isInBlock", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn attached_block(
        &self,
    ) -> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/block/Block;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getAttachedBlock",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::block::Block::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn pickup_status(
        &self,
    ) -> Result<crate::entity::AbstractArrowPickupStatus<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/AbstractArrow$PickupStatus;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPickupStatus", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::AbstractArrowPickupStatus::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_pickup_status(
        &self,
        arg0: impl Into<crate::entity::AbstractArrowPickupStatus<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/AbstractArrow$PickupStatus;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPickupStatus",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_shot_from_crossbow(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isShotFromCrossbow",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if this arrow was shot from a crossbow.
    pub fn set_shot_from_crossbow(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setShotFromCrossbow",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn shooter(
        &self,
    ) -> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = AbstractArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.shooter()
    }
    pub fn set_shooter(
        &self,
        arg0: impl Into<crate::projectiles::ProjectileSource<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AbstractArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.set_shooter(arg0)
    }
    pub fn does_bounce(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AbstractArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.does_bounce()
    }
    pub fn set_bounce(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AbstractArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.set_bounce(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for AbstractArrow<'mc> {
    fn into(self) -> crate::entity::Projectile<'mc> {
        crate::entity::Projectile::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting AbstractArrow into crate::entity::Projectile")
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Endermite<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Endermite<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Endermite<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Endermite from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Endermite")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Endermite object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Endermite<'mc> {
    #[deprecated]

    pub fn is_player_spawned(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isPlayerSpawned", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated = "this functionality no longer exists "]
    /// Sets whether this Endermite was spawned by a player. An Endermite spawned by a player will be attacked by nearby Enderman.
    pub fn set_player_spawned(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPlayerSpawned",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Endermite<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Endermite into crate::entity::Monster")
    }
}
/// Represents a Vindicator.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Vindicator<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Vindicator<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Vindicator<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Vindicator from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Vindicator")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Vindicator object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Vindicator<'mc> {
    pub fn is_johnny(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isJohnny", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets the Johnny state of a vindicator.
    pub fn set_johnny(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setJohnny",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Illager<'mc>> for Vindicator<'mc> {
    fn into(self) -> crate::entity::Illager<'mc> {
        crate::entity::Illager::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Vindicator into crate::entity::Illager")
    }
}
/// A Warden.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Warden<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Warden<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Warden<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Warden from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Warden")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Warden object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Warden<'mc> {
    pub fn get_anger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)I");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getAnger",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn increase_anger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;I)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "increaseAnger",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_anger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;I)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAnger",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn clear_anger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "clearAnger",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn entity_angry_at(
        &self,
    ) -> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/LivingEntity;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getEntityAngryAt",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::LivingEntity::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_disturbance_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDisturbanceLocation",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn anger_level(
        &self,
    ) -> Result<crate::entity::WardenAngerLevel<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Warden$AngerLevel;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getAngerLevel", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::WardenAngerLevel::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Warden<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Warden into crate::entity::Monster")
    }
}
/// Represents a trader Llama.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct TraderLlama<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for TraderLlama<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TraderLlama<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate TraderLlama from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TraderLlama")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TraderLlama object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> TraderLlama<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Llama<'mc>> for TraderLlama<'mc> {
    fn into(self) -> crate::entity::Llama<'mc> {
        crate::entity::Llama::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting TraderLlama into crate::entity::Llama")
    }
}
/// Represents the variant of a axolotl - ie its color.
pub enum AxolotlVariant<'mc> {
    Lucy { inner: AxolotlVariantStruct<'mc> },
    Wild { inner: AxolotlVariantStruct<'mc> },
    Gold { inner: AxolotlVariantStruct<'mc> },
    Cyan { inner: AxolotlVariantStruct<'mc> },
    Blue { inner: AxolotlVariantStruct<'mc> },
}
impl<'mc> std::fmt::Display for AxolotlVariant<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AxolotlVariant::Lucy { .. } => f.write_str("LUCY"),
            AxolotlVariant::Wild { .. } => f.write_str("WILD"),
            AxolotlVariant::Gold { .. } => f.write_str("GOLD"),
            AxolotlVariant::Cyan { .. } => f.write_str("CYAN"),
            AxolotlVariant::Blue { .. } => f.write_str("BLUE"),
        }
    }
}

impl<'mc> AxolotlVariant<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<AxolotlVariant<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Axolotl$Variant");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Axolotl$Variant;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "LUCY" => Ok(AxolotlVariant::Lucy {
                inner: AxolotlVariantStruct::from_raw(env, obj)?,
            }),
            "WILD" => Ok(AxolotlVariant::Wild {
                inner: AxolotlVariantStruct::from_raw(env, obj)?,
            }),
            "GOLD" => Ok(AxolotlVariant::Gold {
                inner: AxolotlVariantStruct::from_raw(env, obj)?,
            }),
            "CYAN" => Ok(AxolotlVariant::Cyan {
                inner: AxolotlVariantStruct::from_raw(env, obj)?,
            }),
            "BLUE" => Ok(AxolotlVariant::Blue {
                inner: AxolotlVariantStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct AxolotlVariantStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for AxolotlVariant<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Lucy { inner } => inner.0.clone(),
            Self::Wild { inner } => inner.0.clone(),
            Self::Gold { inner } => inner.0.clone(),
            Self::Cyan { inner } => inner.0.clone(),
            Self::Blue { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Lucy { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Wild { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Gold { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cyan { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Blue { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for AxolotlVariant<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate AxolotlVariant from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Axolotl$Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a AxolotlVariant object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "LUCY" => Ok(AxolotlVariant::Lucy {
                    inner: AxolotlVariantStruct::from_raw(env, obj)?,
                }),
                "WILD" => Ok(AxolotlVariant::Wild {
                    inner: AxolotlVariantStruct::from_raw(env, obj)?,
                }),
                "GOLD" => Ok(AxolotlVariant::Gold {
                    inner: AxolotlVariantStruct::from_raw(env, obj)?,
                }),
                "CYAN" => Ok(AxolotlVariant::Cyan {
                    inner: AxolotlVariantStruct::from_raw(env, obj)?,
                }),
                "BLUE" => Ok(AxolotlVariant::Blue {
                    inner: AxolotlVariantStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for AxolotlVariantStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for AxolotlVariantStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate AxolotlVariantStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Axolotl$Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a AxolotlVariantStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> AxolotlVariantStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a text display entity.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct TextDisplay<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for TextDisplay<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TextDisplay<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate TextDisplay from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TextDisplay")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TextDisplay object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> TextDisplay<'mc> {
    pub fn text(&self) -> Result<Option<String>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getText", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(
            self.jni_ref()
                .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
                .to_string_lossy()
                .to_string(),
        ))
    }

    pub fn line_width(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLineWidth", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn set_text(&self, arg0: impl Into<String>) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setText",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets the maximum line width before wrapping.
    pub fn set_line_width(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLineWidth",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn background_color(
        &self,
    ) -> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Color;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBackgroundColor",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn set_background_color(
        &self,
        arg0: impl Into<crate::Color<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Color;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBackgroundColor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn text_opacity(&self) -> Result<i8, Box<dyn std::error::Error>> {
        let sig = String::from("()B");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getTextOpacity", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.b()?)
    }
    /// Sets the text opacity.
    pub fn set_text_opacity(&self, arg0: i8) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(B)V");
        let val_1 = jni::objects::JValueGen::Byte(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTextOpacity",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_shadowed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isShadowed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if the text is shadowed.
    pub fn set_shadowed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setShadowed",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_see_through(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isSeeThrough", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if the text is see through.
    pub fn set_see_through(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSeeThrough",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_default_background(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isDefaultBackground",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if the text has its default background.
    pub fn set_default_background(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDefaultBackground",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn alignment(
        &self,
    ) -> Result<crate::entity::TextDisplayTextAlignment<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/TextDisplay$TextAlignment;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getAlignment", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::TextDisplayTextAlignment::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_alignment(
        &self,
        arg0: impl Into<crate::entity::TextDisplayTextAlignment<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/TextDisplay$TextAlignment;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAlignment",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn transformation(
        &self,
    ) -> Result<crate::util::Transformation<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.transformation()
    }
    pub fn set_transformation(
        &self,
        arg0: impl Into<crate::util::Transformation<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_transformation(arg0)
    }
    pub fn set_transformation_matrix(
        &self,
        arg0: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_transformation_matrix(arg0)
    }
    pub fn interpolation_duration(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.interpolation_duration()
    }
    pub fn set_interpolation_duration(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_interpolation_duration(arg0)
    }
    pub fn view_range(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.view_range()
    }
    pub fn set_view_range(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_view_range(arg0)
    }
    pub fn shadow_radius(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getShadowRadius", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    pub fn set_shadow_radius(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setShadowRadius",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn shadow_strength(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.shadow_strength()
    }
    pub fn set_shadow_strength(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_shadow_strength(arg0)
    }
    pub fn display_width(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.display_width()
    }
    pub fn set_display_width(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_display_width(arg0)
    }
    pub fn display_height(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.display_height()
    }
    pub fn set_display_height(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_display_height(arg0)
    }
    pub fn interpolation_delay(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.interpolation_delay()
    }
    pub fn set_interpolation_delay(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_interpolation_delay(arg0)
    }
    pub fn billboard(
        &self,
    ) -> Result<crate::entity::DisplayBillboard<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.billboard()
    }
    pub fn set_billboard(
        &self,
        arg0: impl Into<crate::entity::DisplayBillboard<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_billboard(arg0)
    }
    pub fn glow_color_override(
        &self,
    ) -> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.glow_color_override()
    }
    pub fn set_glow_color_override(
        &self,
        arg0: impl Into<crate::Color<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = TextDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_glow_color_override(arg0)
    }
    pub fn brightness(
        &self,
    ) -> Result<Option<crate::entity::DisplayBrightness<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Display$Brightness;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBrightness", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::DisplayBrightness::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    pub fn set_brightness(
        &self,
        arg0: impl Into<crate::entity::DisplayBrightness<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Display$Brightness;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBrightness",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Display<'mc>> for TextDisplay<'mc> {
    fn into(self) -> crate::entity::Display<'mc> {
        crate::entity::Display::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting TextDisplay into crate::entity::Display")
    }
}
pub enum ProfessionProfession<'mc> {
    None {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Armorer {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Butcher {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Cartographer {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Cleric {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Farmer {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Fisherman {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Fletcher {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Leatherworker {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Librarian {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Mason {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Nitwit {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Shepherd {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Toolsmith {
        inner: ProfessionProfessionStruct<'mc>,
    },
    Weaponsmith {
        inner: ProfessionProfessionStruct<'mc>,
    },
}
impl<'mc> std::fmt::Display for ProfessionProfession<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ProfessionProfession::None { .. } => f.write_str("NONE"),
            ProfessionProfession::Armorer { .. } => f.write_str("ARMORER"),
            ProfessionProfession::Butcher { .. } => f.write_str("BUTCHER"),
            ProfessionProfession::Cartographer { .. } => f.write_str("CARTOGRAPHER"),
            ProfessionProfession::Cleric { .. } => f.write_str("CLERIC"),
            ProfessionProfession::Farmer { .. } => f.write_str("FARMER"),
            ProfessionProfession::Fisherman { .. } => f.write_str("FISHERMAN"),
            ProfessionProfession::Fletcher { .. } => f.write_str("FLETCHER"),
            ProfessionProfession::Leatherworker { .. } => f.write_str("LEATHERWORKER"),
            ProfessionProfession::Librarian { .. } => f.write_str("LIBRARIAN"),
            ProfessionProfession::Mason { .. } => f.write_str("MASON"),
            ProfessionProfession::Nitwit { .. } => f.write_str("NITWIT"),
            ProfessionProfession::Shepherd { .. } => f.write_str("SHEPHERD"),
            ProfessionProfession::Toolsmith { .. } => f.write_str("TOOLSMITH"),
            ProfessionProfession::Weaponsmith { .. } => f.write_str("WEAPONSMITH"),
        }
    }
}

impl<'mc> ProfessionProfession<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<ProfessionProfession<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Profession$Profession");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Profession$Profession;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NONE" => Ok(ProfessionProfession::None {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "ARMORER" => Ok(ProfessionProfession::Armorer {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "BUTCHER" => Ok(ProfessionProfession::Butcher {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "CARTOGRAPHER" => Ok(ProfessionProfession::Cartographer {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "CLERIC" => Ok(ProfessionProfession::Cleric {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "FARMER" => Ok(ProfessionProfession::Farmer {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "FISHERMAN" => Ok(ProfessionProfession::Fisherman {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "FLETCHER" => Ok(ProfessionProfession::Fletcher {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "LEATHERWORKER" => Ok(ProfessionProfession::Leatherworker {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "LIBRARIAN" => Ok(ProfessionProfession::Librarian {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "MASON" => Ok(ProfessionProfession::Mason {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "NITWIT" => Ok(ProfessionProfession::Nitwit {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "SHEPHERD" => Ok(ProfessionProfession::Shepherd {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "TOOLSMITH" => Ok(ProfessionProfession::Toolsmith {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),
            "WEAPONSMITH" => Ok(ProfessionProfession::Weaponsmith {
                inner: ProfessionProfessionStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct ProfessionProfessionStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ProfessionProfession<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::None { inner } => inner.0.clone(),
            Self::Armorer { inner } => inner.0.clone(),
            Self::Butcher { inner } => inner.0.clone(),
            Self::Cartographer { inner } => inner.0.clone(),
            Self::Cleric { inner } => inner.0.clone(),
            Self::Farmer { inner } => inner.0.clone(),
            Self::Fisherman { inner } => inner.0.clone(),
            Self::Fletcher { inner } => inner.0.clone(),
            Self::Leatherworker { inner } => inner.0.clone(),
            Self::Librarian { inner } => inner.0.clone(),
            Self::Mason { inner } => inner.0.clone(),
            Self::Nitwit { inner } => inner.0.clone(),
            Self::Shepherd { inner } => inner.0.clone(),
            Self::Toolsmith { inner } => inner.0.clone(),
            Self::Weaponsmith { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Armorer { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Butcher { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cartographer { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Cleric { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Farmer { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Fisherman { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Fletcher { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Leatherworker { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Librarian { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Mason { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Nitwit { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Shepherd { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Toolsmith { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Weaponsmith { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ProfessionProfession<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ProfessionProfession from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Profession$Profession")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ProfessionProfession object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NONE" => Ok(ProfessionProfession::None {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "ARMORER" => Ok(ProfessionProfession::Armorer {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "BUTCHER" => Ok(ProfessionProfession::Butcher {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "CARTOGRAPHER" => Ok(ProfessionProfession::Cartographer {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "CLERIC" => Ok(ProfessionProfession::Cleric {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "FARMER" => Ok(ProfessionProfession::Farmer {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "FISHERMAN" => Ok(ProfessionProfession::Fisherman {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "FLETCHER" => Ok(ProfessionProfession::Fletcher {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "LEATHERWORKER" => Ok(ProfessionProfession::Leatherworker {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "LIBRARIAN" => Ok(ProfessionProfession::Librarian {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "MASON" => Ok(ProfessionProfession::Mason {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "NITWIT" => Ok(ProfessionProfession::Nitwit {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "SHEPHERD" => Ok(ProfessionProfession::Shepherd {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "TOOLSMITH" => Ok(ProfessionProfession::Toolsmith {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                "WEAPONSMITH" => Ok(ProfessionProfession::Weaponsmith {
                    inner: ProfessionProfessionStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for ProfessionProfessionStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ProfessionProfessionStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate ProfessionProfessionStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Profession$Profession")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ProfessionProfessionStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ProfessionProfessionStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a type of "Illager".
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Illager<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Illager<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Illager<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Illager from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Illager")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Illager object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Illager<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Raider<'mc>> for Illager<'mc> {
    fn into(self) -> crate::entity::Raider<'mc> {
        crate::entity::Raider::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Illager into crate::entity::Raider")
    }
}
/// Represents a fish entity.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Fish<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Fish<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Fish<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Fish from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Fish")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Fish object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Fish<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::WaterMob<'mc>> for Fish<'mc> {
    fn into(self) -> crate::entity::WaterMob<'mc> {
        crate::entity::WaterMob::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Fish into crate::entity::WaterMob")
    }
}
/// Represents a Wolf
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Wolf<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Wolf<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Wolf<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Wolf from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Wolf")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Wolf object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Wolf<'mc> {
    pub fn is_angry(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isAngry", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets the anger of this wolf.
    /// <p>An angry wolf can not be fed or tamed.</p>
    pub fn set_angry(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAngry",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn collar_color(&self) -> Result<crate::DyeColor<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/DyeColor;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getCollarColor", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::DyeColor::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_collar_color(
        &self,
        arg0: impl Into<crate::DyeColor<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/DyeColor;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCollarColor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_wet(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isWet", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn tail_angle(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getTailAngle", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }

    pub fn is_interested(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isInterested", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set wolf to be interested
    pub fn set_interested(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setInterested",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn owner(
        &self,
    ) -> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Wolf::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.owner()
    }
    pub fn set_owner(
        &self,
        arg0: impl Into<crate::entity::AnimalTamer<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Wolf::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.set_owner(arg0)
    }
    pub fn is_tamed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Wolf::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.is_tamed()
    }
    pub fn set_tamed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Wolf::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.set_tamed(arg0)
    }
    pub fn is_sitting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Wolf::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Sittable = temp_clone.into();
        real.is_sitting()
    }
    pub fn set_sitting(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Wolf::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Sittable = temp_clone.into();
        real.set_sitting(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Tameable<'mc>> for Wolf<'mc> {
    fn into(self) -> crate::entity::Tameable<'mc> {
        crate::entity::Tameable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Wolf into crate::entity::Tameable")
    }
}
impl<'mc> Into<crate::entity::Sittable<'mc>> for Wolf<'mc> {
    fn into(self) -> crate::entity::Sittable<'mc> {
        crate::entity::Sittable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Wolf into crate::entity::Sittable")
    }
}
/// Represents the various different cat types there are.
pub enum OcelotType<'mc> {
    WildOcelot { inner: OcelotTypeStruct<'mc> },
    BlackCat { inner: OcelotTypeStruct<'mc> },
    RedCat { inner: OcelotTypeStruct<'mc> },
    SiameseCat { inner: OcelotTypeStruct<'mc> },
}
impl<'mc> std::fmt::Display for OcelotType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            OcelotType::WildOcelot { .. } => f.write_str("WILD_OCELOT"),
            OcelotType::BlackCat { .. } => f.write_str("BLACK_CAT"),
            OcelotType::RedCat { .. } => f.write_str("RED_CAT"),
            OcelotType::SiameseCat { .. } => f.write_str("SIAMESE_CAT"),
        }
    }
}

impl<'mc> OcelotType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<OcelotType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Ocelot$Type");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Ocelot$Type;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "WILD_OCELOT" => Ok(OcelotType::WildOcelot {
                inner: OcelotTypeStruct::from_raw(env, obj)?,
            }),
            "BLACK_CAT" => Ok(OcelotType::BlackCat {
                inner: OcelotTypeStruct::from_raw(env, obj)?,
            }),
            "RED_CAT" => Ok(OcelotType::RedCat {
                inner: OcelotTypeStruct::from_raw(env, obj)?,
            }),
            "SIAMESE_CAT" => Ok(OcelotType::SiameseCat {
                inner: OcelotTypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct OcelotTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for OcelotType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::WildOcelot { inner } => inner.0.clone(),
            Self::BlackCat { inner } => inner.0.clone(),
            Self::RedCat { inner } => inner.0.clone(),
            Self::SiameseCat { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::WildOcelot { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlackCat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::RedCat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::SiameseCat { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for OcelotType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate OcelotType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ocelot$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a OcelotType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "WILD_OCELOT" => Ok(OcelotType::WildOcelot {
                    inner: OcelotTypeStruct::from_raw(env, obj)?,
                }),
                "BLACK_CAT" => Ok(OcelotType::BlackCat {
                    inner: OcelotTypeStruct::from_raw(env, obj)?,
                }),
                "RED_CAT" => Ok(OcelotType::RedCat {
                    inner: OcelotTypeStruct::from_raw(env, obj)?,
                }),
                "SIAMESE_CAT" => Ok(OcelotType::SiameseCat {
                    inner: OcelotTypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for OcelotTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for OcelotTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate OcelotTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ocelot$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a OcelotTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> OcelotTypeStruct<'mc> {
    pub fn id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getId", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated = "Magic value "]
    /// Gets a cat type by its ID.
    pub fn get_type(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: i32,
    ) -> Result<Option<crate::entity::OcelotType<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Lorg/bukkit/entity/Ocelot$Type;");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let cls = jni.find_class("org/bukkit/entity/Ocelot$Type");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getType",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::entity::OcelotType::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a Wither boss
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Wither<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Wither<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Wither<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Wither from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Wither")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Wither object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Wither<'mc> {
    pub fn invulnerability_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getInvulnerabilityTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the wither's current invulnerability ticks. When invulnerability ticks reach 0, the wither will trigger an explosion.
    pub fn set_invulnerability_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setInvulnerabilityTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn get_target(
        &self,
        arg0: impl Into<crate::entity::WitherHead<'mc>>,
    ) -> Result<crate::entity::LivingEntity<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Wither$Head;)Lorg/bukkit/entity/LivingEntity;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTarget",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::LivingEntity::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_target_with_witherhead(
        &self,
        arg0: impl Into<crate::entity::WitherHead<'mc>>,
        arg1: std::option::Option<impl Into<crate::entity::LivingEntity<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Wither$Head;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/entity/LivingEntity;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "setTarget", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn boss_bar(
        &self,
    ) -> Result<Option<crate::boss::BossBar<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Wither::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Boss = temp_clone.into();
        real.boss_bar()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Wither<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Wither into crate::entity::Monster")
    }
}
impl<'mc> Into<crate::entity::Boss<'mc>> for Wither<'mc> {
    fn into(self) -> crate::entity::Boss<'mc> {
        crate::entity::Boss::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Wither into crate::entity::Boss")
    }
}
/// Represents the various different fox types there are.
pub enum FoxType<'mc> {
    Red { inner: FoxTypeStruct<'mc> },
    Snow { inner: FoxTypeStruct<'mc> },
}
impl<'mc> std::fmt::Display for FoxType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FoxType::Red { .. } => f.write_str("RED"),
            FoxType::Snow { .. } => f.write_str("SNOW"),
        }
    }
}

impl<'mc> FoxType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<FoxType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Fox$Type");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Fox$Type;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "RED" => Ok(FoxType::Red {
                inner: FoxTypeStruct::from_raw(env, obj)?,
            }),
            "SNOW" => Ok(FoxType::Snow {
                inner: FoxTypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct FoxTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for FoxType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Red { inner } => inner.0.clone(),
            Self::Snow { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Red { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Snow { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FoxType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate FoxType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Fox$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FoxType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "RED" => Ok(FoxType::Red {
                    inner: FoxTypeStruct::from_raw(env, obj)?,
                }),
                "SNOW" => Ok(FoxType::Snow {
                    inner: FoxTypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for FoxTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FoxTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate FoxTypeStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Fox$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FoxTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> FoxTypeStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a Bee.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Bee<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Bee<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Bee<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Bee from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Bee")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Bee object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Bee<'mc> {
    pub fn anger(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getAnger", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the bee's new anger level.
    pub fn set_anger(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAnger",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn flower(&self) -> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getFlower", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn set_flower(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFlower",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn cannot_enter_hive_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCannotEnterHiveTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn hive(&self) -> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getHive", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn set_hive(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setHive",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn has_nectar(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hasNectar", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set if the bee has nectar.
    pub fn set_has_nectar(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setHasNectar",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn has_stung(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hasStung", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set if the bee has stung.
    pub fn set_has_stung(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setHasStung",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Set the amount of ticks the bee cannot enter a hive for.
    pub fn set_cannot_enter_hive_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCannotEnterHiveTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Bee::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Bee::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Bee::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Bee<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Bee into crate::entity::Animals")
    }
}
/// Represents an <a title="interface in org.bukkit.entity" href="Entity.html"><code>Entity</code></a> that has health and can take damage.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Damageable<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Damageable<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Damageable<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Damageable from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Damageable")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Damageable object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Damageable<'mc> {
    pub fn damage_with_double(
        &self,
        arg0: f64,
        arg1: std::option::Option<impl Into<crate::entity::Entity<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "D";
        let val_1 = jni::objects::JValueGen::Double(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/entity/Entity;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "damage", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn health(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getHealth", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Sets the entity's health from 0 to <a href="#getMaxHealth()"><code>getMaxHealth()</code></a>, where 0 is dead.
    pub fn set_health(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setHealth",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn absorption_amount(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getAbsorptionAmount",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Sets the entity's absorption amount.
    pub fn set_absorption_amount(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAbsorptionAmount",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn max_health(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxHealth", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    #[deprecated = "use <a href='../attribute/Attribute.html#GENERIC_MAX_HEALTH'><code>Attribute.GENERIC_MAX_HEALTH</code></a>. "]
    /// Sets the maximum health this entity can have.<p>If the health of the entity is above the value provided it will be set to that value.</p> <p>Note: An entity with a health bar (<a href="Player.html" title="interface in org.bukkit.entity"><code>Player</code></a>, <a href="EnderDragon.html" title="interface in org.bukkit.entity"><code>EnderDragon</code></a>, <a title="interface in org.bukkit.entity" href="Wither.html"><code>Wither</code></a>, etc...} will have their bar scaled accordingly.</p>
    pub fn set_max_health(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaxHealth",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn reset_max_health(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "resetMaxHealth", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Damageable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Damageable<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Damageable into crate::entity::Entity")
    }
}
/// Represents an entity that can age and breed.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Breedable<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Breedable<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Breedable<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Breedable from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Breedable")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Breedable object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Breedable<'mc> {
    #[deprecated]
    /// Lock the age of the animal, setting this will prevent the animal from maturing or getting ready for mating.
    pub fn set_age_lock(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAgeLock",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn age_lock(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getAgeLock", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]

    pub fn can_breed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "canBreed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]
    /// Set breedability of the animal, if the animal is a baby and set to breed it will instantly grow up.
    pub fn set_breed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBreed",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn age(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Breedable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.age()
    }
    pub fn set_age(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Breedable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_age(arg0)
    }
    pub fn set_baby(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Breedable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_baby()
    }
    pub fn set_adult(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Breedable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_adult()
    }
    pub fn is_adult(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Breedable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.is_adult()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Ageable<'mc>> for Breedable<'mc> {
    fn into(self) -> crate::entity::Ageable<'mc> {
        crate::entity::Ageable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Breedable into crate::entity::Ageable")
    }
}

#[repr(C)]
pub struct PlayerSpigot<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for PlayerSpigot<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for PlayerSpigot<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate PlayerSpigot from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Player$Spigot")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PlayerSpigot object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> PlayerSpigot<'mc> {
    pub fn new(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::entity::PlayerSpigot<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let cls = jni.find_class("org/bukkit/entity/Player$Spigot");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.new_object(cls, sig.as_str(), vec![]);
        let res = jni.translate_error_no_gen(res)?;
        crate::entity::PlayerSpigot::from_raw(&jni, res)
    }

    pub fn send_message_with_base_components(
        &self,
        arg0: Vec<blackboxmc_bungee::bungee::api::chat::BaseComponent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "[Lnet/md_5/bungee/api/chat/BaseComponent;";
        let arr = self.jni_ref().new_object_array(
            arg0.len() as i32,
            "net/md_5/bungee/api/chat/BaseComponent",
            jni::objects::JObject::null(),
        );
        let arr = self.jni_ref().translate_error_no_gen(arr)?;
        for i in 0..arg0.len() {
            let val_1 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(arg0.get(i).unwrap().jni_object().clone())
            });
            self.jni_ref()
                .set_object_array_element(&arr, i as i32, val_1.l()?)?;
        }
        let val_1 = jni::objects::JValueGen::Object(arr);
        args.push(val_1.l()?.into());
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "sendMessage", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn send_message_with_chat_message_type(
        &self,
        arg0: impl Into<blackboxmc_bungee::bungee::api::ChatMessageType<'mc>>,
        arg1: std::option::Option<impl Into<blackboxmc_java::util::JavaUUID<'mc>>>,
        arg2: std::option::Option<
            impl Into<blackboxmc_bungee::bungee::api::chat::BaseComponent<'mc>>,
        >,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lnet/md_5/bungee/api/ChatMessageType;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Ljava/util/UUID;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        if let Some(a) = arg2 {
            sig += "Lnet/md_5/bungee/api/chat/BaseComponent;";
            let val_3 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_3);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "sendMessage", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn raw_address(&self) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/net/InetSocketAddress;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getRawAddress", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }

    pub fn respawn(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "respawn", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn hidden_players(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getHiddenPlayers",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::EntitySpigot<'mc>> for PlayerSpigot<'mc> {
    fn into(self) -> crate::entity::EntitySpigot<'mc> {
        crate::entity::EntitySpigot::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting PlayerSpigot into crate::entity::EntitySpigot")
    }
}
/// Represents a Husk - variant of <a href="Zombie.html" title="interface in org.bukkit.entity"><code>Zombie</code></a>.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Husk<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Husk<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Husk<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Husk from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Husk")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Husk object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Husk<'mc> {
    pub fn is_converting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isConverting", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn conversion_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getConversionTime",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the amount of ticks until this entity will be converted to a Zombie as a result of being underwater. When this reaches 0, the entity will be converted. A value of less than 0 will stop the current conversion process without converting the current entity.
    pub fn set_conversion_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setConversionTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_baby(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Husk::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.set_baby(arg0)
    }

    pub fn is_baby(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Husk::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.is_baby()
    }

    pub fn is_villager(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Husk::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.is_villager()
    }
    pub fn set_villager_profession(
        &self,
        arg0: impl Into<crate::entity::VillagerProfession<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Husk::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.set_villager_profession(arg0)
    }
    pub fn set_villager(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Husk::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.set_villager(arg0)
    }
    pub fn villager_profession(
        &self,
    ) -> Result<crate::entity::VillagerProfession<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Husk::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.villager_profession()
    }
    pub fn can_break_doors(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "canBreakDoors", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn set_can_break_doors(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCanBreakDoors",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Zombie<'mc>> for Husk<'mc> {
    fn into(self) -> crate::entity::Zombie<'mc> {
        crate::entity::Zombie::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Husk into crate::entity::Zombie")
    }
}
/// Represents an area effect cloud which will imbue a potion effect onto entities which enter it.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct AreaEffectCloud<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for AreaEffectCloud<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for AreaEffectCloud<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate AreaEffectCloud from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AreaEffectCloud")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a AreaEffectCloud object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> AreaEffectCloud<'mc> {
    pub fn set_color(
        &self,
        arg0: impl Into<crate::Color<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Color;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setColor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn source(
        &self,
    ) -> Result<crate::projectiles::ProjectileSource<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/projectiles/ProjectileSource;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getSource", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn color(&self) -> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Color;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getColor", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn set_source(
        &self,
        arg0: impl Into<crate::projectiles::ProjectileSource<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSource",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn has_custom_effects(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasCustomEffects",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn custom_effects(
        &self,
    ) -> Result<Vec<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCustomEffects",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::potion::PotionEffect::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }

    pub fn add_custom_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffect<'mc>>,
        arg1: bool,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionEffect;Z)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Bool(arg1.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "addCustomEffect",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn remove_custom_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removeCustomEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn has_custom_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasCustomEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn clear_custom_effects(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "clearCustomEffects",
            sig.as_str(),
            vec![],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_base_potion_data(
        &self,
        arg0: impl Into<crate::potion::PotionData<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionData;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBasePotionData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn base_potion_data(
        &self,
    ) -> Result<crate::potion::PotionData<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/potion/PotionData;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBasePotionData",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::potion::PotionData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn reapplication_delay(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getReapplicationDelay",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn duration(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDuration", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the duration which this cloud will exist for (in ticks).
    /// Sets the amount that the duration of this cloud will decrease by when it applies an effect to an entity.
    pub fn set_duration(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDuration",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn wait_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getWaitTime", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the time which an entity has to be exposed to the cloud before the effect is applied.
    pub fn set_wait_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWaitTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets the time that an entity will be immune from subsequent exposure.
    pub fn set_reapplication_delay(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setReapplicationDelay",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn duration_on_use(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDurationOnUse",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the amount that the duration of this cloud will decrease by when it applies an effect to an entity.
    pub fn set_duration_on_use(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDurationOnUse",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn radius(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getRadius", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the initial radius of the cloud.
    /// Sets the amount that the radius of this cloud will decrease by when it applies an effect to an entity.
    /// Gets the amount that the radius of this cloud will decrease by each tick.
    pub fn set_radius(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRadius",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn radius_on_use(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getRadiusOnUse", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the amount that the radius of this cloud will decrease by when it applies an effect to an entity.
    pub fn set_radius_on_use(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRadiusOnUse",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn radius_per_tick(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getRadiusPerTick",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Gets the amount that the radius of this cloud will decrease by each tick.
    pub fn set_radius_per_tick(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRadiusPerTick",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn particle(&self) -> Result<crate::Particle<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Particle;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getParticle", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Particle::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_particle_with_particle(
        &self,
        arg0: impl Into<crate::Particle<'mc>>,
        arg1: std::option::Option<jni::objects::JObject<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Particle;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Ljava/lang/Object;";
            let val_2 = jni::objects::JValueGen::Object(a);
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "setParticle", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AreaEffectCloud::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for AreaEffectCloud<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting AreaEffectCloud into crate::entity::Entity")
    }
}
/// Represents a Slime.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Slime<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Slime<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Slime<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Slime from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Slime")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Slime object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Slime<'mc> {
    pub fn set_size(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSize",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn size(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getSize", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_aware(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Slime::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Mob = temp_clone.into();
        real.set_aware(arg0)
    }
    pub fn is_aware(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Slime::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Mob = temp_clone.into();
        real.is_aware()
    }
    pub fn ambient_sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Slime::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Mob = temp_clone.into();
        real.ambient_sound()
    }
    pub fn target(
        &self,
    ) -> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Slime::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Mob = temp_clone.into();
        real.target()
    }
    pub fn set_target(
        &self,
        arg0: impl Into<crate::entity::LivingEntity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Slime::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Mob = temp_clone.into();
        real.set_target(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Mob<'mc>> for Slime<'mc> {
    fn into(self) -> crate::entity::Mob<'mc> {
        crate::entity::Mob::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Slime into crate::entity::Mob")
    }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for Slime<'mc> {
    fn into(self) -> crate::entity::Enemy<'mc> {
        crate::entity::Enemy::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Slime into crate::entity::Enemy")
    }
}
/// Represents an ambient mob
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Ambient<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Ambient<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Ambient<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Ambient from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ambient")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Ambient object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Ambient<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Mob<'mc>> for Ambient<'mc> {
    fn into(self) -> crate::entity::Mob<'mc> {
        crate::entity::Mob::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Ambient into crate::entity::Mob")
    }
}
pub enum ItemDisplayTransform<'mc> {
    None {
        inner: ItemDisplayTransformStruct<'mc>,
    },
    ThirdpersonLefthand {
        inner: ItemDisplayTransformStruct<'mc>,
    },
    ThirdpersonRighthand {
        inner: ItemDisplayTransformStruct<'mc>,
    },
    FirstpersonLefthand {
        inner: ItemDisplayTransformStruct<'mc>,
    },
    FirstpersonRighthand {
        inner: ItemDisplayTransformStruct<'mc>,
    },
    Head {
        inner: ItemDisplayTransformStruct<'mc>,
    },
    Gui {
        inner: ItemDisplayTransformStruct<'mc>,
    },
    Ground {
        inner: ItemDisplayTransformStruct<'mc>,
    },
    Fixed {
        inner: ItemDisplayTransformStruct<'mc>,
    },
}
impl<'mc> std::fmt::Display for ItemDisplayTransform<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ItemDisplayTransform::None { .. } => f.write_str("NONE"),
            ItemDisplayTransform::ThirdpersonLefthand { .. } => f.write_str("THIRDPERSON_LEFTHAND"),
            ItemDisplayTransform::ThirdpersonRighthand { .. } => {
                f.write_str("THIRDPERSON_RIGHTHAND")
            }
            ItemDisplayTransform::FirstpersonLefthand { .. } => f.write_str("FIRSTPERSON_LEFTHAND"),
            ItemDisplayTransform::FirstpersonRighthand { .. } => {
                f.write_str("FIRSTPERSON_RIGHTHAND")
            }
            ItemDisplayTransform::Head { .. } => f.write_str("HEAD"),
            ItemDisplayTransform::Gui { .. } => f.write_str("GUI"),
            ItemDisplayTransform::Ground { .. } => f.write_str("GROUND"),
            ItemDisplayTransform::Fixed { .. } => f.write_str("FIXED"),
        }
    }
}

impl<'mc> ItemDisplayTransform<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<ItemDisplayTransform<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/ItemDisplayTransform");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/ItemDisplayTransform;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NONE" => Ok(ItemDisplayTransform::None {
                inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "THIRDPERSON_LEFTHAND" => Ok(ItemDisplayTransform::ThirdpersonLefthand {
                inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "THIRDPERSON_RIGHTHAND" => Ok(ItemDisplayTransform::ThirdpersonRighthand {
                inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "FIRSTPERSON_LEFTHAND" => Ok(ItemDisplayTransform::FirstpersonLefthand {
                inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "FIRSTPERSON_RIGHTHAND" => Ok(ItemDisplayTransform::FirstpersonRighthand {
                inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "HEAD" => Ok(ItemDisplayTransform::Head {
                inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "GUI" => Ok(ItemDisplayTransform::Gui {
                inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "GROUND" => Ok(ItemDisplayTransform::Ground {
                inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "FIXED" => Ok(ItemDisplayTransform::Fixed {
                inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct ItemDisplayTransformStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ItemDisplayTransform<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::None { inner } => inner.0.clone(),
            Self::ThirdpersonLefthand { inner } => inner.0.clone(),
            Self::ThirdpersonRighthand { inner } => inner.0.clone(),
            Self::FirstpersonLefthand { inner } => inner.0.clone(),
            Self::FirstpersonRighthand { inner } => inner.0.clone(),
            Self::Head { inner } => inner.0.clone(),
            Self::Gui { inner } => inner.0.clone(),
            Self::Ground { inner } => inner.0.clone(),
            Self::Fixed { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::ThirdpersonLefthand { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ThirdpersonRighthand { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::FirstpersonLefthand { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::FirstpersonRighthand { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Head { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Gui { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Ground { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Fixed { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ItemDisplayTransform<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ItemDisplayTransform from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ItemDisplayTransform")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ItemDisplayTransform object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NONE" => Ok(ItemDisplayTransform::None {
                    inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                "THIRDPERSON_LEFTHAND" => Ok(ItemDisplayTransform::ThirdpersonLefthand {
                    inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                "THIRDPERSON_RIGHTHAND" => Ok(ItemDisplayTransform::ThirdpersonRighthand {
                    inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                "FIRSTPERSON_LEFTHAND" => Ok(ItemDisplayTransform::FirstpersonLefthand {
                    inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                "FIRSTPERSON_RIGHTHAND" => Ok(ItemDisplayTransform::FirstpersonRighthand {
                    inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                "HEAD" => Ok(ItemDisplayTransform::Head {
                    inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                "GUI" => Ok(ItemDisplayTransform::Gui {
                    inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                "GROUND" => Ok(ItemDisplayTransform::Ground {
                    inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                "FIXED" => Ok(ItemDisplayTransform::Fixed {
                    inner: ItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for ItemDisplayTransformStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ItemDisplayTransformStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate ItemDisplayTransformStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ItemDisplayTransform")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ItemDisplayTransformStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ItemDisplayTransformStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a Llama.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Llama<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Llama<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Llama<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Llama from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Llama")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Llama object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Llama<'mc> {
    pub fn set_color(
        &self,
        arg0: impl Into<crate::entity::LlamaColor<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Llama$Color;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setColor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn inventory(
        &self,
    ) -> Result<crate::inventory::AbstractHorseInventory<'mc>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Lorg/bukkit/inventory/AbstractHorseInventory;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getInventory", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::AbstractHorseInventory::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn color(
        &self,
    ) -> Result<Option<crate::entity::LlamaColor<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Llama$Color;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getColor", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::LlamaColor::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn strength(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getStrength", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the llama's strength. A higher strength llama will have more inventory slots and be more threatening to entities. Inventory slots are equal to strength * 3.
    pub fn set_strength(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setStrength",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_carrying_chest(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Llama::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::ChestedHorse = temp_clone.into();
        real.is_carrying_chest()
    }
    pub fn set_carrying_chest(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Llama::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::ChestedHorse = temp_clone.into();
        real.set_carrying_chest(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::ChestedHorse<'mc>> for Llama<'mc> {
    fn into(self) -> crate::entity::ChestedHorse<'mc> {
        crate::entity::ChestedHorse::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Llama into crate::entity::ChestedHorse")
    }
}

pub enum WardenAngerLevel<'mc> {
    Calm { inner: WardenAngerLevelStruct<'mc> },
    Agitated { inner: WardenAngerLevelStruct<'mc> },
    Angry { inner: WardenAngerLevelStruct<'mc> },
}
impl<'mc> std::fmt::Display for WardenAngerLevel<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            WardenAngerLevel::Calm { .. } => f.write_str("CALM"),
            WardenAngerLevel::Agitated { .. } => f.write_str("AGITATED"),
            WardenAngerLevel::Angry { .. } => f.write_str("ANGRY"),
        }
    }
}

impl<'mc> WardenAngerLevel<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<WardenAngerLevel<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Warden$AngerLevel");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Warden$AngerLevel;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "CALM" => Ok(WardenAngerLevel::Calm {
                inner: WardenAngerLevelStruct::from_raw(env, obj)?,
            }),
            "AGITATED" => Ok(WardenAngerLevel::Agitated {
                inner: WardenAngerLevelStruct::from_raw(env, obj)?,
            }),
            "ANGRY" => Ok(WardenAngerLevel::Angry {
                inner: WardenAngerLevelStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct WardenAngerLevelStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for WardenAngerLevel<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Calm { inner } => inner.0.clone(),
            Self::Agitated { inner } => inner.0.clone(),
            Self::Angry { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Calm { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Agitated { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Angry { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WardenAngerLevel<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate WardenAngerLevel from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Warden$AngerLevel")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WardenAngerLevel object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "CALM" => Ok(WardenAngerLevel::Calm {
                    inner: WardenAngerLevelStruct::from_raw(env, obj)?,
                }),
                "AGITATED" => Ok(WardenAngerLevel::Agitated {
                    inner: WardenAngerLevelStruct::from_raw(env, obj)?,
                }),
                "ANGRY" => Ok(WardenAngerLevel::Angry {
                    inner: WardenAngerLevelStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for WardenAngerLevelStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WardenAngerLevelStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate WardenAngerLevelStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Warden$AngerLevel")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WardenAngerLevelStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> WardenAngerLevelStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a Pig Zombie.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct PigZombie<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for PigZombie<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for PigZombie<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate PigZombie from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/PigZombie")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PigZombie object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> PigZombie<'mc> {
    pub fn anger(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getAnger", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the pig zombie's current anger level.
    pub fn set_anger(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAnger",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_converting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isConverting", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn conversion_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getConversionTime",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// <b>Not applicable to this entity</b>
    pub fn set_conversion_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setConversionTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_angry(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isAngry", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Shorthand; sets to either 0 or the default level.
    pub fn set_angry(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAngry",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_baby(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = PigZombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.set_baby(arg0)
    }

    pub fn is_baby(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = PigZombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.is_baby()
    }

    pub fn is_villager(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = PigZombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.is_villager()
    }
    pub fn set_villager_profession(
        &self,
        arg0: impl Into<crate::entity::VillagerProfession<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = PigZombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.set_villager_profession(arg0)
    }
    pub fn set_villager(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = PigZombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.set_villager(arg0)
    }
    pub fn villager_profession(
        &self,
    ) -> Result<crate::entity::VillagerProfession<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = PigZombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.villager_profession()
    }
    pub fn can_break_doors(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "canBreakDoors", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn set_can_break_doors(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCanBreakDoors",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Zombie<'mc>> for PigZombie<'mc> {
    fn into(self) -> crate::entity::Zombie<'mc> {
        crate::entity::Zombie::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting PigZombie into crate::entity::Zombie")
    }
}
pub enum TextAlignment<'mc> {
    Center { inner: TextAlignmentStruct<'mc> },
    Left { inner: TextAlignmentStruct<'mc> },
    Right { inner: TextAlignmentStruct<'mc> },
}
impl<'mc> std::fmt::Display for TextAlignment<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TextAlignment::Center { .. } => f.write_str("CENTER"),
            TextAlignment::Left { .. } => f.write_str("LEFT"),
            TextAlignment::Right { .. } => f.write_str("RIGHT"),
        }
    }
}

impl<'mc> TextAlignment<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<TextAlignment<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/TextAlignment");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/TextAlignment;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "CENTER" => Ok(TextAlignment::Center {
                inner: TextAlignmentStruct::from_raw(env, obj)?,
            }),
            "LEFT" => Ok(TextAlignment::Left {
                inner: TextAlignmentStruct::from_raw(env, obj)?,
            }),
            "RIGHT" => Ok(TextAlignment::Right {
                inner: TextAlignmentStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct TextAlignmentStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for TextAlignment<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Center { inner } => inner.0.clone(),
            Self::Left { inner } => inner.0.clone(),
            Self::Right { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Center { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Left { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Right { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TextAlignment<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate TextAlignment from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TextAlignment")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TextAlignment object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "CENTER" => Ok(TextAlignment::Center {
                    inner: TextAlignmentStruct::from_raw(env, obj)?,
                }),
                "LEFT" => Ok(TextAlignment::Left {
                    inner: TextAlignmentStruct::from_raw(env, obj)?,
                }),
                "RIGHT" => Ok(TextAlignment::Right {
                    inner: TextAlignmentStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for TextAlignmentStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TextAlignmentStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate TextAlignmentStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TextAlignment")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TextAlignmentStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> TextAlignmentStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a snowman entity
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Snowman<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Snowman<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Snowman<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Snowman from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Snowman")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Snowman object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Snowman<'mc> {
    pub fn is_derp(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isDerp", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether this snowman is in "derp mode", meaning it is not wearing a pumpkin. NOTE: This value is not persisted to disk and will therefore reset when the chunk is reloaded.
    pub fn set_derp(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDerp",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Golem<'mc>> for Snowman<'mc> {
    fn into(self) -> crate::entity::Golem<'mc> {
        crate::entity::Golem::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Snowman into crate::entity::Golem")
    }
}
/// Represents the various types a Rabbit might be.
pub enum RabbitType<'mc> {
    Brown { inner: RabbitTypeStruct<'mc> },
    White { inner: RabbitTypeStruct<'mc> },
    Black { inner: RabbitTypeStruct<'mc> },
    BlackAndWhite { inner: RabbitTypeStruct<'mc> },
    Gold { inner: RabbitTypeStruct<'mc> },
    SaltAndPepper { inner: RabbitTypeStruct<'mc> },
    TheKillerBunny { inner: RabbitTypeStruct<'mc> },
}
impl<'mc> std::fmt::Display for RabbitType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RabbitType::Brown { .. } => f.write_str("BROWN"),
            RabbitType::White { .. } => f.write_str("WHITE"),
            RabbitType::Black { .. } => f.write_str("BLACK"),
            RabbitType::BlackAndWhite { .. } => f.write_str("BLACK_AND_WHITE"),
            RabbitType::Gold { .. } => f.write_str("GOLD"),
            RabbitType::SaltAndPepper { .. } => f.write_str("SALT_AND_PEPPER"),
            RabbitType::TheKillerBunny { .. } => f.write_str("THE_KILLER_BUNNY"),
        }
    }
}

impl<'mc> RabbitType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<RabbitType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Rabbit$Type");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Rabbit$Type;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "BROWN" => Ok(RabbitType::Brown {
                inner: RabbitTypeStruct::from_raw(env, obj)?,
            }),
            "WHITE" => Ok(RabbitType::White {
                inner: RabbitTypeStruct::from_raw(env, obj)?,
            }),
            "BLACK" => Ok(RabbitType::Black {
                inner: RabbitTypeStruct::from_raw(env, obj)?,
            }),
            "BLACK_AND_WHITE" => Ok(RabbitType::BlackAndWhite {
                inner: RabbitTypeStruct::from_raw(env, obj)?,
            }),
            "GOLD" => Ok(RabbitType::Gold {
                inner: RabbitTypeStruct::from_raw(env, obj)?,
            }),
            "SALT_AND_PEPPER" => Ok(RabbitType::SaltAndPepper {
                inner: RabbitTypeStruct::from_raw(env, obj)?,
            }),
            "THE_KILLER_BUNNY" => Ok(RabbitType::TheKillerBunny {
                inner: RabbitTypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct RabbitTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for RabbitType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Brown { inner } => inner.0.clone(),
            Self::White { inner } => inner.0.clone(),
            Self::Black { inner } => inner.0.clone(),
            Self::BlackAndWhite { inner } => inner.0.clone(),
            Self::Gold { inner } => inner.0.clone(),
            Self::SaltAndPepper { inner } => inner.0.clone(),
            Self::TheKillerBunny { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Brown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::White { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Black { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::BlackAndWhite { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Gold { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::SaltAndPepper { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::TheKillerBunny { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for RabbitType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate RabbitType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Rabbit$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a RabbitType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "BROWN" => Ok(RabbitType::Brown {
                    inner: RabbitTypeStruct::from_raw(env, obj)?,
                }),
                "WHITE" => Ok(RabbitType::White {
                    inner: RabbitTypeStruct::from_raw(env, obj)?,
                }),
                "BLACK" => Ok(RabbitType::Black {
                    inner: RabbitTypeStruct::from_raw(env, obj)?,
                }),
                "BLACK_AND_WHITE" => Ok(RabbitType::BlackAndWhite {
                    inner: RabbitTypeStruct::from_raw(env, obj)?,
                }),
                "GOLD" => Ok(RabbitType::Gold {
                    inner: RabbitTypeStruct::from_raw(env, obj)?,
                }),
                "SALT_AND_PEPPER" => Ok(RabbitType::SaltAndPepper {
                    inner: RabbitTypeStruct::from_raw(env, obj)?,
                }),
                "THE_KILLER_BUNNY" => Ok(RabbitType::TheKillerBunny {
                    inner: RabbitTypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for RabbitTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for RabbitTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate RabbitTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Rabbit$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a RabbitTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> RabbitTypeStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a Zoglin.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Zoglin<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Zoglin<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Zoglin<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Zoglin from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Zoglin")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Zoglin object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Zoglin<'mc> {
    #[deprecated = "see <a href='Ageable.html#setBaby()'><code>Ageable.setBaby()</code></a> and <a href='Ageable.html#setAdult()'><code>Ageable.setAdult()</code></a> "]
    /// Sets whether the zoglin is a baby
    pub fn set_baby(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBaby",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn is_baby(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBaby", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn age(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Zoglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.age()
    }
    pub fn set_age(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Zoglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_age(arg0)
    }

    pub fn set_age_lock(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Zoglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_age_lock(arg0)
    }

    pub fn age_lock(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Zoglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.age_lock()
    }

    pub fn can_breed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Zoglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.can_breed()
    }

    pub fn set_breed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Zoglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_breed(arg0)
    }
    pub fn set_adult(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Zoglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_adult()
    }
    pub fn is_adult(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Zoglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.is_adult()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Zoglin<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Zoglin into crate::entity::Monster")
    }
}
impl<'mc> Into<crate::entity::Ageable<'mc>> for Zoglin<'mc> {
    fn into(self) -> crate::entity::Ageable<'mc> {
        crate::entity::Ageable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Zoglin into crate::entity::Ageable")
    }
}
/// Represents a display entity which is designed to only have a visual function.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Display<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Display<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Display<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Display from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Display")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Display object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Display<'mc> {
    pub fn transformation(
        &self,
    ) -> Result<crate::util::Transformation<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/Transformation;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTransformation",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::util::Transformation::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_transformation(
        &self,
        arg0: impl Into<crate::util::Transformation<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/Transformation;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTransformation",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_transformation_matrix(
        &self,
        arg0: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/joml/Matrix4f;)V");
        let val_1 = jni::objects::JValueGen::Object(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTransformationMatrix",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn interpolation_duration(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getInterpolationDuration",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the interpolation duration of this display.
    pub fn set_interpolation_duration(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setInterpolationDuration",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn view_range(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getViewRange", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the view distance/range of this display.
    pub fn set_view_range(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setViewRange",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn shadow_radius(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getShadowRadius", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the shadow radius of this display.
    pub fn set_shadow_radius(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setShadowRadius",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn shadow_strength(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getShadowStrength",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the shadow strength of this display.
    pub fn set_shadow_strength(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setShadowStrength",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn display_width(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDisplayWidth", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the width of this display.
    pub fn set_display_width(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDisplayWidth",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn display_height(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDisplayHeight",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the height if this display.
    pub fn set_display_height(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDisplayHeight",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn interpolation_delay(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getInterpolationDelay",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the amount of ticks before client-side interpolation will commence.
    pub fn set_interpolation_delay(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setInterpolationDelay",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn billboard(
        &self,
    ) -> Result<crate::entity::DisplayBillboard<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Display$Billboard;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBillboard", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::DisplayBillboard::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_billboard(
        &self,
        arg0: impl Into<crate::entity::DisplayBillboard<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Display$Billboard;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBillboard",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn glow_color_override(
        &self,
    ) -> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Color;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getGlowColorOverride",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn set_glow_color_override(
        &self,
        arg0: impl Into<crate::Color<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Color;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setGlowColorOverride",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn brightness(
        &self,
    ) -> Result<Option<crate::entity::DisplayBrightness<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Display$Brightness;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBrightness", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::DisplayBrightness::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_brightness(
        &self,
        arg0: impl Into<crate::entity::DisplayBrightness<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Display$Brightness;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBrightness",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Display::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Display<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Display into crate::entity::Entity")
    }
}
/// Represents the status of the boat.
pub enum BoatStatus<'mc> {
    InWater { inner: BoatStatusStruct<'mc> },
    UnderWater { inner: BoatStatusStruct<'mc> },
    UnderFlowingWater { inner: BoatStatusStruct<'mc> },
    OnLand { inner: BoatStatusStruct<'mc> },
    InAir { inner: BoatStatusStruct<'mc> },
}
impl<'mc> std::fmt::Display for BoatStatus<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            BoatStatus::InWater { .. } => f.write_str("IN_WATER"),
            BoatStatus::UnderWater { .. } => f.write_str("UNDER_WATER"),
            BoatStatus::UnderFlowingWater { .. } => f.write_str("UNDER_FLOWING_WATER"),
            BoatStatus::OnLand { .. } => f.write_str("ON_LAND"),
            BoatStatus::InAir { .. } => f.write_str("IN_AIR"),
        }
    }
}

impl<'mc> BoatStatus<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<BoatStatus<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Boat$Status");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Boat$Status;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "IN_WATER" => Ok(BoatStatus::InWater {
                inner: BoatStatusStruct::from_raw(env, obj)?,
            }),
            "UNDER_WATER" => Ok(BoatStatus::UnderWater {
                inner: BoatStatusStruct::from_raw(env, obj)?,
            }),
            "UNDER_FLOWING_WATER" => Ok(BoatStatus::UnderFlowingWater {
                inner: BoatStatusStruct::from_raw(env, obj)?,
            }),
            "ON_LAND" => Ok(BoatStatus::OnLand {
                inner: BoatStatusStruct::from_raw(env, obj)?,
            }),
            "IN_AIR" => Ok(BoatStatus::InAir {
                inner: BoatStatusStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct BoatStatusStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for BoatStatus<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::InWater { inner } => inner.0.clone(),
            Self::UnderWater { inner } => inner.0.clone(),
            Self::UnderFlowingWater { inner } => inner.0.clone(),
            Self::OnLand { inner } => inner.0.clone(),
            Self::InAir { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::InWater { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::UnderWater { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::UnderFlowingWater { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::OnLand { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::InAir { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for BoatStatus<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate BoatStatus from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Boat$Status")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a BoatStatus object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "IN_WATER" => Ok(BoatStatus::InWater {
                    inner: BoatStatusStruct::from_raw(env, obj)?,
                }),
                "UNDER_WATER" => Ok(BoatStatus::UnderWater {
                    inner: BoatStatusStruct::from_raw(env, obj)?,
                }),
                "UNDER_FLOWING_WATER" => Ok(BoatStatus::UnderFlowingWater {
                    inner: BoatStatusStruct::from_raw(env, obj)?,
                }),
                "ON_LAND" => Ok(BoatStatus::OnLand {
                    inner: BoatStatusStruct::from_raw(env, obj)?,
                }),
                "IN_AIR" => Ok(BoatStatus::InAir {
                    inner: BoatStatusStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for BoatStatusStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for BoatStatusStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate BoatStatusStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Boat$Status")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a BoatStatusStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> BoatStatusStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum PickupStatus<'mc> {
    Disallowed { inner: PickupStatusStruct<'mc> },
    Allowed { inner: PickupStatusStruct<'mc> },
    CreativeOnly { inner: PickupStatusStruct<'mc> },
}
impl<'mc> std::fmt::Display for PickupStatus<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PickupStatus::Disallowed { .. } => f.write_str("DISALLOWED"),
            PickupStatus::Allowed { .. } => f.write_str("ALLOWED"),
            PickupStatus::CreativeOnly { .. } => f.write_str("CREATIVE_ONLY"),
        }
    }
}

impl<'mc> PickupStatus<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<PickupStatus<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/PickupStatus");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/PickupStatus;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "DISALLOWED" => Ok(PickupStatus::Disallowed {
                inner: PickupStatusStruct::from_raw(env, obj)?,
            }),
            "ALLOWED" => Ok(PickupStatus::Allowed {
                inner: PickupStatusStruct::from_raw(env, obj)?,
            }),
            "CREATIVE_ONLY" => Ok(PickupStatus::CreativeOnly {
                inner: PickupStatusStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct PickupStatusStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for PickupStatus<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Disallowed { inner } => inner.0.clone(),
            Self::Allowed { inner } => inner.0.clone(),
            Self::CreativeOnly { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Disallowed { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Allowed { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::CreativeOnly { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for PickupStatus<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate PickupStatus from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/PickupStatus")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PickupStatus object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "DISALLOWED" => Ok(PickupStatus::Disallowed {
                    inner: PickupStatusStruct::from_raw(env, obj)?,
                }),
                "ALLOWED" => Ok(PickupStatus::Allowed {
                    inner: PickupStatusStruct::from_raw(env, obj)?,
                }),
                "CREATIVE_ONLY" => Ok(PickupStatus::CreativeOnly {
                    inner: PickupStatusStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for PickupStatusStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for PickupStatusStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate PickupStatusStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/PickupStatus")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PickupStatusStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> PickupStatusStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a minecart entity.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Minecart<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Minecart<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Minecart<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Minecart from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Minecart")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Minecart object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Minecart<'mc> {
    /// Sets a minecart's damage.
    pub fn set_damage(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDamage",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn damage(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getDamage", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }

    pub fn max_speed(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxSpeed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Sets the maximum speed of a minecart. Must be nonnegative. Default is 0.4D.
    pub fn set_max_speed(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaxSpeed",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_slow_when_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isSlowWhenEmpty", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether this minecart will slow down faster without a passenger occupying it
    pub fn set_slow_when_empty(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSlowWhenEmpty",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn flying_velocity_mod(
        &self,
    ) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/Vector;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getFlyingVelocityMod",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::util::Vector::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_flying_velocity_mod(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/Vector;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFlyingVelocityMod",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn derailed_velocity_mod(
        &self,
    ) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/Vector;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDerailedVelocityMod",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::util::Vector::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_derailed_velocity_mod(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/Vector;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDerailedVelocityMod",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_display_block(
        &self,
        arg0: impl Into<crate::material::MaterialData<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/material/MaterialData;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDisplayBlock",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn display_block(
        &self,
    ) -> Result<crate::material::MaterialData<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/material/MaterialData;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDisplayBlock", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::material::MaterialData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_display_block_data(
        &self,
        arg0: impl Into<crate::block::data::BlockData<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/block/data/BlockData;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDisplayBlockData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn display_block_data(
        &self,
    ) -> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/block/data/BlockData;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDisplayBlockData",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::block::data::BlockData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the offset of the display block.
    pub fn set_display_block_offset(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDisplayBlockOffset",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn display_block_offset(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDisplayBlockOffset",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Minecart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Vehicle = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Minecart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Vehicle = temp_clone.into();
        real.velocity()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Vehicle<'mc>> for Minecart<'mc> {
    fn into(self) -> crate::entity::Vehicle<'mc> {
        crate::entity::Vehicle::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Minecart into crate::entity::Vehicle")
    }
}
pub enum LockType<'mc> {
    AddingOrChanging { inner: LockTypeStruct<'mc> },
    RemovingOrChanging { inner: LockTypeStruct<'mc> },
    Adding { inner: LockTypeStruct<'mc> },
}
impl<'mc> std::fmt::Display for LockType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LockType::AddingOrChanging { .. } => f.write_str("ADDING_OR_CHANGING"),
            LockType::RemovingOrChanging { .. } => f.write_str("REMOVING_OR_CHANGING"),
            LockType::Adding { .. } => f.write_str("ADDING"),
        }
    }
}

impl<'mc> LockType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<LockType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/LockType");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/LockType;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "ADDING_OR_CHANGING" => Ok(LockType::AddingOrChanging {
                inner: LockTypeStruct::from_raw(env, obj)?,
            }),
            "REMOVING_OR_CHANGING" => Ok(LockType::RemovingOrChanging {
                inner: LockTypeStruct::from_raw(env, obj)?,
            }),
            "ADDING" => Ok(LockType::Adding {
                inner: LockTypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct LockTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for LockType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::AddingOrChanging { inner } => inner.0.clone(),
            Self::RemovingOrChanging { inner } => inner.0.clone(),
            Self::Adding { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::AddingOrChanging { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::RemovingOrChanging { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Adding { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for LockType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate LockType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LockType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a LockType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "ADDING_OR_CHANGING" => Ok(LockType::AddingOrChanging {
                    inner: LockTypeStruct::from_raw(env, obj)?,
                }),
                "REMOVING_OR_CHANGING" => Ok(LockType::RemovingOrChanging {
                    inner: LockTypeStruct::from_raw(env, obj)?,
                }),
                "ADDING" => Ok(LockType::Adding {
                    inner: LockTypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for LockTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for LockTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate LockTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LockType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a LockTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> LockTypeStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum EntityTypeEntityType<'mc> {
    DroppedItem {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    ExperienceOrb {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    AreaEffectCloud {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    ElderGuardian {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    WitherSkeleton {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Stray {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Egg {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    LeashHitch {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Painting {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Arrow {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Snowball {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Fireball {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    SmallFireball {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    EnderPearl {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    EnderSignal {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    SplashPotion {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    ThrownExpBottle {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    ItemFrame {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    WitherSkull {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    PrimedTnt {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    FallingBlock {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Firework {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Husk {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    SpectralArrow {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    ShulkerBullet {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    DragonFireball {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    ZombieVillager {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    SkeletonHorse {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    ZombieHorse {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    ArmorStand {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Donkey {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Mule {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    EvokerFangs {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Evoker {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Vex {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Vindicator {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Illusioner {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    MinecartCommand {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Boat {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Minecart {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    MinecartChest {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    MinecartFurnace {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    MinecartTnt {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    MinecartHopper {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    MinecartMobSpawner {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Creeper {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Skeleton {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Spider {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Giant {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Zombie {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Slime {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Ghast {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    ZombifiedPiglin {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Enderman {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    CaveSpider {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Silverfish {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Blaze {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    MagmaCube {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    EnderDragon {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Wither {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Bat {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Witch {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Endermite {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Guardian {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Shulker {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Pig {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Sheep {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Cow {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Chicken {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Squid {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Wolf {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    MushroomCow {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Snowman {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Ocelot {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    IronGolem {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Horse {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Rabbit {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    PolarBear {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Llama {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    LlamaSpit {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Parrot {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Villager {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    EnderCrystal {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Turtle {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Phantom {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Trident {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Cod {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Salmon {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Pufferfish {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    TropicalFish {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Drowned {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Dolphin {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Cat {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Panda {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Pillager {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Ravager {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    TraderLlama {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    WanderingTrader {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Fox {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Bee {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Hoglin {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Piglin {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Strider {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Zoglin {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    PiglinBrute {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Axolotl {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    GlowItemFrame {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    GlowSquid {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Goat {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Marker {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Allay {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    ChestBoat {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Frog {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Tadpole {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Warden {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Camel {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    BlockDisplay {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Interaction {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    ItemDisplay {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Sniffer {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    TextDisplay {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    FishingHook {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Lightning {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Player {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
    Unknown {
        inner: EntityTypeEntityTypeStruct<'mc>,
    },
}
impl<'mc> std::fmt::Display for EntityTypeEntityType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EntityTypeEntityType::DroppedItem { .. } => f.write_str("DROPPED_ITEM"),
            EntityTypeEntityType::ExperienceOrb { .. } => f.write_str("EXPERIENCE_ORB"),
            EntityTypeEntityType::AreaEffectCloud { .. } => f.write_str("AREA_EFFECT_CLOUD"),
            EntityTypeEntityType::ElderGuardian { .. } => f.write_str("ELDER_GUARDIAN"),
            EntityTypeEntityType::WitherSkeleton { .. } => f.write_str("WITHER_SKELETON"),
            EntityTypeEntityType::Stray { .. } => f.write_str("STRAY"),
            EntityTypeEntityType::Egg { .. } => f.write_str("EGG"),
            EntityTypeEntityType::LeashHitch { .. } => f.write_str("LEASH_HITCH"),
            EntityTypeEntityType::Painting { .. } => f.write_str("PAINTING"),
            EntityTypeEntityType::Arrow { .. } => f.write_str("ARROW"),
            EntityTypeEntityType::Snowball { .. } => f.write_str("SNOWBALL"),
            EntityTypeEntityType::Fireball { .. } => f.write_str("FIREBALL"),
            EntityTypeEntityType::SmallFireball { .. } => f.write_str("SMALL_FIREBALL"),
            EntityTypeEntityType::EnderPearl { .. } => f.write_str("ENDER_PEARL"),
            EntityTypeEntityType::EnderSignal { .. } => f.write_str("ENDER_SIGNAL"),
            EntityTypeEntityType::SplashPotion { .. } => f.write_str("SPLASH_POTION"),
            EntityTypeEntityType::ThrownExpBottle { .. } => f.write_str("THROWN_EXP_BOTTLE"),
            EntityTypeEntityType::ItemFrame { .. } => f.write_str("ITEM_FRAME"),
            EntityTypeEntityType::WitherSkull { .. } => f.write_str("WITHER_SKULL"),
            EntityTypeEntityType::PrimedTnt { .. } => f.write_str("PRIMED_TNT"),
            EntityTypeEntityType::FallingBlock { .. } => f.write_str("FALLING_BLOCK"),
            EntityTypeEntityType::Firework { .. } => f.write_str("FIREWORK"),
            EntityTypeEntityType::Husk { .. } => f.write_str("HUSK"),
            EntityTypeEntityType::SpectralArrow { .. } => f.write_str("SPECTRAL_ARROW"),
            EntityTypeEntityType::ShulkerBullet { .. } => f.write_str("SHULKER_BULLET"),
            EntityTypeEntityType::DragonFireball { .. } => f.write_str("DRAGON_FIREBALL"),
            EntityTypeEntityType::ZombieVillager { .. } => f.write_str("ZOMBIE_VILLAGER"),
            EntityTypeEntityType::SkeletonHorse { .. } => f.write_str("SKELETON_HORSE"),
            EntityTypeEntityType::ZombieHorse { .. } => f.write_str("ZOMBIE_HORSE"),
            EntityTypeEntityType::ArmorStand { .. } => f.write_str("ARMOR_STAND"),
            EntityTypeEntityType::Donkey { .. } => f.write_str("DONKEY"),
            EntityTypeEntityType::Mule { .. } => f.write_str("MULE"),
            EntityTypeEntityType::EvokerFangs { .. } => f.write_str("EVOKER_FANGS"),
            EntityTypeEntityType::Evoker { .. } => f.write_str("EVOKER"),
            EntityTypeEntityType::Vex { .. } => f.write_str("VEX"),
            EntityTypeEntityType::Vindicator { .. } => f.write_str("VINDICATOR"),
            EntityTypeEntityType::Illusioner { .. } => f.write_str("ILLUSIONER"),
            EntityTypeEntityType::MinecartCommand { .. } => f.write_str("MINECART_COMMAND"),
            EntityTypeEntityType::Boat { .. } => f.write_str("BOAT"),
            EntityTypeEntityType::Minecart { .. } => f.write_str("MINECART"),
            EntityTypeEntityType::MinecartChest { .. } => f.write_str("MINECART_CHEST"),
            EntityTypeEntityType::MinecartFurnace { .. } => f.write_str("MINECART_FURNACE"),
            EntityTypeEntityType::MinecartTnt { .. } => f.write_str("MINECART_TNT"),
            EntityTypeEntityType::MinecartHopper { .. } => f.write_str("MINECART_HOPPER"),
            EntityTypeEntityType::MinecartMobSpawner { .. } => f.write_str("MINECART_MOB_SPAWNER"),
            EntityTypeEntityType::Creeper { .. } => f.write_str("CREEPER"),
            EntityTypeEntityType::Skeleton { .. } => f.write_str("SKELETON"),
            EntityTypeEntityType::Spider { .. } => f.write_str("SPIDER"),
            EntityTypeEntityType::Giant { .. } => f.write_str("GIANT"),
            EntityTypeEntityType::Zombie { .. } => f.write_str("ZOMBIE"),
            EntityTypeEntityType::Slime { .. } => f.write_str("SLIME"),
            EntityTypeEntityType::Ghast { .. } => f.write_str("GHAST"),
            EntityTypeEntityType::ZombifiedPiglin { .. } => f.write_str("ZOMBIFIED_PIGLIN"),
            EntityTypeEntityType::Enderman { .. } => f.write_str("ENDERMAN"),
            EntityTypeEntityType::CaveSpider { .. } => f.write_str("CAVE_SPIDER"),
            EntityTypeEntityType::Silverfish { .. } => f.write_str("SILVERFISH"),
            EntityTypeEntityType::Blaze { .. } => f.write_str("BLAZE"),
            EntityTypeEntityType::MagmaCube { .. } => f.write_str("MAGMA_CUBE"),
            EntityTypeEntityType::EnderDragon { .. } => f.write_str("ENDER_DRAGON"),
            EntityTypeEntityType::Wither { .. } => f.write_str("WITHER"),
            EntityTypeEntityType::Bat { .. } => f.write_str("BAT"),
            EntityTypeEntityType::Witch { .. } => f.write_str("WITCH"),
            EntityTypeEntityType::Endermite { .. } => f.write_str("ENDERMITE"),
            EntityTypeEntityType::Guardian { .. } => f.write_str("GUARDIAN"),
            EntityTypeEntityType::Shulker { .. } => f.write_str("SHULKER"),
            EntityTypeEntityType::Pig { .. } => f.write_str("PIG"),
            EntityTypeEntityType::Sheep { .. } => f.write_str("SHEEP"),
            EntityTypeEntityType::Cow { .. } => f.write_str("COW"),
            EntityTypeEntityType::Chicken { .. } => f.write_str("CHICKEN"),
            EntityTypeEntityType::Squid { .. } => f.write_str("SQUID"),
            EntityTypeEntityType::Wolf { .. } => f.write_str("WOLF"),
            EntityTypeEntityType::MushroomCow { .. } => f.write_str("MUSHROOM_COW"),
            EntityTypeEntityType::Snowman { .. } => f.write_str("SNOWMAN"),
            EntityTypeEntityType::Ocelot { .. } => f.write_str("OCELOT"),
            EntityTypeEntityType::IronGolem { .. } => f.write_str("IRON_GOLEM"),
            EntityTypeEntityType::Horse { .. } => f.write_str("HORSE"),
            EntityTypeEntityType::Rabbit { .. } => f.write_str("RABBIT"),
            EntityTypeEntityType::PolarBear { .. } => f.write_str("POLAR_BEAR"),
            EntityTypeEntityType::Llama { .. } => f.write_str("LLAMA"),
            EntityTypeEntityType::LlamaSpit { .. } => f.write_str("LLAMA_SPIT"),
            EntityTypeEntityType::Parrot { .. } => f.write_str("PARROT"),
            EntityTypeEntityType::Villager { .. } => f.write_str("VILLAGER"),
            EntityTypeEntityType::EnderCrystal { .. } => f.write_str("ENDER_CRYSTAL"),
            EntityTypeEntityType::Turtle { .. } => f.write_str("TURTLE"),
            EntityTypeEntityType::Phantom { .. } => f.write_str("PHANTOM"),
            EntityTypeEntityType::Trident { .. } => f.write_str("TRIDENT"),
            EntityTypeEntityType::Cod { .. } => f.write_str("COD"),
            EntityTypeEntityType::Salmon { .. } => f.write_str("SALMON"),
            EntityTypeEntityType::Pufferfish { .. } => f.write_str("PUFFERFISH"),
            EntityTypeEntityType::TropicalFish { .. } => f.write_str("TROPICAL_FISH"),
            EntityTypeEntityType::Drowned { .. } => f.write_str("DROWNED"),
            EntityTypeEntityType::Dolphin { .. } => f.write_str("DOLPHIN"),
            EntityTypeEntityType::Cat { .. } => f.write_str("CAT"),
            EntityTypeEntityType::Panda { .. } => f.write_str("PANDA"),
            EntityTypeEntityType::Pillager { .. } => f.write_str("PILLAGER"),
            EntityTypeEntityType::Ravager { .. } => f.write_str("RAVAGER"),
            EntityTypeEntityType::TraderLlama { .. } => f.write_str("TRADER_LLAMA"),
            EntityTypeEntityType::WanderingTrader { .. } => f.write_str("WANDERING_TRADER"),
            EntityTypeEntityType::Fox { .. } => f.write_str("FOX"),
            EntityTypeEntityType::Bee { .. } => f.write_str("BEE"),
            EntityTypeEntityType::Hoglin { .. } => f.write_str("HOGLIN"),
            EntityTypeEntityType::Piglin { .. } => f.write_str("PIGLIN"),
            EntityTypeEntityType::Strider { .. } => f.write_str("STRIDER"),
            EntityTypeEntityType::Zoglin { .. } => f.write_str("ZOGLIN"),
            EntityTypeEntityType::PiglinBrute { .. } => f.write_str("PIGLIN_BRUTE"),
            EntityTypeEntityType::Axolotl { .. } => f.write_str("AXOLOTL"),
            EntityTypeEntityType::GlowItemFrame { .. } => f.write_str("GLOW_ITEM_FRAME"),
            EntityTypeEntityType::GlowSquid { .. } => f.write_str("GLOW_SQUID"),
            EntityTypeEntityType::Goat { .. } => f.write_str("GOAT"),
            EntityTypeEntityType::Marker { .. } => f.write_str("MARKER"),
            EntityTypeEntityType::Allay { .. } => f.write_str("ALLAY"),
            EntityTypeEntityType::ChestBoat { .. } => f.write_str("CHEST_BOAT"),
            EntityTypeEntityType::Frog { .. } => f.write_str("FROG"),
            EntityTypeEntityType::Tadpole { .. } => f.write_str("TADPOLE"),
            EntityTypeEntityType::Warden { .. } => f.write_str("WARDEN"),
            EntityTypeEntityType::Camel { .. } => f.write_str("CAMEL"),
            EntityTypeEntityType::BlockDisplay { .. } => f.write_str("BLOCK_DISPLAY"),
            EntityTypeEntityType::Interaction { .. } => f.write_str("INTERACTION"),
            EntityTypeEntityType::ItemDisplay { .. } => f.write_str("ITEM_DISPLAY"),
            EntityTypeEntityType::Sniffer { .. } => f.write_str("SNIFFER"),
            EntityTypeEntityType::TextDisplay { .. } => f.write_str("TEXT_DISPLAY"),
            EntityTypeEntityType::FishingHook { .. } => f.write_str("FISHING_HOOK"),
            EntityTypeEntityType::Lightning { .. } => f.write_str("LIGHTNING"),
            EntityTypeEntityType::Player { .. } => f.write_str("PLAYER"),
            EntityTypeEntityType::Unknown { .. } => f.write_str("UNKNOWN"),
        }
    }
}

impl<'mc> EntityTypeEntityType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<EntityTypeEntityType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/EntityType$EntityType");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/EntityType$EntityType;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "DROPPED_ITEM" => Ok(EntityTypeEntityType::DroppedItem {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "EXPERIENCE_ORB" => Ok(EntityTypeEntityType::ExperienceOrb {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "AREA_EFFECT_CLOUD" => Ok(EntityTypeEntityType::AreaEffectCloud {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ELDER_GUARDIAN" => Ok(EntityTypeEntityType::ElderGuardian {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "WITHER_SKELETON" => Ok(EntityTypeEntityType::WitherSkeleton {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "STRAY" => Ok(EntityTypeEntityType::Stray {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "EGG" => Ok(EntityTypeEntityType::Egg {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "LEASH_HITCH" => Ok(EntityTypeEntityType::LeashHitch {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "PAINTING" => Ok(EntityTypeEntityType::Painting {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ARROW" => Ok(EntityTypeEntityType::Arrow {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SNOWBALL" => Ok(EntityTypeEntityType::Snowball {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "FIREBALL" => Ok(EntityTypeEntityType::Fireball {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SMALL_FIREBALL" => Ok(EntityTypeEntityType::SmallFireball {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ENDER_PEARL" => Ok(EntityTypeEntityType::EnderPearl {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ENDER_SIGNAL" => Ok(EntityTypeEntityType::EnderSignal {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SPLASH_POTION" => Ok(EntityTypeEntityType::SplashPotion {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "THROWN_EXP_BOTTLE" => Ok(EntityTypeEntityType::ThrownExpBottle {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ITEM_FRAME" => Ok(EntityTypeEntityType::ItemFrame {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "WITHER_SKULL" => Ok(EntityTypeEntityType::WitherSkull {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "PRIMED_TNT" => Ok(EntityTypeEntityType::PrimedTnt {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "FALLING_BLOCK" => Ok(EntityTypeEntityType::FallingBlock {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "FIREWORK" => Ok(EntityTypeEntityType::Firework {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "HUSK" => Ok(EntityTypeEntityType::Husk {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SPECTRAL_ARROW" => Ok(EntityTypeEntityType::SpectralArrow {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SHULKER_BULLET" => Ok(EntityTypeEntityType::ShulkerBullet {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "DRAGON_FIREBALL" => Ok(EntityTypeEntityType::DragonFireball {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ZOMBIE_VILLAGER" => Ok(EntityTypeEntityType::ZombieVillager {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SKELETON_HORSE" => Ok(EntityTypeEntityType::SkeletonHorse {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ZOMBIE_HORSE" => Ok(EntityTypeEntityType::ZombieHorse {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ARMOR_STAND" => Ok(EntityTypeEntityType::ArmorStand {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "DONKEY" => Ok(EntityTypeEntityType::Donkey {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "MULE" => Ok(EntityTypeEntityType::Mule {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "EVOKER_FANGS" => Ok(EntityTypeEntityType::EvokerFangs {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "EVOKER" => Ok(EntityTypeEntityType::Evoker {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "VEX" => Ok(EntityTypeEntityType::Vex {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "VINDICATOR" => Ok(EntityTypeEntityType::Vindicator {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ILLUSIONER" => Ok(EntityTypeEntityType::Illusioner {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART_COMMAND" => Ok(EntityTypeEntityType::MinecartCommand {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "BOAT" => Ok(EntityTypeEntityType::Boat {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART" => Ok(EntityTypeEntityType::Minecart {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART_CHEST" => Ok(EntityTypeEntityType::MinecartChest {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART_FURNACE" => Ok(EntityTypeEntityType::MinecartFurnace {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART_TNT" => Ok(EntityTypeEntityType::MinecartTnt {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART_HOPPER" => Ok(EntityTypeEntityType::MinecartHopper {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART_MOB_SPAWNER" => Ok(EntityTypeEntityType::MinecartMobSpawner {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "CREEPER" => Ok(EntityTypeEntityType::Creeper {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SKELETON" => Ok(EntityTypeEntityType::Skeleton {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SPIDER" => Ok(EntityTypeEntityType::Spider {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "GIANT" => Ok(EntityTypeEntityType::Giant {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ZOMBIE" => Ok(EntityTypeEntityType::Zombie {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SLIME" => Ok(EntityTypeEntityType::Slime {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "GHAST" => Ok(EntityTypeEntityType::Ghast {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ZOMBIFIED_PIGLIN" => Ok(EntityTypeEntityType::ZombifiedPiglin {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ENDERMAN" => Ok(EntityTypeEntityType::Enderman {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "CAVE_SPIDER" => Ok(EntityTypeEntityType::CaveSpider {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SILVERFISH" => Ok(EntityTypeEntityType::Silverfish {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "BLAZE" => Ok(EntityTypeEntityType::Blaze {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "MAGMA_CUBE" => Ok(EntityTypeEntityType::MagmaCube {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ENDER_DRAGON" => Ok(EntityTypeEntityType::EnderDragon {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "WITHER" => Ok(EntityTypeEntityType::Wither {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "BAT" => Ok(EntityTypeEntityType::Bat {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "WITCH" => Ok(EntityTypeEntityType::Witch {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ENDERMITE" => Ok(EntityTypeEntityType::Endermite {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "GUARDIAN" => Ok(EntityTypeEntityType::Guardian {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SHULKER" => Ok(EntityTypeEntityType::Shulker {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "PIG" => Ok(EntityTypeEntityType::Pig {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SHEEP" => Ok(EntityTypeEntityType::Sheep {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "COW" => Ok(EntityTypeEntityType::Cow {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "CHICKEN" => Ok(EntityTypeEntityType::Chicken {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SQUID" => Ok(EntityTypeEntityType::Squid {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "WOLF" => Ok(EntityTypeEntityType::Wolf {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "MUSHROOM_COW" => Ok(EntityTypeEntityType::MushroomCow {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SNOWMAN" => Ok(EntityTypeEntityType::Snowman {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "OCELOT" => Ok(EntityTypeEntityType::Ocelot {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "IRON_GOLEM" => Ok(EntityTypeEntityType::IronGolem {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "HORSE" => Ok(EntityTypeEntityType::Horse {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "RABBIT" => Ok(EntityTypeEntityType::Rabbit {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "POLAR_BEAR" => Ok(EntityTypeEntityType::PolarBear {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "LLAMA" => Ok(EntityTypeEntityType::Llama {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "LLAMA_SPIT" => Ok(EntityTypeEntityType::LlamaSpit {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "PARROT" => Ok(EntityTypeEntityType::Parrot {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "VILLAGER" => Ok(EntityTypeEntityType::Villager {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ENDER_CRYSTAL" => Ok(EntityTypeEntityType::EnderCrystal {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "TURTLE" => Ok(EntityTypeEntityType::Turtle {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "PHANTOM" => Ok(EntityTypeEntityType::Phantom {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "TRIDENT" => Ok(EntityTypeEntityType::Trident {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "COD" => Ok(EntityTypeEntityType::Cod {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SALMON" => Ok(EntityTypeEntityType::Salmon {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "PUFFERFISH" => Ok(EntityTypeEntityType::Pufferfish {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "TROPICAL_FISH" => Ok(EntityTypeEntityType::TropicalFish {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "DROWNED" => Ok(EntityTypeEntityType::Drowned {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "DOLPHIN" => Ok(EntityTypeEntityType::Dolphin {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "CAT" => Ok(EntityTypeEntityType::Cat {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "PANDA" => Ok(EntityTypeEntityType::Panda {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "PILLAGER" => Ok(EntityTypeEntityType::Pillager {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "RAVAGER" => Ok(EntityTypeEntityType::Ravager {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "TRADER_LLAMA" => Ok(EntityTypeEntityType::TraderLlama {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "WANDERING_TRADER" => Ok(EntityTypeEntityType::WanderingTrader {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "FOX" => Ok(EntityTypeEntityType::Fox {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "BEE" => Ok(EntityTypeEntityType::Bee {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "HOGLIN" => Ok(EntityTypeEntityType::Hoglin {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "PIGLIN" => Ok(EntityTypeEntityType::Piglin {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "STRIDER" => Ok(EntityTypeEntityType::Strider {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ZOGLIN" => Ok(EntityTypeEntityType::Zoglin {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "PIGLIN_BRUTE" => Ok(EntityTypeEntityType::PiglinBrute {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "AXOLOTL" => Ok(EntityTypeEntityType::Axolotl {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "GLOW_ITEM_FRAME" => Ok(EntityTypeEntityType::GlowItemFrame {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "GLOW_SQUID" => Ok(EntityTypeEntityType::GlowSquid {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "GOAT" => Ok(EntityTypeEntityType::Goat {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "MARKER" => Ok(EntityTypeEntityType::Marker {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ALLAY" => Ok(EntityTypeEntityType::Allay {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "CHEST_BOAT" => Ok(EntityTypeEntityType::ChestBoat {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "FROG" => Ok(EntityTypeEntityType::Frog {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "TADPOLE" => Ok(EntityTypeEntityType::Tadpole {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "WARDEN" => Ok(EntityTypeEntityType::Warden {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "CAMEL" => Ok(EntityTypeEntityType::Camel {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "BLOCK_DISPLAY" => Ok(EntityTypeEntityType::BlockDisplay {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "INTERACTION" => Ok(EntityTypeEntityType::Interaction {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "ITEM_DISPLAY" => Ok(EntityTypeEntityType::ItemDisplay {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "SNIFFER" => Ok(EntityTypeEntityType::Sniffer {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "TEXT_DISPLAY" => Ok(EntityTypeEntityType::TextDisplay {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "FISHING_HOOK" => Ok(EntityTypeEntityType::FishingHook {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "LIGHTNING" => Ok(EntityTypeEntityType::Lightning {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "PLAYER" => Ok(EntityTypeEntityType::Player {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),
            "UNKNOWN" => Ok(EntityTypeEntityType::Unknown {
                inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct EntityTypeEntityTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EntityTypeEntityType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::DroppedItem { inner } => inner.0.clone(),
            Self::ExperienceOrb { inner } => inner.0.clone(),
            Self::AreaEffectCloud { inner } => inner.0.clone(),
            Self::ElderGuardian { inner } => inner.0.clone(),
            Self::WitherSkeleton { inner } => inner.0.clone(),
            Self::Stray { inner } => inner.0.clone(),
            Self::Egg { inner } => inner.0.clone(),
            Self::LeashHitch { inner } => inner.0.clone(),
            Self::Painting { inner } => inner.0.clone(),
            Self::Arrow { inner } => inner.0.clone(),
            Self::Snowball { inner } => inner.0.clone(),
            Self::Fireball { inner } => inner.0.clone(),
            Self::SmallFireball { inner } => inner.0.clone(),
            Self::EnderPearl { inner } => inner.0.clone(),
            Self::EnderSignal { inner } => inner.0.clone(),
            Self::SplashPotion { inner } => inner.0.clone(),
            Self::ThrownExpBottle { inner } => inner.0.clone(),
            Self::ItemFrame { inner } => inner.0.clone(),
            Self::WitherSkull { inner } => inner.0.clone(),
            Self::PrimedTnt { inner } => inner.0.clone(),
            Self::FallingBlock { inner } => inner.0.clone(),
            Self::Firework { inner } => inner.0.clone(),
            Self::Husk { inner } => inner.0.clone(),
            Self::SpectralArrow { inner } => inner.0.clone(),
            Self::ShulkerBullet { inner } => inner.0.clone(),
            Self::DragonFireball { inner } => inner.0.clone(),
            Self::ZombieVillager { inner } => inner.0.clone(),
            Self::SkeletonHorse { inner } => inner.0.clone(),
            Self::ZombieHorse { inner } => inner.0.clone(),
            Self::ArmorStand { inner } => inner.0.clone(),
            Self::Donkey { inner } => inner.0.clone(),
            Self::Mule { inner } => inner.0.clone(),
            Self::EvokerFangs { inner } => inner.0.clone(),
            Self::Evoker { inner } => inner.0.clone(),
            Self::Vex { inner } => inner.0.clone(),
            Self::Vindicator { inner } => inner.0.clone(),
            Self::Illusioner { inner } => inner.0.clone(),
            Self::MinecartCommand { inner } => inner.0.clone(),
            Self::Boat { inner } => inner.0.clone(),
            Self::Minecart { inner } => inner.0.clone(),
            Self::MinecartChest { inner } => inner.0.clone(),
            Self::MinecartFurnace { inner } => inner.0.clone(),
            Self::MinecartTnt { inner } => inner.0.clone(),
            Self::MinecartHopper { inner } => inner.0.clone(),
            Self::MinecartMobSpawner { inner } => inner.0.clone(),
            Self::Creeper { inner } => inner.0.clone(),
            Self::Skeleton { inner } => inner.0.clone(),
            Self::Spider { inner } => inner.0.clone(),
            Self::Giant { inner } => inner.0.clone(),
            Self::Zombie { inner } => inner.0.clone(),
            Self::Slime { inner } => inner.0.clone(),
            Self::Ghast { inner } => inner.0.clone(),
            Self::ZombifiedPiglin { inner } => inner.0.clone(),
            Self::Enderman { inner } => inner.0.clone(),
            Self::CaveSpider { inner } => inner.0.clone(),
            Self::Silverfish { inner } => inner.0.clone(),
            Self::Blaze { inner } => inner.0.clone(),
            Self::MagmaCube { inner } => inner.0.clone(),
            Self::EnderDragon { inner } => inner.0.clone(),
            Self::Wither { inner } => inner.0.clone(),
            Self::Bat { inner } => inner.0.clone(),
            Self::Witch { inner } => inner.0.clone(),
            Self::Endermite { inner } => inner.0.clone(),
            Self::Guardian { inner } => inner.0.clone(),
            Self::Shulker { inner } => inner.0.clone(),
            Self::Pig { inner } => inner.0.clone(),
            Self::Sheep { inner } => inner.0.clone(),
            Self::Cow { inner } => inner.0.clone(),
            Self::Chicken { inner } => inner.0.clone(),
            Self::Squid { inner } => inner.0.clone(),
            Self::Wolf { inner } => inner.0.clone(),
            Self::MushroomCow { inner } => inner.0.clone(),
            Self::Snowman { inner } => inner.0.clone(),
            Self::Ocelot { inner } => inner.0.clone(),
            Self::IronGolem { inner } => inner.0.clone(),
            Self::Horse { inner } => inner.0.clone(),
            Self::Rabbit { inner } => inner.0.clone(),
            Self::PolarBear { inner } => inner.0.clone(),
            Self::Llama { inner } => inner.0.clone(),
            Self::LlamaSpit { inner } => inner.0.clone(),
            Self::Parrot { inner } => inner.0.clone(),
            Self::Villager { inner } => inner.0.clone(),
            Self::EnderCrystal { inner } => inner.0.clone(),
            Self::Turtle { inner } => inner.0.clone(),
            Self::Phantom { inner } => inner.0.clone(),
            Self::Trident { inner } => inner.0.clone(),
            Self::Cod { inner } => inner.0.clone(),
            Self::Salmon { inner } => inner.0.clone(),
            Self::Pufferfish { inner } => inner.0.clone(),
            Self::TropicalFish { inner } => inner.0.clone(),
            Self::Drowned { inner } => inner.0.clone(),
            Self::Dolphin { inner } => inner.0.clone(),
            Self::Cat { inner } => inner.0.clone(),
            Self::Panda { inner } => inner.0.clone(),
            Self::Pillager { inner } => inner.0.clone(),
            Self::Ravager { inner } => inner.0.clone(),
            Self::TraderLlama { inner } => inner.0.clone(),
            Self::WanderingTrader { inner } => inner.0.clone(),
            Self::Fox { inner } => inner.0.clone(),
            Self::Bee { inner } => inner.0.clone(),
            Self::Hoglin { inner } => inner.0.clone(),
            Self::Piglin { inner } => inner.0.clone(),
            Self::Strider { inner } => inner.0.clone(),
            Self::Zoglin { inner } => inner.0.clone(),
            Self::PiglinBrute { inner } => inner.0.clone(),
            Self::Axolotl { inner } => inner.0.clone(),
            Self::GlowItemFrame { inner } => inner.0.clone(),
            Self::GlowSquid { inner } => inner.0.clone(),
            Self::Goat { inner } => inner.0.clone(),
            Self::Marker { inner } => inner.0.clone(),
            Self::Allay { inner } => inner.0.clone(),
            Self::ChestBoat { inner } => inner.0.clone(),
            Self::Frog { inner } => inner.0.clone(),
            Self::Tadpole { inner } => inner.0.clone(),
            Self::Warden { inner } => inner.0.clone(),
            Self::Camel { inner } => inner.0.clone(),
            Self::BlockDisplay { inner } => inner.0.clone(),
            Self::Interaction { inner } => inner.0.clone(),
            Self::ItemDisplay { inner } => inner.0.clone(),
            Self::Sniffer { inner } => inner.0.clone(),
            Self::TextDisplay { inner } => inner.0.clone(),
            Self::FishingHook { inner } => inner.0.clone(),
            Self::Lightning { inner } => inner.0.clone(),
            Self::Player { inner } => inner.0.clone(),
            Self::Unknown { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::DroppedItem { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ExperienceOrb { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::AreaEffectCloud { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ElderGuardian { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::WitherSkeleton { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Stray { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Egg { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::LeashHitch { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Painting { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Arrow { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Snowball { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Fireball { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::SmallFireball { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EnderPearl { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EnderSignal { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::SplashPotion { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ThrownExpBottle { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ItemFrame { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::WitherSkull { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::PrimedTnt { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::FallingBlock { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Firework { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Husk { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::SpectralArrow { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ShulkerBullet { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DragonFireball { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ZombieVillager { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::SkeletonHorse { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ZombieHorse { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ArmorStand { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Donkey { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Mule { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::EvokerFangs { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Evoker { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Vex { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Vindicator { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Illusioner { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MinecartCommand { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Boat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Minecart { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::MinecartChest { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MinecartFurnace { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MinecartTnt { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MinecartHopper { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MinecartMobSpawner { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Creeper { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Skeleton { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Spider { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Giant { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Zombie { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Slime { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Ghast { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::ZombifiedPiglin { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Enderman { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::CaveSpider { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Silverfish { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Blaze { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::MagmaCube { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EnderDragon { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Wither { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Bat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Witch { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Endermite { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Guardian { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Shulker { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Pig { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Sheep { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cow { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Chicken { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Squid { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Wolf { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::MushroomCow { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Snowman { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Ocelot { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::IronGolem { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Horse { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Rabbit { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::PolarBear { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Llama { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::LlamaSpit { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Parrot { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Villager { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::EnderCrystal { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Turtle { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Phantom { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Trident { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cod { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Salmon { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Pufferfish { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::TropicalFish { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Drowned { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Dolphin { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Panda { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Pillager { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Ravager { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::TraderLlama { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::WanderingTrader { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Fox { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Bee { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Hoglin { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Piglin { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Strider { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Zoglin { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::PiglinBrute { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Axolotl { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::GlowItemFrame { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::GlowSquid { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Goat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Marker { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Allay { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::ChestBoat { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Frog { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Tadpole { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Warden { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Camel { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::BlockDisplay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Interaction { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ItemDisplay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Sniffer { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::TextDisplay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::FishingHook { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Lightning { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Player { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Unknown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EntityTypeEntityType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate EntityTypeEntityType from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EntityType$EntityType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EntityTypeEntityType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "DROPPED_ITEM" => Ok(EntityTypeEntityType::DroppedItem {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "EXPERIENCE_ORB" => Ok(EntityTypeEntityType::ExperienceOrb {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "AREA_EFFECT_CLOUD" => Ok(EntityTypeEntityType::AreaEffectCloud {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ELDER_GUARDIAN" => Ok(EntityTypeEntityType::ElderGuardian {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "WITHER_SKELETON" => Ok(EntityTypeEntityType::WitherSkeleton {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "STRAY" => Ok(EntityTypeEntityType::Stray {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "EGG" => Ok(EntityTypeEntityType::Egg {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "LEASH_HITCH" => Ok(EntityTypeEntityType::LeashHitch {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "PAINTING" => Ok(EntityTypeEntityType::Painting {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ARROW" => Ok(EntityTypeEntityType::Arrow {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SNOWBALL" => Ok(EntityTypeEntityType::Snowball {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "FIREBALL" => Ok(EntityTypeEntityType::Fireball {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SMALL_FIREBALL" => Ok(EntityTypeEntityType::SmallFireball {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ENDER_PEARL" => Ok(EntityTypeEntityType::EnderPearl {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ENDER_SIGNAL" => Ok(EntityTypeEntityType::EnderSignal {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SPLASH_POTION" => Ok(EntityTypeEntityType::SplashPotion {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "THROWN_EXP_BOTTLE" => Ok(EntityTypeEntityType::ThrownExpBottle {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ITEM_FRAME" => Ok(EntityTypeEntityType::ItemFrame {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "WITHER_SKULL" => Ok(EntityTypeEntityType::WitherSkull {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "PRIMED_TNT" => Ok(EntityTypeEntityType::PrimedTnt {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "FALLING_BLOCK" => Ok(EntityTypeEntityType::FallingBlock {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "FIREWORK" => Ok(EntityTypeEntityType::Firework {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "HUSK" => Ok(EntityTypeEntityType::Husk {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SPECTRAL_ARROW" => Ok(EntityTypeEntityType::SpectralArrow {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SHULKER_BULLET" => Ok(EntityTypeEntityType::ShulkerBullet {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "DRAGON_FIREBALL" => Ok(EntityTypeEntityType::DragonFireball {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ZOMBIE_VILLAGER" => Ok(EntityTypeEntityType::ZombieVillager {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SKELETON_HORSE" => Ok(EntityTypeEntityType::SkeletonHorse {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ZOMBIE_HORSE" => Ok(EntityTypeEntityType::ZombieHorse {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ARMOR_STAND" => Ok(EntityTypeEntityType::ArmorStand {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "DONKEY" => Ok(EntityTypeEntityType::Donkey {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "MULE" => Ok(EntityTypeEntityType::Mule {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "EVOKER_FANGS" => Ok(EntityTypeEntityType::EvokerFangs {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "EVOKER" => Ok(EntityTypeEntityType::Evoker {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "VEX" => Ok(EntityTypeEntityType::Vex {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "VINDICATOR" => Ok(EntityTypeEntityType::Vindicator {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ILLUSIONER" => Ok(EntityTypeEntityType::Illusioner {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART_COMMAND" => Ok(EntityTypeEntityType::MinecartCommand {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "BOAT" => Ok(EntityTypeEntityType::Boat {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART" => Ok(EntityTypeEntityType::Minecart {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART_CHEST" => Ok(EntityTypeEntityType::MinecartChest {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART_FURNACE" => Ok(EntityTypeEntityType::MinecartFurnace {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART_TNT" => Ok(EntityTypeEntityType::MinecartTnt {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART_HOPPER" => Ok(EntityTypeEntityType::MinecartHopper {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART_MOB_SPAWNER" => Ok(EntityTypeEntityType::MinecartMobSpawner {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "CREEPER" => Ok(EntityTypeEntityType::Creeper {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SKELETON" => Ok(EntityTypeEntityType::Skeleton {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SPIDER" => Ok(EntityTypeEntityType::Spider {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "GIANT" => Ok(EntityTypeEntityType::Giant {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ZOMBIE" => Ok(EntityTypeEntityType::Zombie {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SLIME" => Ok(EntityTypeEntityType::Slime {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "GHAST" => Ok(EntityTypeEntityType::Ghast {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ZOMBIFIED_PIGLIN" => Ok(EntityTypeEntityType::ZombifiedPiglin {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ENDERMAN" => Ok(EntityTypeEntityType::Enderman {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "CAVE_SPIDER" => Ok(EntityTypeEntityType::CaveSpider {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SILVERFISH" => Ok(EntityTypeEntityType::Silverfish {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "BLAZE" => Ok(EntityTypeEntityType::Blaze {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "MAGMA_CUBE" => Ok(EntityTypeEntityType::MagmaCube {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ENDER_DRAGON" => Ok(EntityTypeEntityType::EnderDragon {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "WITHER" => Ok(EntityTypeEntityType::Wither {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "BAT" => Ok(EntityTypeEntityType::Bat {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "WITCH" => Ok(EntityTypeEntityType::Witch {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ENDERMITE" => Ok(EntityTypeEntityType::Endermite {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "GUARDIAN" => Ok(EntityTypeEntityType::Guardian {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SHULKER" => Ok(EntityTypeEntityType::Shulker {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "PIG" => Ok(EntityTypeEntityType::Pig {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SHEEP" => Ok(EntityTypeEntityType::Sheep {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "COW" => Ok(EntityTypeEntityType::Cow {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "CHICKEN" => Ok(EntityTypeEntityType::Chicken {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SQUID" => Ok(EntityTypeEntityType::Squid {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "WOLF" => Ok(EntityTypeEntityType::Wolf {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "MUSHROOM_COW" => Ok(EntityTypeEntityType::MushroomCow {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SNOWMAN" => Ok(EntityTypeEntityType::Snowman {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "OCELOT" => Ok(EntityTypeEntityType::Ocelot {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "IRON_GOLEM" => Ok(EntityTypeEntityType::IronGolem {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "HORSE" => Ok(EntityTypeEntityType::Horse {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "RABBIT" => Ok(EntityTypeEntityType::Rabbit {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "POLAR_BEAR" => Ok(EntityTypeEntityType::PolarBear {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "LLAMA" => Ok(EntityTypeEntityType::Llama {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "LLAMA_SPIT" => Ok(EntityTypeEntityType::LlamaSpit {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "PARROT" => Ok(EntityTypeEntityType::Parrot {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "VILLAGER" => Ok(EntityTypeEntityType::Villager {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ENDER_CRYSTAL" => Ok(EntityTypeEntityType::EnderCrystal {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "TURTLE" => Ok(EntityTypeEntityType::Turtle {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "PHANTOM" => Ok(EntityTypeEntityType::Phantom {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "TRIDENT" => Ok(EntityTypeEntityType::Trident {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "COD" => Ok(EntityTypeEntityType::Cod {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SALMON" => Ok(EntityTypeEntityType::Salmon {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "PUFFERFISH" => Ok(EntityTypeEntityType::Pufferfish {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "TROPICAL_FISH" => Ok(EntityTypeEntityType::TropicalFish {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "DROWNED" => Ok(EntityTypeEntityType::Drowned {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "DOLPHIN" => Ok(EntityTypeEntityType::Dolphin {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "CAT" => Ok(EntityTypeEntityType::Cat {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "PANDA" => Ok(EntityTypeEntityType::Panda {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "PILLAGER" => Ok(EntityTypeEntityType::Pillager {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "RAVAGER" => Ok(EntityTypeEntityType::Ravager {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "TRADER_LLAMA" => Ok(EntityTypeEntityType::TraderLlama {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "WANDERING_TRADER" => Ok(EntityTypeEntityType::WanderingTrader {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "FOX" => Ok(EntityTypeEntityType::Fox {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "BEE" => Ok(EntityTypeEntityType::Bee {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "HOGLIN" => Ok(EntityTypeEntityType::Hoglin {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "PIGLIN" => Ok(EntityTypeEntityType::Piglin {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "STRIDER" => Ok(EntityTypeEntityType::Strider {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ZOGLIN" => Ok(EntityTypeEntityType::Zoglin {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "PIGLIN_BRUTE" => Ok(EntityTypeEntityType::PiglinBrute {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "AXOLOTL" => Ok(EntityTypeEntityType::Axolotl {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "GLOW_ITEM_FRAME" => Ok(EntityTypeEntityType::GlowItemFrame {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "GLOW_SQUID" => Ok(EntityTypeEntityType::GlowSquid {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "GOAT" => Ok(EntityTypeEntityType::Goat {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "MARKER" => Ok(EntityTypeEntityType::Marker {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ALLAY" => Ok(EntityTypeEntityType::Allay {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "CHEST_BOAT" => Ok(EntityTypeEntityType::ChestBoat {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "FROG" => Ok(EntityTypeEntityType::Frog {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "TADPOLE" => Ok(EntityTypeEntityType::Tadpole {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "WARDEN" => Ok(EntityTypeEntityType::Warden {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "CAMEL" => Ok(EntityTypeEntityType::Camel {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "BLOCK_DISPLAY" => Ok(EntityTypeEntityType::BlockDisplay {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "INTERACTION" => Ok(EntityTypeEntityType::Interaction {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "ITEM_DISPLAY" => Ok(EntityTypeEntityType::ItemDisplay {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "SNIFFER" => Ok(EntityTypeEntityType::Sniffer {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "TEXT_DISPLAY" => Ok(EntityTypeEntityType::TextDisplay {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "FISHING_HOOK" => Ok(EntityTypeEntityType::FishingHook {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "LIGHTNING" => Ok(EntityTypeEntityType::Lightning {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "PLAYER" => Ok(EntityTypeEntityType::Player {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                "UNKNOWN" => Ok(EntityTypeEntityType::Unknown {
                    inner: EntityTypeEntityTypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for EntityTypeEntityTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EntityTypeEntityTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate EntityTypeEntityTypeStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EntityType$EntityType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EntityTypeEntityTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EntityTypeEntityTypeStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a falling block
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct FallingBlock<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for FallingBlock<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FallingBlock<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate FallingBlock from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/FallingBlock")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FallingBlock object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> FallingBlock<'mc> {
    pub fn material(&self) -> Result<crate::Material<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Material;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaterial", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Material::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn block_data(
        &self,
    ) -> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/block/data/BlockData;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBlockData", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::data::BlockData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn drop_item(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDropItem", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set if the falling block will break into an item if it cannot be placed.
    /// <p>Note that if <a href="#getCancelDrop()"><code>getCancelDrop()</code></a> is <code>true</code>, the falling block will not drop an item regardless of whether or not the value is set to <code>true</code>.</p>
    pub fn set_drop_item(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDropItem",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn cancel_drop(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getCancelDrop", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Get if the falling block will not become a block upon landing and not drop an item.
    /// <p>Unlike <a href="#setDropItem(boolean)"><code>setDropItem(boolean)</code></a>, this property will prevent the block from forming into a block when it lands, causing it to disappear. If this property is true and <a href="#getDropItem()"><code>getDropItem()</code></a> is true, an item will <strong>NOT</strong> be dropped.</p>
    pub fn set_cancel_drop(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCancelDrop",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn can_hurt_entities(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "canHurtEntities", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set the HurtEntities state of this block.
    pub fn set_hurt_entities(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setHurtEntities",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn damage_per_block(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDamagePerBlock",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Set the amount of damage inflicted upon entities multiplied by the distance that the block had fallen when this falling block lands on them.
    /// <p>If <code>damage</code> is non-zero, this method will automatically call <a href="#setHurtEntities(boolean)"><code>setHurtEntities(true)</code></a>.</p>
    pub fn set_damage_per_block(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDamagePerBlock",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn max_damage(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxDamage", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the maximum amount of damage that can be inflicted upon entities when this falling block lands on them.
    /// <p>If <code>damage</code> is non-zero, this method will automatically call <a href="#setHurtEntities(boolean)"><code>setHurtEntities(true)</code></a>.</p>
    pub fn set_max_damage(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaxDamage",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FallingBlock::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for FallingBlock<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting FallingBlock into crate::entity::Entity")
    }
}
/// Represents a vehicle entity.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Vehicle<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Vehicle<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Vehicle<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Vehicle from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Vehicle")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Vehicle object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Vehicle<'mc> {
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/Vector;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVelocity",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/Vector;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getVelocity", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::Vector::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Vehicle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Vehicle<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Vehicle into crate::entity::Entity")
    }
}
/// A representation of an explosive entity
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Explosive<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Explosive<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Explosive<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Explosive from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Explosive")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Explosive object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Explosive<'mc> {
    /// Set the radius affected by this explosive's explosion
    pub fn set_yield(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setYield",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn get_yield(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getYield", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Set whether or not this explosive's explosion causes fire
    pub fn set_is_incendiary(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setIsIncendiary",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_incendiary(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isIncendiary", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Explosive::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Explosive<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Explosive into crate::entity::Entity")
    }
}
/// Represents a Hanging entity
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Hanging<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Hanging<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Hanging<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Hanging from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Hanging")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Hanging object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Hanging<'mc> {
    pub fn set_facing_direction(
        &self,
        arg0: impl Into<crate::block::BlockFace<'mc>>,
        arg1: bool,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/block/BlockFace;Z)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Bool(arg1.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFacingDirection",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }
    pub fn attached_face(
        &self,
    ) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Hanging::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::material::Attachable = temp_clone.into();
        real.attached_face()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Hanging<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Hanging into crate::entity::Entity")
    }
}
impl<'mc> Into<crate::material::Attachable<'mc>> for Hanging<'mc> {
    fn into(self) -> crate::material::Attachable<'mc> {
        crate::material::Attachable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Hanging into crate::material::Attachable")
    }
}
/// Represents an EnderSignal, which is created upon throwing an ender eye.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct EnderSignal<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EnderSignal<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EnderSignal<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate EnderSignal from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderSignal")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EnderSignal object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EnderSignal<'mc> {
    pub fn item(&self) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getItem", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_item(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setItem",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn tarlocation(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTargetLocation",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_target_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTargetLocation",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn drop_item(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDropItem", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if the EnderSignal should drop an item on death; or if it should shatter.
    pub fn set_drop_item(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDropItem",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn despawn_timer(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDespawnTimer", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set how long this entity has been alive (in ticks).
    ///
    /// When this number is greater than 80, it will despawn on the next tick.
    pub fn set_despawn_timer(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDespawnTimer",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderSignal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for EnderSignal<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting EnderSignal into crate::entity::Entity")
    }
}
pub enum SkeletonType<'mc> {
    Normal { inner: SkeletonTypeStruct<'mc> },
    Wither { inner: SkeletonTypeStruct<'mc> },
    Stray { inner: SkeletonTypeStruct<'mc> },
}
impl<'mc> std::fmt::Display for SkeletonType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SkeletonType::Normal { .. } => f.write_str("NORMAL"),
            SkeletonType::Wither { .. } => f.write_str("WITHER"),
            SkeletonType::Stray { .. } => f.write_str("STRAY"),
        }
    }
}

impl<'mc> SkeletonType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<SkeletonType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/SkeletonType");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/SkeletonType;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NORMAL" => Ok(SkeletonType::Normal {
                inner: SkeletonTypeStruct::from_raw(env, obj)?,
            }),
            "WITHER" => Ok(SkeletonType::Wither {
                inner: SkeletonTypeStruct::from_raw(env, obj)?,
            }),
            "STRAY" => Ok(SkeletonType::Stray {
                inner: SkeletonTypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct SkeletonTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SkeletonType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Normal { inner } => inner.0.clone(),
            Self::Wither { inner } => inner.0.clone(),
            Self::Stray { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Normal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Wither { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Stray { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SkeletonType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SkeletonType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SkeletonType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SkeletonType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NORMAL" => Ok(SkeletonType::Normal {
                    inner: SkeletonTypeStruct::from_raw(env, obj)?,
                }),
                "WITHER" => Ok(SkeletonType::Wither {
                    inner: SkeletonTypeStruct::from_raw(env, obj)?,
                }),
                "STRAY" => Ok(SkeletonType::Stray {
                    inner: SkeletonTypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for SkeletonTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SkeletonTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate SkeletonTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SkeletonType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SkeletonTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SkeletonTypeStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents an Enemy
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Enemy<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Enemy<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Enemy<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Enemy from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Enemy")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Enemy object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Enemy<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::LivingEntity<'mc>> for Enemy<'mc> {
    fn into(self) -> crate::entity::LivingEntity<'mc> {
        crate::entity::LivingEntity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Enemy into crate::entity::LivingEntity")
    }
}
pub enum Pose<'mc> {
    Standing { inner: PoseStruct<'mc> },
    FallFlying { inner: PoseStruct<'mc> },
    Sleeping { inner: PoseStruct<'mc> },
    Swimming { inner: PoseStruct<'mc> },
    SpinAttack { inner: PoseStruct<'mc> },
    Sneaking { inner: PoseStruct<'mc> },
    LongJumping { inner: PoseStruct<'mc> },
    Dying { inner: PoseStruct<'mc> },
    Croaking { inner: PoseStruct<'mc> },
    UsingTongue { inner: PoseStruct<'mc> },
    Sitting { inner: PoseStruct<'mc> },
    Roaring { inner: PoseStruct<'mc> },
    Sniffing { inner: PoseStruct<'mc> },
    Emerging { inner: PoseStruct<'mc> },
    Digging { inner: PoseStruct<'mc> },
}
impl<'mc> std::fmt::Display for Pose<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Pose::Standing { .. } => f.write_str("STANDING"),
            Pose::FallFlying { .. } => f.write_str("FALL_FLYING"),
            Pose::Sleeping { .. } => f.write_str("SLEEPING"),
            Pose::Swimming { .. } => f.write_str("SWIMMING"),
            Pose::SpinAttack { .. } => f.write_str("SPIN_ATTACK"),
            Pose::Sneaking { .. } => f.write_str("SNEAKING"),
            Pose::LongJumping { .. } => f.write_str("LONG_JUMPING"),
            Pose::Dying { .. } => f.write_str("DYING"),
            Pose::Croaking { .. } => f.write_str("CROAKING"),
            Pose::UsingTongue { .. } => f.write_str("USING_TONGUE"),
            Pose::Sitting { .. } => f.write_str("SITTING"),
            Pose::Roaring { .. } => f.write_str("ROARING"),
            Pose::Sniffing { .. } => f.write_str("SNIFFING"),
            Pose::Emerging { .. } => f.write_str("EMERGING"),
            Pose::Digging { .. } => f.write_str("DIGGING"),
        }
    }
}

impl<'mc> Pose<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Pose<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Pose");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Pose;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "STANDING" => Ok(Pose::Standing {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "FALL_FLYING" => Ok(Pose::FallFlying {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "SLEEPING" => Ok(Pose::Sleeping {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "SWIMMING" => Ok(Pose::Swimming {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "SPIN_ATTACK" => Ok(Pose::SpinAttack {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "SNEAKING" => Ok(Pose::Sneaking {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "LONG_JUMPING" => Ok(Pose::LongJumping {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "DYING" => Ok(Pose::Dying {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "CROAKING" => Ok(Pose::Croaking {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "USING_TONGUE" => Ok(Pose::UsingTongue {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "SITTING" => Ok(Pose::Sitting {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "ROARING" => Ok(Pose::Roaring {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "SNIFFING" => Ok(Pose::Sniffing {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "EMERGING" => Ok(Pose::Emerging {
                inner: PoseStruct::from_raw(env, obj)?,
            }),
            "DIGGING" => Ok(Pose::Digging {
                inner: PoseStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct PoseStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Pose<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Standing { inner } => inner.0.clone(),
            Self::FallFlying { inner } => inner.0.clone(),
            Self::Sleeping { inner } => inner.0.clone(),
            Self::Swimming { inner } => inner.0.clone(),
            Self::SpinAttack { inner } => inner.0.clone(),
            Self::Sneaking { inner } => inner.0.clone(),
            Self::LongJumping { inner } => inner.0.clone(),
            Self::Dying { inner } => inner.0.clone(),
            Self::Croaking { inner } => inner.0.clone(),
            Self::UsingTongue { inner } => inner.0.clone(),
            Self::Sitting { inner } => inner.0.clone(),
            Self::Roaring { inner } => inner.0.clone(),
            Self::Sniffing { inner } => inner.0.clone(),
            Self::Emerging { inner } => inner.0.clone(),
            Self::Digging { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Standing { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::FallFlying { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Sleeping { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Swimming { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::SpinAttack { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Sneaking { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::LongJumping { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Dying { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Croaking { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::UsingTongue { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Sitting { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Roaring { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Sniffing { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Emerging { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Digging { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Pose<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Pose from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Pose")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Pose object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "STANDING" => Ok(Pose::Standing {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "FALL_FLYING" => Ok(Pose::FallFlying {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "SLEEPING" => Ok(Pose::Sleeping {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "SWIMMING" => Ok(Pose::Swimming {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "SPIN_ATTACK" => Ok(Pose::SpinAttack {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "SNEAKING" => Ok(Pose::Sneaking {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "LONG_JUMPING" => Ok(Pose::LongJumping {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "DYING" => Ok(Pose::Dying {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "CROAKING" => Ok(Pose::Croaking {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "USING_TONGUE" => Ok(Pose::UsingTongue {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "SITTING" => Ok(Pose::Sitting {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "ROARING" => Ok(Pose::Roaring {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "SNIFFING" => Ok(Pose::Sniffing {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "EMERGING" => Ok(Pose::Emerging {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                "DIGGING" => Ok(Pose::Digging {
                    inner: PoseStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for PoseStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for PoseStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate PoseStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Pose")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PoseStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> PoseStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a turtle.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Turtle<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Turtle<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Turtle<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Turtle from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Turtle")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Turtle object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Turtle<'mc> {
    pub fn has_egg(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hasEgg", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn is_laying_egg(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isLayingEgg", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Turtle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Turtle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Turtle::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Turtle<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Turtle into crate::entity::Animals")
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Raider<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Raider<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Raider<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Raider from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Raider")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Raider object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Raider<'mc> {
    pub fn set_raid(
        &self,
        arg0: impl Into<crate::Raid<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Raid;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRaid",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn raid(&self) -> Result<Option<crate::Raid<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Raid;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getRaid", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Raid::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn wave(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getWave", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the raid wave that this raider was spawned as part of.
    pub fn set_wave(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWave",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn patrol_target(
        &self,
    ) -> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/block/Block;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPatrolTarget", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::block::Block::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_patrol_target(
        &self,
        arg0: impl Into<crate::block::Block<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/block/Block;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPatrolTarget",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_patrol_leader(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isPatrolLeader", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether this entity is a patrol leader.
    pub fn set_patrol_leader(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPatrolLeader",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_can_join_raid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isCanJoinRaid", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether this mob can join an active raid.
    pub fn set_can_join_raid(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCanJoinRaid",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn ticks_outside_raid(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksOutsideRaid",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the amount of ticks that this mob has exited the bounds of a village as a raid participant.
    /// <p>This value is considered only when the mob has had no action for 2,400 ticks (according to <a href="LivingEntity.html#getNoActionTicks()"><code>LivingEntity.getNoActionTicks()</code></a>). Once both the no action ticks have reached that value and the ticks outside a raid exceeds 30, the mob will be expelled from the raid.</p>
    pub fn set_ticks_outside_raid(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTicksOutsideRaid",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_celebrating(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isCelebrating", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set whether or not this mob is celebrating a raid victory.
    pub fn set_celebrating(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCelebrating",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn celebration_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCelebrationSound",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Raider<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Raider into crate::entity::Monster")
    }
}
/// Represents an entity designed to only record interactions.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Interaction<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Interaction<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Interaction<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Interaction from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Interaction")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Interaction object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Interaction<'mc> {
    pub fn interaction_width(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getInteractionWidth",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the width of this interaction entity.
    pub fn set_interaction_width(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setInteractionWidth",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn interaction_height(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getInteractionHeight",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the height of this interaction entity.
    pub fn set_interaction_height(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setInteractionHeight",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_responsive(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isResponsive", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if this interaction entity should trigger a response when interacted with.
    pub fn set_responsive(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setResponsive",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn last_attack(
        &self,
    ) -> Result<
        Option<crate::entity::InteractionPreviousInteraction<'mc>>,
        Box<dyn std::error::Error>,
    > {
        let sig = String::from("()Lorg/bukkit/entity/Interaction$PreviousInteraction;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLastAttack", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(
            crate::entity::InteractionPreviousInteraction::from_raw(&self.jni_ref(), unsafe {
                jni::objects::JObject::from_raw(res.l()?.clone())
            })?,
        ))
    }

    pub fn last_interaction(
        &self,
    ) -> Result<
        Option<crate::entity::InteractionPreviousInteraction<'mc>>,
        Box<dyn std::error::Error>,
    > {
        let sig = String::from("()Lorg/bukkit/entity/Interaction$PreviousInteraction;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLastInteraction",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(
            crate::entity::InteractionPreviousInteraction::from_raw(&self.jni_ref(), unsafe {
                jni::objects::JObject::from_raw(res.l()?.clone())
            })?,
        ))
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Interaction::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Interaction<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Interaction into crate::entity::Entity")
    }
}
pub enum Color<'mc> {
    White { inner: ColorStruct<'mc> },
    Creamy { inner: ColorStruct<'mc> },
    Chestnut { inner: ColorStruct<'mc> },
    Brown { inner: ColorStruct<'mc> },
    Black { inner: ColorStruct<'mc> },
    Gray { inner: ColorStruct<'mc> },
    DarkBrown { inner: ColorStruct<'mc> },
}
impl<'mc> std::fmt::Display for Color<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Color::White { .. } => f.write_str("WHITE"),
            Color::Creamy { .. } => f.write_str("CREAMY"),
            Color::Chestnut { .. } => f.write_str("CHESTNUT"),
            Color::Brown { .. } => f.write_str("BROWN"),
            Color::Black { .. } => f.write_str("BLACK"),
            Color::Gray { .. } => f.write_str("GRAY"),
            Color::DarkBrown { .. } => f.write_str("DARK_BROWN"),
        }
    }
}

impl<'mc> Color<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Color<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Color");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Color;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "WHITE" => Ok(Color::White {
                inner: ColorStruct::from_raw(env, obj)?,
            }),
            "CREAMY" => Ok(Color::Creamy {
                inner: ColorStruct::from_raw(env, obj)?,
            }),
            "CHESTNUT" => Ok(Color::Chestnut {
                inner: ColorStruct::from_raw(env, obj)?,
            }),
            "BROWN" => Ok(Color::Brown {
                inner: ColorStruct::from_raw(env, obj)?,
            }),
            "BLACK" => Ok(Color::Black {
                inner: ColorStruct::from_raw(env, obj)?,
            }),
            "GRAY" => Ok(Color::Gray {
                inner: ColorStruct::from_raw(env, obj)?,
            }),
            "DARK_BROWN" => Ok(Color::DarkBrown {
                inner: ColorStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct ColorStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Color<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::White { inner } => inner.0.clone(),
            Self::Creamy { inner } => inner.0.clone(),
            Self::Chestnut { inner } => inner.0.clone(),
            Self::Brown { inner } => inner.0.clone(),
            Self::Black { inner } => inner.0.clone(),
            Self::Gray { inner } => inner.0.clone(),
            Self::DarkBrown { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::White { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Creamy { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Chestnut { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Brown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Black { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Gray { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::DarkBrown { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Color<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Color from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Color")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Color object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "WHITE" => Ok(Color::White {
                    inner: ColorStruct::from_raw(env, obj)?,
                }),
                "CREAMY" => Ok(Color::Creamy {
                    inner: ColorStruct::from_raw(env, obj)?,
                }),
                "CHESTNUT" => Ok(Color::Chestnut {
                    inner: ColorStruct::from_raw(env, obj)?,
                }),
                "BROWN" => Ok(Color::Brown {
                    inner: ColorStruct::from_raw(env, obj)?,
                }),
                "BLACK" => Ok(Color::Black {
                    inner: ColorStruct::from_raw(env, obj)?,
                }),
                "GRAY" => Ok(Color::Gray {
                    inner: ColorStruct::from_raw(env, obj)?,
                }),
                "DARK_BROWN" => Ok(Color::DarkBrown {
                    inner: ColorStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for ColorStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ColorStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ColorStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Color")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ColorStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ColorStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a Piglin Brute.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct PiglinBrute<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for PiglinBrute<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for PiglinBrute<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate PiglinBrute from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/PiglinBrute")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PiglinBrute object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> PiglinBrute<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::PiglinAbstract<'mc>> for PiglinBrute<'mc> {
    fn into(self) -> crate::entity::PiglinAbstract<'mc> {
        crate::entity::PiglinAbstract::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting PiglinBrute into crate::entity::PiglinAbstract")
    }
}
/// A Marker entity, exists only on the server.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Marker<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Marker<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Marker<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Marker from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Marker")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Marker object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Marker<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Marker<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Marker into crate::entity::Entity")
    }
}
/// Represents a phase or action that an Ender Dragon can perform.
pub enum EnderDragonPhase<'mc> {
    Circling { inner: EnderDragonPhaseStruct<'mc> },
    Strafing { inner: EnderDragonPhaseStruct<'mc> },
    FlyToPortal { inner: EnderDragonPhaseStruct<'mc> },
    LandOnPortal { inner: EnderDragonPhaseStruct<'mc> },
    LeavePortal { inner: EnderDragonPhaseStruct<'mc> },
    BreathAttack { inner: EnderDragonPhaseStruct<'mc> },
    SearchForBreathAttackTarget { inner: EnderDragonPhaseStruct<'mc> },
    RoarBeforeAttack { inner: EnderDragonPhaseStruct<'mc> },
    ChargePlayer { inner: EnderDragonPhaseStruct<'mc> },
    Dying { inner: EnderDragonPhaseStruct<'mc> },
    Hover { inner: EnderDragonPhaseStruct<'mc> },
}
impl<'mc> std::fmt::Display for EnderDragonPhase<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EnderDragonPhase::Circling { .. } => f.write_str("CIRCLING"),
            EnderDragonPhase::Strafing { .. } => f.write_str("STRAFING"),
            EnderDragonPhase::FlyToPortal { .. } => f.write_str("FLY_TO_PORTAL"),
            EnderDragonPhase::LandOnPortal { .. } => f.write_str("LAND_ON_PORTAL"),
            EnderDragonPhase::LeavePortal { .. } => f.write_str("LEAVE_PORTAL"),
            EnderDragonPhase::BreathAttack { .. } => f.write_str("BREATH_ATTACK"),
            EnderDragonPhase::SearchForBreathAttackTarget { .. } => {
                f.write_str("SEARCH_FOR_BREATH_ATTACK_TARGET")
            }
            EnderDragonPhase::RoarBeforeAttack { .. } => f.write_str("ROAR_BEFORE_ATTACK"),
            EnderDragonPhase::ChargePlayer { .. } => f.write_str("CHARGE_PLAYER"),
            EnderDragonPhase::Dying { .. } => f.write_str("DYING"),
            EnderDragonPhase::Hover { .. } => f.write_str("HOVER"),
        }
    }
}

impl<'mc> EnderDragonPhase<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<EnderDragonPhase<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/EnderDragon$Phase");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/EnderDragon$Phase;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "CIRCLING" => Ok(EnderDragonPhase::Circling {
                inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
            }),
            "STRAFING" => Ok(EnderDragonPhase::Strafing {
                inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
            }),
            "FLY_TO_PORTAL" => Ok(EnderDragonPhase::FlyToPortal {
                inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
            }),
            "LAND_ON_PORTAL" => Ok(EnderDragonPhase::LandOnPortal {
                inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
            }),
            "LEAVE_PORTAL" => Ok(EnderDragonPhase::LeavePortal {
                inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
            }),
            "BREATH_ATTACK" => Ok(EnderDragonPhase::BreathAttack {
                inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
            }),
            "SEARCH_FOR_BREATH_ATTACK_TARGET" => {
                Ok(EnderDragonPhase::SearchForBreathAttackTarget {
                    inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
                })
            }
            "ROAR_BEFORE_ATTACK" => Ok(EnderDragonPhase::RoarBeforeAttack {
                inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
            }),
            "CHARGE_PLAYER" => Ok(EnderDragonPhase::ChargePlayer {
                inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
            }),
            "DYING" => Ok(EnderDragonPhase::Dying {
                inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
            }),
            "HOVER" => Ok(EnderDragonPhase::Hover {
                inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct EnderDragonPhaseStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EnderDragonPhase<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Circling { inner } => inner.0.clone(),
            Self::Strafing { inner } => inner.0.clone(),
            Self::FlyToPortal { inner } => inner.0.clone(),
            Self::LandOnPortal { inner } => inner.0.clone(),
            Self::LeavePortal { inner } => inner.0.clone(),
            Self::BreathAttack { inner } => inner.0.clone(),
            Self::SearchForBreathAttackTarget { inner } => inner.0.clone(),
            Self::RoarBeforeAttack { inner } => inner.0.clone(),
            Self::ChargePlayer { inner } => inner.0.clone(),
            Self::Dying { inner } => inner.0.clone(),
            Self::Hover { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Circling { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Strafing { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::FlyToPortal { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::LandOnPortal { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::LeavePortal { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BreathAttack { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::SearchForBreathAttackTarget { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::RoarBeforeAttack { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ChargePlayer { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Dying { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Hover { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EnderDragonPhase<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate EnderDragonPhase from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderDragon$Phase")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EnderDragonPhase object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "CIRCLING" => Ok(EnderDragonPhase::Circling {
                    inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
                }),
                "STRAFING" => Ok(EnderDragonPhase::Strafing {
                    inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
                }),
                "FLY_TO_PORTAL" => Ok(EnderDragonPhase::FlyToPortal {
                    inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
                }),
                "LAND_ON_PORTAL" => Ok(EnderDragonPhase::LandOnPortal {
                    inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
                }),
                "LEAVE_PORTAL" => Ok(EnderDragonPhase::LeavePortal {
                    inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
                }),
                "BREATH_ATTACK" => Ok(EnderDragonPhase::BreathAttack {
                    inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
                }),
                "SEARCH_FOR_BREATH_ATTACK_TARGET" => {
                    Ok(EnderDragonPhase::SearchForBreathAttackTarget {
                        inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
                    })
                }
                "ROAR_BEFORE_ATTACK" => Ok(EnderDragonPhase::RoarBeforeAttack {
                    inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
                }),
                "CHARGE_PLAYER" => Ok(EnderDragonPhase::ChargePlayer {
                    inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
                }),
                "DYING" => Ok(EnderDragonPhase::Dying {
                    inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
                }),
                "HOVER" => Ok(EnderDragonPhase::Hover {
                    inner: EnderDragonPhaseStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for EnderDragonPhaseStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EnderDragonPhaseStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate EnderDragonPhaseStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderDragon$Phase")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EnderDragonPhaseStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EnderDragonPhaseStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// What does the fox say?
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Fox<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Fox<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Fox<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Fox from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Fox")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Fox object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Fox<'mc> {
    pub fn fox_type(&self) -> Result<crate::entity::FoxType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Fox$Type;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFoxType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::FoxType::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_fox_type(
        &self,
        arg0: impl Into<crate::entity::FoxType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Fox$Type;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFoxType",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_crouching(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isCrouching", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if this animal is crouching.
    pub fn set_crouching(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCrouching",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets if this animal is sleeping.
    pub fn set_sleeping(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSleeping",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn first_trusted_player(
        &self,
    ) -> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/AnimalTamer;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getFirstTrustedPlayer",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::AnimalTamer::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_first_trusted_player(
        &self,
        arg0: impl Into<crate::entity::AnimalTamer<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFirstTrustedPlayer",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn second_trusted_player(
        &self,
    ) -> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/AnimalTamer;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getSecondTrustedPlayer",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::AnimalTamer::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_second_trusted_player(
        &self,
        arg0: impl Into<crate::entity::AnimalTamer<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSecondTrustedPlayer",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_faceplanted(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isFaceplanted", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Fox::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Fox::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Fox::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn is_sitting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Fox::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Sittable = temp_clone.into();
        real.is_sitting()
    }
    pub fn set_sitting(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Fox::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Sittable = temp_clone.into();
        real.set_sitting(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Fox<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Fox into crate::entity::Animals")
    }
}
impl<'mc> Into<crate::entity::Sittable<'mc>> for Fox<'mc> {
    fn into(self) -> crate::entity::Sittable<'mc> {
        crate::entity::Sittable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Fox into crate::entity::Sittable")
    }
}
/// Represents a large <a href="Fireball.html" title="interface in org.bukkit.entity"><code>Fireball</code></a>
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct LargeFireball<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for LargeFireball<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for LargeFireball<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate LargeFireball from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LargeFireball")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a LargeFireball object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> LargeFireball<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::SizedFireball<'mc>> for LargeFireball<'mc> {
    fn into(self) -> crate::entity::SizedFireball<'mc> {
        crate::entity::SizedFireball::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting LargeFireball into crate::entity::SizedFireball")
    }
}
/// A wild tameable cat
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Ocelot<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Ocelot<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Ocelot<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Ocelot from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ocelot")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Ocelot object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Ocelot<'mc> {
    pub fn cat_type(&self) -> Result<crate::entity::OcelotType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Ocelot$Type;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getCatType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::OcelotType::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_cat_type(
        &self,
        arg0: impl Into<crate::entity::OcelotType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Ocelot$Type;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCatType",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_trusting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isTrusting", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if this ocelot trusts players.
    pub fn set_trusting(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTrusting",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Ocelot::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Ocelot::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Ocelot::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Ocelot<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Ocelot into crate::entity::Animals")
    }
}
/// Drowned zombie.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Drowned<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Drowned<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Drowned<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Drowned from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Drowned")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Drowned object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Drowned<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Zombie<'mc>> for Drowned<'mc> {
    fn into(self) -> crate::entity::Zombie<'mc> {
        crate::entity::Zombie::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Drowned into crate::entity::Zombie")
    }
}
/// Represents the variant of a parrot - ie its color.
pub enum ParrotVariant<'mc> {
    Red { inner: ParrotVariantStruct<'mc> },
    Blue { inner: ParrotVariantStruct<'mc> },
    Green { inner: ParrotVariantStruct<'mc> },
    Cyan { inner: ParrotVariantStruct<'mc> },
    Gray { inner: ParrotVariantStruct<'mc> },
}
impl<'mc> std::fmt::Display for ParrotVariant<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ParrotVariant::Red { .. } => f.write_str("RED"),
            ParrotVariant::Blue { .. } => f.write_str("BLUE"),
            ParrotVariant::Green { .. } => f.write_str("GREEN"),
            ParrotVariant::Cyan { .. } => f.write_str("CYAN"),
            ParrotVariant::Gray { .. } => f.write_str("GRAY"),
        }
    }
}

impl<'mc> ParrotVariant<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<ParrotVariant<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Parrot$Variant");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Parrot$Variant;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "RED" => Ok(ParrotVariant::Red {
                inner: ParrotVariantStruct::from_raw(env, obj)?,
            }),
            "BLUE" => Ok(ParrotVariant::Blue {
                inner: ParrotVariantStruct::from_raw(env, obj)?,
            }),
            "GREEN" => Ok(ParrotVariant::Green {
                inner: ParrotVariantStruct::from_raw(env, obj)?,
            }),
            "CYAN" => Ok(ParrotVariant::Cyan {
                inner: ParrotVariantStruct::from_raw(env, obj)?,
            }),
            "GRAY" => Ok(ParrotVariant::Gray {
                inner: ParrotVariantStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct ParrotVariantStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ParrotVariant<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Red { inner } => inner.0.clone(),
            Self::Blue { inner } => inner.0.clone(),
            Self::Green { inner } => inner.0.clone(),
            Self::Cyan { inner } => inner.0.clone(),
            Self::Gray { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Red { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Blue { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Green { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cyan { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Gray { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ParrotVariant<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ParrotVariant from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Parrot$Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ParrotVariant object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "RED" => Ok(ParrotVariant::Red {
                    inner: ParrotVariantStruct::from_raw(env, obj)?,
                }),
                "BLUE" => Ok(ParrotVariant::Blue {
                    inner: ParrotVariantStruct::from_raw(env, obj)?,
                }),
                "GREEN" => Ok(ParrotVariant::Green {
                    inner: ParrotVariantStruct::from_raw(env, obj)?,
                }),
                "CYAN" => Ok(ParrotVariant::Cyan {
                    inner: ParrotVariantStruct::from_raw(env, obj)?,
                }),
                "GRAY" => Ok(ParrotVariant::Gray {
                    inner: ParrotVariantStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for ParrotVariantStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ParrotVariantStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ParrotVariantStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Parrot$Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ParrotVariantStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ParrotVariantStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents an Enderman.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Enderman<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Enderman<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Enderman<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Enderman from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Enderman")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Enderman object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Enderman<'mc> {
    pub fn teleport(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn carried_material(
        &self,
    ) -> Result<crate::material::MaterialData<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/material/MaterialData;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCarriedMaterial",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::material::MaterialData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_carried_material(
        &self,
        arg0: impl Into<crate::material::MaterialData<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/material/MaterialData;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCarriedMaterial",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn carried_block(
        &self,
    ) -> Result<Option<crate::block::data::BlockData<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/block/data/BlockData;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getCarriedBlock", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::block::data::BlockData::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_carried_block(
        &self,
        arg0: impl Into<crate::block::data::BlockData<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/block/data/BlockData;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCarriedBlock",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn teleport_towards(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "teleportTowards",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Enderman<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Enderman into crate::entity::Monster")
    }
}
/// Represents a thrown Experience bottle.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ThrownExpBottle<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ThrownExpBottle<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ThrownExpBottle<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ThrownExpBottle from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ThrownExpBottle")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ThrownExpBottle object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ThrownExpBottle<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::ThrowableProjectile<'mc>> for ThrownExpBottle<'mc> {
    fn into(self) -> crate::entity::ThrowableProjectile<'mc> {
        crate::entity::ThrowableProjectile::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ThrownExpBottle into crate::entity::ThrowableProjectile")
    }
}
/// An Allay.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Allay<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Allay<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Allay<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Allay from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Allay")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Allay object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Allay<'mc> {
    pub fn duplication_cooldown(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDuplicationCooldown",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }

    pub fn can_duplicate(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "canDuplicate", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if the allay can duplicate.
    ///
    /// <b>Note:</b> this value can be overridden later by <a href="#getDuplicationCooldown()"><code>getDuplicationCooldown()</code></a> if is lower than zero. You can also use <a href="#setDuplicationCooldown(long)"><code>setDuplicationCooldown(long)</code></a> to allow the allay to duplicate
    pub fn set_can_duplicate(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCanDuplicate",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets the cooldown before the allay can duplicate again.
    pub fn set_duplication_cooldown(&self, arg0: i64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(J)V");
        let val_1 = jni::objects::JValueGen::Long(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDuplicationCooldown",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn reset_duplication_cooldown(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "resetDuplicationCooldown",
            sig.as_str(),
            vec![],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_dancing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isDancing", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn start_dancing_with_location(
        &self,
        arg0: std::option::Option<impl Into<crate::Location<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = arg0 {
            sig += "Lorg/bukkit/Location;";
            let val_1 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_1);
        }
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "startDancing", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn stop_dancing(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "stopDancing", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn duplicate_allay(
        &self,
    ) -> Result<Option<crate::entity::Allay<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Allay;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "duplicateAllay", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Allay::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn jukebox(&self) -> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getJukebox", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    pub fn inventory(
        &self,
    ) -> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Allay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::inventory::InventoryHolder = temp_clone.into();
        real.inventory()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Creature<'mc>> for Allay<'mc> {
    fn into(self) -> crate::entity::Creature<'mc> {
        crate::entity::Creature::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Allay into crate::entity::Creature")
    }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for Allay<'mc> {
    fn into(self) -> crate::inventory::InventoryHolder<'mc> {
        crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Allay into crate::inventory::InventoryHolder")
    }
}
pub enum AngerLevel<'mc> {
    Calm { inner: AngerLevelStruct<'mc> },
    Agitated { inner: AngerLevelStruct<'mc> },
    Angry { inner: AngerLevelStruct<'mc> },
}
impl<'mc> std::fmt::Display for AngerLevel<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AngerLevel::Calm { .. } => f.write_str("CALM"),
            AngerLevel::Agitated { .. } => f.write_str("AGITATED"),
            AngerLevel::Angry { .. } => f.write_str("ANGRY"),
        }
    }
}

impl<'mc> AngerLevel<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<AngerLevel<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/AngerLevel");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/AngerLevel;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "CALM" => Ok(AngerLevel::Calm {
                inner: AngerLevelStruct::from_raw(env, obj)?,
            }),
            "AGITATED" => Ok(AngerLevel::Agitated {
                inner: AngerLevelStruct::from_raw(env, obj)?,
            }),
            "ANGRY" => Ok(AngerLevel::Angry {
                inner: AngerLevelStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct AngerLevelStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for AngerLevel<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Calm { inner } => inner.0.clone(),
            Self::Agitated { inner } => inner.0.clone(),
            Self::Angry { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Calm { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Agitated { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Angry { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for AngerLevel<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate AngerLevel from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AngerLevel")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a AngerLevel object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "CALM" => Ok(AngerLevel::Calm {
                    inner: AngerLevelStruct::from_raw(env, obj)?,
                }),
                "AGITATED" => Ok(AngerLevel::Agitated {
                    inner: AngerLevelStruct::from_raw(env, obj)?,
                }),
                "ANGRY" => Ok(AngerLevel::Angry {
                    inner: AngerLevelStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for AngerLevelStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for AngerLevelStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate AngerLevelStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AngerLevel")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a AngerLevelStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> AngerLevelStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a non-player character
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct NPC<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for NPC<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for NPC<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate NPC from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/NPC")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a NPC object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> NPC<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Creature<'mc>> for NPC<'mc> {
    fn into(self) -> crate::entity::Creature<'mc> {
        crate::entity::Creature::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting NPC into crate::entity::Creature")
    }
}
/// Represents a Stray - variant of <a title="interface in org.bukkit.entity" href="AbstractSkeleton.html"><code>AbstractSkeleton</code></a>.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Stray<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Stray<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Stray<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Stray from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Stray")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Stray object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Stray<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::AbstractSkeleton<'mc>> for Stray<'mc> {
    fn into(self) -> crate::entity::AbstractSkeleton<'mc> {
        crate::entity::AbstractSkeleton::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Stray into crate::entity::AbstractSkeleton")
    }
}
/// Represents the various different cat types there are.
pub enum CatType<'mc> {
    Tabby { inner: CatTypeStruct<'mc> },
    Black { inner: CatTypeStruct<'mc> },
    Red { inner: CatTypeStruct<'mc> },
    Siamese { inner: CatTypeStruct<'mc> },
    BritishShorthair { inner: CatTypeStruct<'mc> },
    Calico { inner: CatTypeStruct<'mc> },
    Persian { inner: CatTypeStruct<'mc> },
    Ragdoll { inner: CatTypeStruct<'mc> },
    White { inner: CatTypeStruct<'mc> },
    Jellie { inner: CatTypeStruct<'mc> },
    AllBlack { inner: CatTypeStruct<'mc> },
}
impl<'mc> std::fmt::Display for CatType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CatType::Tabby { .. } => f.write_str("TABBY"),
            CatType::Black { .. } => f.write_str("BLACK"),
            CatType::Red { .. } => f.write_str("RED"),
            CatType::Siamese { .. } => f.write_str("SIAMESE"),
            CatType::BritishShorthair { .. } => f.write_str("BRITISH_SHORTHAIR"),
            CatType::Calico { .. } => f.write_str("CALICO"),
            CatType::Persian { .. } => f.write_str("PERSIAN"),
            CatType::Ragdoll { .. } => f.write_str("RAGDOLL"),
            CatType::White { .. } => f.write_str("WHITE"),
            CatType::Jellie { .. } => f.write_str("JELLIE"),
            CatType::AllBlack { .. } => f.write_str("ALL_BLACK"),
        }
    }
}

impl<'mc> CatType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<CatType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Cat$Type");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Cat$Type;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "TABBY" => Ok(CatType::Tabby {
                inner: CatTypeStruct::from_raw(env, obj)?,
            }),
            "BLACK" => Ok(CatType::Black {
                inner: CatTypeStruct::from_raw(env, obj)?,
            }),
            "RED" => Ok(CatType::Red {
                inner: CatTypeStruct::from_raw(env, obj)?,
            }),
            "SIAMESE" => Ok(CatType::Siamese {
                inner: CatTypeStruct::from_raw(env, obj)?,
            }),
            "BRITISH_SHORTHAIR" => Ok(CatType::BritishShorthair {
                inner: CatTypeStruct::from_raw(env, obj)?,
            }),
            "CALICO" => Ok(CatType::Calico {
                inner: CatTypeStruct::from_raw(env, obj)?,
            }),
            "PERSIAN" => Ok(CatType::Persian {
                inner: CatTypeStruct::from_raw(env, obj)?,
            }),
            "RAGDOLL" => Ok(CatType::Ragdoll {
                inner: CatTypeStruct::from_raw(env, obj)?,
            }),
            "WHITE" => Ok(CatType::White {
                inner: CatTypeStruct::from_raw(env, obj)?,
            }),
            "JELLIE" => Ok(CatType::Jellie {
                inner: CatTypeStruct::from_raw(env, obj)?,
            }),
            "ALL_BLACK" => Ok(CatType::AllBlack {
                inner: CatTypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct CatTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for CatType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Tabby { inner } => inner.0.clone(),
            Self::Black { inner } => inner.0.clone(),
            Self::Red { inner } => inner.0.clone(),
            Self::Siamese { inner } => inner.0.clone(),
            Self::BritishShorthair { inner } => inner.0.clone(),
            Self::Calico { inner } => inner.0.clone(),
            Self::Persian { inner } => inner.0.clone(),
            Self::Ragdoll { inner } => inner.0.clone(),
            Self::White { inner } => inner.0.clone(),
            Self::Jellie { inner } => inner.0.clone(),
            Self::AllBlack { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Tabby { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Black { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Red { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Siamese { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::BritishShorthair { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Calico { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Persian { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Ragdoll { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::White { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Jellie { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::AllBlack { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for CatType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate CatType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Cat$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a CatType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "TABBY" => Ok(CatType::Tabby {
                    inner: CatTypeStruct::from_raw(env, obj)?,
                }),
                "BLACK" => Ok(CatType::Black {
                    inner: CatTypeStruct::from_raw(env, obj)?,
                }),
                "RED" => Ok(CatType::Red {
                    inner: CatTypeStruct::from_raw(env, obj)?,
                }),
                "SIAMESE" => Ok(CatType::Siamese {
                    inner: CatTypeStruct::from_raw(env, obj)?,
                }),
                "BRITISH_SHORTHAIR" => Ok(CatType::BritishShorthair {
                    inner: CatTypeStruct::from_raw(env, obj)?,
                }),
                "CALICO" => Ok(CatType::Calico {
                    inner: CatTypeStruct::from_raw(env, obj)?,
                }),
                "PERSIAN" => Ok(CatType::Persian {
                    inner: CatTypeStruct::from_raw(env, obj)?,
                }),
                "RAGDOLL" => Ok(CatType::Ragdoll {
                    inner: CatTypeStruct::from_raw(env, obj)?,
                }),
                "WHITE" => Ok(CatType::White {
                    inner: CatTypeStruct::from_raw(env, obj)?,
                }),
                "JELLIE" => Ok(CatType::Jellie {
                    inner: CatTypeStruct::from_raw(env, obj)?,
                }),
                "ALL_BLACK" => Ok(CatType::AllBlack {
                    inner: CatTypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for CatTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for CatTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate CatTypeStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Cat$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a CatTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> CatTypeStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a Silverfish.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Silverfish<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Silverfish<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Silverfish<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Silverfish from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Silverfish")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Silverfish object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Silverfish<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Silverfish<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Silverfish into crate::entity::Monster")
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ArmorStand<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ArmorStand<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ArmorStand<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ArmorStand from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ArmorStand")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ArmorStand object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ArmorStand<'mc> {
    pub fn is_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isVisible", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the armor stand should be visible or not.
    pub fn set_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVisible",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets whether this armor stand is scaled down.
    pub fn set_small(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSmall",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_marker(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isMarker", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether this armor stand is a marker, meaning it has a very small collision box.
    pub fn set_marker(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMarker",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn add_equipment_lock(
        &self,
        arg0: impl Into<crate::inventory::EquipmentSlot<'mc>>,
        arg1: impl Into<crate::entity::ArmorStandLockType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from(
            "(Lorg/bukkit/inventory/EquipmentSlot;Lorg/bukkit/entity/ArmorStand$LockType;)V",
        );
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg1.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "addEquipmentLock",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn remove_equipment_lock(
        &self,
        arg0: impl Into<crate::inventory::EquipmentSlot<'mc>>,
        arg1: impl Into<crate::entity::ArmorStandLockType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from(
            "(Lorg/bukkit/inventory/EquipmentSlot;Lorg/bukkit/entity/ArmorStand$LockType;)V",
        );
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg1.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removeEquipmentLock",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn has_equipment_lock(
        &self,
        arg0: impl Into<crate::inventory::EquipmentSlot<'mc>>,
        arg1: impl Into<crate::entity::ArmorStandLockType<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from(
            "(Lorg/bukkit/inventory/EquipmentSlot;Lorg/bukkit/entity/ArmorStand$LockType;)Z",
        );
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg1.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasEquipmentLock",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]

    pub fn item_in_hand(
        &self,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getItemInHand", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_item_in_hand(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setItemInHand",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn boots(&self) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBoots", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_boots(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBoots",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn leggings(&self) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLeggings", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_leggings(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLeggings",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn chestplate(
        &self,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getChestplate", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_chestplate(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setChestplate",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn helmet(&self) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getHelmet", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_helmet(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setHelmet",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn body_pose(&self) -> Result<crate::util::EulerAngle<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/EulerAngle;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBodyPose", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::EulerAngle::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_body_pose(
        &self,
        arg0: impl Into<crate::util::EulerAngle<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/EulerAngle;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBodyPose",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn left_arm_pose(
        &self,
    ) -> Result<crate::util::EulerAngle<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/EulerAngle;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLeftArmPose", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::EulerAngle::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_left_arm_pose(
        &self,
        arg0: impl Into<crate::util::EulerAngle<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/EulerAngle;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLeftArmPose",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn right_arm_pose(
        &self,
    ) -> Result<crate::util::EulerAngle<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/EulerAngle;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getRightArmPose", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::EulerAngle::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_right_arm_pose(
        &self,
        arg0: impl Into<crate::util::EulerAngle<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/EulerAngle;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRightArmPose",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn left_leg_pose(
        &self,
    ) -> Result<crate::util::EulerAngle<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/EulerAngle;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLeftLegPose", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::EulerAngle::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_left_leg_pose(
        &self,
        arg0: impl Into<crate::util::EulerAngle<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/EulerAngle;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLeftLegPose",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn right_leg_pose(
        &self,
    ) -> Result<crate::util::EulerAngle<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/EulerAngle;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getRightLegPose", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::EulerAngle::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_right_leg_pose(
        &self,
        arg0: impl Into<crate::util::EulerAngle<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/EulerAngle;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRightLegPose",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn head_pose(&self) -> Result<crate::util::EulerAngle<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/EulerAngle;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getHeadPose", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::EulerAngle::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_head_pose(
        &self,
        arg0: impl Into<crate::util::EulerAngle<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/EulerAngle;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setHeadPose",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn has_base_plate(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "hasBasePlate", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the armor stand has a base plate.
    pub fn set_base_plate(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBasePlate",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn has_arms(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hasArms", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether this armor stand has arms.
    pub fn set_arms(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setArms",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_small(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isSmall", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn maximum_no_damage_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaximumNoDamageTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_arrows_in_body(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_arrows_in_body(arg0)
    }
    pub fn get_eye_height(&self, arg0: bool) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_eye_height(arg0)
    }
    pub fn eye_location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.eye_location()
    }
    pub fn get_line_of_sight(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<Vec<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_line_of_sight(arg0, arg1)
    }
    pub fn get_target_block(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_target_block(arg0, arg1)
    }
    pub fn get_last_two_target_blocks(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<Vec<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/Set;I)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLastTwoTargetBlocks",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::block::Block::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn get_target_block_exact_with_int(
        &self,
        arg0: i32,
        arg1: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>,
    ) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/FluidCollisionMode;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/block/Block;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTargetBlockExact",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Block::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn ray_trace_blocks_with_double(
        &self,
        arg0: f64,
        arg1: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>,
    ) -> Result<crate::util::RayTraceResult<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "D";
        let val_1 = jni::objects::JValueGen::Double(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/FluidCollisionMode;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/util/RayTraceResult;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "rayTraceBlocks", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::RayTraceResult::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn remaining_air(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.remaining_air()
    }
    pub fn set_remaining_air(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_remaining_air(arg0)
    }
    pub fn maximum_air(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.maximum_air()
    }
    pub fn set_maximum_air(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_maximum_air(arg0)
    }
    pub fn arrow_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.arrow_cooldown()
    }
    pub fn set_arrow_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_arrow_cooldown(arg0)
    }
    pub fn arrows_in_body(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.arrows_in_body()
    }
    pub fn set_maximum_no_damage_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaximumNoDamageTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn last_damage(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.last_damage()
    }
    pub fn set_last_damage(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_last_damage(arg0)
    }
    pub fn no_damage_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNoDamageTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_no_damage_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setNoDamageTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn no_action_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNoActionTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_no_action_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setNoActionTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn killer(&self) -> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.killer()
    }
    pub fn add_potion_effect_with_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffect<'mc>>,
        arg1: std::option::Option<bool>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/potion/PotionEffect;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Z";
            let val_2 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_2);
        }
        sig += ")Z";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "addPotionEffect", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn has_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasPotionEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn get_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<crate::potion::PotionEffect<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_potion_effect(arg0)
    }
    pub fn remove_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.remove_potion_effect(arg0)
    }
    pub fn active_potion_effects(
        &self,
    ) -> Result<Vec<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getActivePotionEffects",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::potion::PotionEffect::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn has_line_of_sight(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.has_line_of_sight(arg0)
    }
    pub fn remove_when_far_away(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.remove_when_far_away()
    }
    pub fn set_remove_when_far_away(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_remove_when_far_away(arg0)
    }
    pub fn equipment(
        &self,
    ) -> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.equipment()
    }
    pub fn set_can_pickup_items(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCanPickupItems",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn can_pickup_items(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCanPickupItems",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn is_leashed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_leashed()
    }
    pub fn leash_holder(&self) -> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.leash_holder()
    }
    pub fn set_leash_holder(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_leash_holder(arg0)
    }
    pub fn is_gliding(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_gliding()
    }
    pub fn set_gliding(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_gliding(arg0)
    }
    pub fn is_swimming(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_swimming()
    }
    pub fn set_swimming(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_swimming(arg0)
    }
    pub fn is_riptiding(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_riptiding()
    }
    pub fn is_sleeping(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_sleeping()
    }
    pub fn is_climbing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_climbing()
    }
    pub fn set_ai(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_ai(arg0)
    }
    pub fn has_ai(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.has_ai()
    }
    pub fn attack(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.attack(arg0)
    }
    pub fn swing_main_hand(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.swing_main_hand()
    }
    pub fn swing_off_hand(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.swing_off_hand()
    }
    pub fn play_hurt_animation(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.play_hurt_animation(arg0)
    }
    pub fn set_collidable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_collidable(arg0)
    }
    pub fn is_collidable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_collidable()
    }
    pub fn collidable_exemptions(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCollidableExemptions",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn get_memory(
        &self,
        arg0: impl Into<crate::entity::memory::MemoryKey<'mc>>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_memory(arg0)
    }
    pub fn hurt_sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.hurt_sound()
    }
    pub fn death_sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.death_sound()
    }
    pub fn get_fall_damage_sound(
        &self,
        arg0: i32,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_fall_damage_sound(arg0)
    }
    pub fn fall_damage_sound_small(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.fall_damage_sound_small()
    }
    pub fn fall_damage_sound_big(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.fall_damage_sound_big()
    }
    pub fn get_drinking_sound(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_drinking_sound(arg0)
    }
    pub fn get_eating_sound(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_eating_sound(arg0)
    }
    pub fn can_breathe_underwater(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.can_breathe_underwater()
    }
    pub fn category(
        &self,
    ) -> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.category()
    }
    pub fn set_invisible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_invisible(arg0)
    }
    pub fn is_invisible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_invisible()
    }
    pub fn set_memory(
        &self,
        arg0: impl Into<crate::entity::memory::MemoryKey<'mc>>,
        arg1: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ArmorStand::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_memory(arg0, arg1)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::LivingEntity<'mc>> for ArmorStand<'mc> {
    fn into(self) -> crate::entity::LivingEntity<'mc> {
        crate::entity::LivingEntity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ArmorStand into crate::entity::LivingEntity")
    }
}
/// A legacy enum that defines the different variances of skeleton-like entities on the server.
pub enum SkeletonSkeletonType<'mc> {
    Normal {
        inner: SkeletonSkeletonTypeStruct<'mc>,
    },
    Wither {
        inner: SkeletonSkeletonTypeStruct<'mc>,
    },
    Stray {
        inner: SkeletonSkeletonTypeStruct<'mc>,
    },
}
impl<'mc> std::fmt::Display for SkeletonSkeletonType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SkeletonSkeletonType::Normal { .. } => f.write_str("NORMAL"),
            SkeletonSkeletonType::Wither { .. } => f.write_str("WITHER"),
            SkeletonSkeletonType::Stray { .. } => f.write_str("STRAY"),
        }
    }
}

impl<'mc> SkeletonSkeletonType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<SkeletonSkeletonType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Skeleton$SkeletonType");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Skeleton$SkeletonType;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NORMAL" => Ok(SkeletonSkeletonType::Normal {
                inner: SkeletonSkeletonTypeStruct::from_raw(env, obj)?,
            }),
            "WITHER" => Ok(SkeletonSkeletonType::Wither {
                inner: SkeletonSkeletonTypeStruct::from_raw(env, obj)?,
            }),
            "STRAY" => Ok(SkeletonSkeletonType::Stray {
                inner: SkeletonSkeletonTypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct SkeletonSkeletonTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SkeletonSkeletonType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Normal { inner } => inner.0.clone(),
            Self::Wither { inner } => inner.0.clone(),
            Self::Stray { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Normal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Wither { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Stray { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SkeletonSkeletonType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate SkeletonSkeletonType from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Skeleton$SkeletonType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SkeletonSkeletonType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NORMAL" => Ok(SkeletonSkeletonType::Normal {
                    inner: SkeletonSkeletonTypeStruct::from_raw(env, obj)?,
                }),
                "WITHER" => Ok(SkeletonSkeletonType::Wither {
                    inner: SkeletonSkeletonTypeStruct::from_raw(env, obj)?,
                }),
                "STRAY" => Ok(SkeletonSkeletonType::Stray {
                    inner: SkeletonSkeletonTypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for SkeletonSkeletonTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SkeletonSkeletonTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate SkeletonSkeletonTypeStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Skeleton$SkeletonType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SkeletonSkeletonTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SkeletonSkeletonTypeStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a spell casting "Illager".
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Spellcaster<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Spellcaster<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Spellcaster<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Spellcaster from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Spellcaster")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Spellcaster object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Spellcaster<'mc> {
    pub fn spell(
        &self,
    ) -> Result<crate::entity::SpellcasterSpell<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Spellcaster$Spell;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getSpell", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::SpellcasterSpell::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_spell(
        &self,
        arg0: impl Into<crate::entity::SpellcasterSpell<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Spellcaster$Spell;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSpell",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Illager<'mc>> for Spellcaster<'mc> {
    fn into(self) -> crate::entity::Illager<'mc> {
        crate::entity::Illager::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Spellcaster into crate::entity::Illager")
    }
}
/// Represents a Leash Hitch on a fence
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct LeashHitch<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for LeashHitch<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for LeashHitch<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate LeashHitch from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LeashHitch")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a LeashHitch object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> LeashHitch<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Hanging<'mc>> for LeashHitch<'mc> {
    fn into(self) -> crate::entity::Hanging<'mc> {
        crate::entity::Hanging::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting LeashHitch into crate::entity::Hanging")
    }
}
/// Represents a Skeleton.
/// <p>This interface only represents the normal skeleton type on the server. Other skeleton-like entities, such as the <a href="WitherSkeleton.html" title="interface in org.bukkit.entity"><code>WitherSkeleton</code></a> or the <a href="Stray.html" title="interface in org.bukkit.entity"><code>Stray</code></a> are not related to this type.</p>
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Skeleton<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Skeleton<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Skeleton<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Skeleton from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Skeleton")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Skeleton object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Skeleton<'mc> {
    pub fn is_converting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isConverting", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn conversion_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getConversionTime",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the amount of ticks until this entity will be converted to a stray as a result of being frozen by a powdered snow block.
    /// <p>When this reaches 0, the entity will be converted. A value of less than 0 will stop the current conversion process without converting the current entity.</p>
    pub fn set_conversion_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setConversionTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn skeleton_type(
        &self,
    ) -> Result<crate::entity::SkeletonSkeletonType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Skeleton::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractSkeleton = temp_clone.into();
        real.skeleton_type()
    }
    pub fn set_skeleton_type(
        &self,
        arg0: impl Into<crate::entity::SkeletonSkeletonType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Skeleton::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractSkeleton = temp_clone.into();
        real.set_skeleton_type(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::AbstractSkeleton<'mc>> for Skeleton<'mc> {
    fn into(self) -> crate::entity::AbstractSkeleton<'mc> {
        crate::entity::AbstractSkeleton::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Skeleton into crate::entity::AbstractSkeleton")
    }
}
/// Represents a small <a href="Fireball.html" title="interface in org.bukkit.entity"><code>Fireball</code></a>
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct SmallFireball<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SmallFireball<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SmallFireball<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SmallFireball from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SmallFireball")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SmallFireball object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SmallFireball<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::SizedFireball<'mc>> for SmallFireball<'mc> {
    fn into(self) -> crate::entity::SizedFireball<'mc> {
        crate::entity::SizedFireball::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting SmallFireball into crate::entity::SizedFireball")
    }
}
/// Represents a SkeletonHorse - variant of <a href="AbstractHorse.html" title="interface in org.bukkit.entity"><code>AbstractHorse</code></a>.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct SkeletonHorse<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SkeletonHorse<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SkeletonHorse<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SkeletonHorse from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SkeletonHorse")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SkeletonHorse object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SkeletonHorse<'mc> {
    /// Sets the trap time for the horse. Values greater than 18000 will cause the horse to despawn on the next tick.
    pub fn set_trap_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTrapTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_trapped(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isTrapped", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if this skeleton horse is trapped.
    pub fn set_trapped(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTrapped",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn trap_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getTrapTime", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn variant(&self) -> Result<crate::entity::HorseVariant<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = SkeletonHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.variant()
    }
    pub fn inventory(
        &self,
    ) -> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = SkeletonHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.inventory()
    }
    pub fn set_variant(
        &self,
        arg0: impl Into<crate::entity::HorseVariant<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = SkeletonHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_variant(arg0)
    }
    pub fn domestication(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = SkeletonHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.domestication()
    }
    pub fn set_domestication(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = SkeletonHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_domestication(arg0)
    }
    pub fn max_domestication(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = SkeletonHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.max_domestication()
    }
    pub fn set_max_domestication(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = SkeletonHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_max_domestication(arg0)
    }
    pub fn jump_strength(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = SkeletonHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.jump_strength()
    }
    pub fn set_jump_strength(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = SkeletonHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_jump_strength(arg0)
    }
    pub fn is_eating_haystack(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = SkeletonHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.is_eating_haystack()
    }
    pub fn set_eating_haystack(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = SkeletonHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_eating_haystack(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::AbstractHorse<'mc>> for SkeletonHorse<'mc> {
    fn into(self) -> crate::entity::AbstractHorse<'mc> {
        crate::entity::AbstractHorse::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting SkeletonHorse into crate::entity::AbstractHorse")
    }
}
/// Represents a polar bear.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct PolarBear<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for PolarBear<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for PolarBear<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate PolarBear from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/PolarBear")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PolarBear object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> PolarBear<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for PolarBear<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting PolarBear into crate::entity::Animals")
    }
}
/// Represents a Mob. Mobs are living entities with simple AI.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Mob<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Mob<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Mob<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Mob from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Mob")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Mob object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Mob<'mc> {
    /// Sets whether this mob is aware of its surroundings. Unaware mobs will still move if pushed, attacked, etc. but will not move or perform any actions on their own. Unaware mobs may also have other unspecified behaviours disabled, such as drowning.
    pub fn set_aware(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAware",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_aware(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isAware", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn ambient_sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getAmbientSound", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn target(
        &self,
    ) -> Result<Option<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/LivingEntity;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getTarget", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::LivingEntity::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_target(
        &self,
        arg0: impl Into<crate::entity::LivingEntity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/LivingEntity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTarget",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn maximum_no_damage_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaximumNoDamageTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_arrows_in_body(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_arrows_in_body(arg0)
    }
    pub fn get_eye_height(&self, arg0: bool) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_eye_height(arg0)
    }
    pub fn eye_location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.eye_location()
    }
    pub fn get_line_of_sight(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<Vec<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_line_of_sight(arg0, arg1)
    }
    pub fn get_target_block(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_target_block(arg0, arg1)
    }
    pub fn get_last_two_target_blocks(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<Vec<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/Set;I)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLastTwoTargetBlocks",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::block::Block::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn get_target_block_exact_with_int(
        &self,
        arg0: i32,
        arg1: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>,
    ) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/FluidCollisionMode;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/block/Block;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTargetBlockExact",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Block::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn ray_trace_blocks_with_double(
        &self,
        arg0: f64,
        arg1: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>,
    ) -> Result<crate::util::RayTraceResult<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "D";
        let val_1 = jni::objects::JValueGen::Double(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/FluidCollisionMode;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/util/RayTraceResult;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "rayTraceBlocks", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::RayTraceResult::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn remaining_air(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.remaining_air()
    }
    pub fn set_remaining_air(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_remaining_air(arg0)
    }
    pub fn maximum_air(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.maximum_air()
    }
    pub fn set_maximum_air(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_maximum_air(arg0)
    }
    pub fn arrow_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.arrow_cooldown()
    }
    pub fn set_arrow_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_arrow_cooldown(arg0)
    }
    pub fn arrows_in_body(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.arrows_in_body()
    }
    pub fn set_maximum_no_damage_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaximumNoDamageTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn last_damage(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.last_damage()
    }
    pub fn set_last_damage(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_last_damage(arg0)
    }
    pub fn no_damage_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNoDamageTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_no_damage_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setNoDamageTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn no_action_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNoActionTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_no_action_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setNoActionTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn killer(&self) -> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.killer()
    }
    pub fn add_potion_effect_with_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffect<'mc>>,
        arg1: std::option::Option<bool>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/potion/PotionEffect;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Z";
            let val_2 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_2);
        }
        sig += ")Z";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "addPotionEffect", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn has_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasPotionEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn get_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<crate::potion::PotionEffect<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_potion_effect(arg0)
    }
    pub fn remove_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.remove_potion_effect(arg0)
    }
    pub fn active_potion_effects(
        &self,
    ) -> Result<Vec<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getActivePotionEffects",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::potion::PotionEffect::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn has_line_of_sight(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.has_line_of_sight(arg0)
    }
    pub fn remove_when_far_away(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.remove_when_far_away()
    }
    pub fn set_remove_when_far_away(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_remove_when_far_away(arg0)
    }
    pub fn equipment(
        &self,
    ) -> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.equipment()
    }
    pub fn set_can_pickup_items(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCanPickupItems",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn can_pickup_items(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCanPickupItems",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn is_leashed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_leashed()
    }
    pub fn leash_holder(&self) -> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.leash_holder()
    }
    pub fn set_leash_holder(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_leash_holder(arg0)
    }
    pub fn is_gliding(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_gliding()
    }
    pub fn set_gliding(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_gliding(arg0)
    }
    pub fn is_swimming(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_swimming()
    }
    pub fn set_swimming(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_swimming(arg0)
    }
    pub fn is_riptiding(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_riptiding()
    }
    pub fn is_sleeping(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_sleeping()
    }
    pub fn is_climbing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_climbing()
    }
    pub fn set_ai(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_ai(arg0)
    }
    pub fn has_ai(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.has_ai()
    }
    pub fn attack(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.attack(arg0)
    }
    pub fn swing_main_hand(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.swing_main_hand()
    }
    pub fn swing_off_hand(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.swing_off_hand()
    }
    pub fn play_hurt_animation(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.play_hurt_animation(arg0)
    }
    pub fn set_collidable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_collidable(arg0)
    }
    pub fn is_collidable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_collidable()
    }
    pub fn collidable_exemptions(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCollidableExemptions",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn get_memory(
        &self,
        arg0: impl Into<crate::entity::memory::MemoryKey<'mc>>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_memory(arg0)
    }
    pub fn hurt_sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.hurt_sound()
    }
    pub fn death_sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.death_sound()
    }
    pub fn get_fall_damage_sound(
        &self,
        arg0: i32,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_fall_damage_sound(arg0)
    }
    pub fn fall_damage_sound_small(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.fall_damage_sound_small()
    }
    pub fn fall_damage_sound_big(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.fall_damage_sound_big()
    }
    pub fn get_drinking_sound(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_drinking_sound(arg0)
    }
    pub fn get_eating_sound(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_eating_sound(arg0)
    }
    pub fn can_breathe_underwater(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.can_breathe_underwater()
    }
    pub fn category(
        &self,
    ) -> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.category()
    }
    pub fn set_invisible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_invisible(arg0)
    }
    pub fn is_invisible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_invisible()
    }
    pub fn set_memory(
        &self,
        arg0: impl Into<crate::entity::memory::MemoryKey<'mc>>,
        arg1: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_memory(arg0, arg1)
    }
    pub fn seed(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::loot::Lootable = temp_clone.into();
        real.seed()
    }
    pub fn set_seed(&self, arg0: i64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::loot::Lootable = temp_clone.into();
        real.set_seed(arg0)
    }
    pub fn set_loot_table(
        &self,
        arg0: impl Into<crate::loot::LootTable<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::loot::Lootable = temp_clone.into();
        real.set_loot_table(arg0)
    }
    pub fn loot_table(
        &self,
    ) -> Result<Option<crate::loot::LootTable<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Mob::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::loot::Lootable = temp_clone.into();
        real.loot_table()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::LivingEntity<'mc>> for Mob<'mc> {
    fn into(self) -> crate::entity::LivingEntity<'mc> {
        crate::entity::LivingEntity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Mob into crate::entity::LivingEntity")
    }
}
impl<'mc> Into<crate::loot::Lootable<'mc>> for Mob<'mc> {
    fn into(self) -> crate::loot::Lootable<'mc> {
        crate::loot::Lootable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Mob into crate::loot::Lootable")
    }
}
/// Represents a puffer fish.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct PufferFish<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for PufferFish<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for PufferFish<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate PufferFish from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/PufferFish")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PufferFish object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> PufferFish<'mc> {
    pub fn puff_state(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPuffState", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the current puff state of this fish (i.e. how inflated it is).
    pub fn set_puff_state(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPuffState",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Fish<'mc>> for PufferFish<'mc> {
    fn into(self) -> crate::entity::Fish<'mc> {
        crate::entity::Fish::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting PufferFish into crate::entity::Fish")
    }
}
/// Represents a Primed TNT.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct TNTPrimed<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for TNTPrimed<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TNTPrimed<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate TNTPrimed from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TNTPrimed")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TNTPrimed object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> TNTPrimed<'mc> {
    pub fn source(&self) -> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Entity;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getSource", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::Entity::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Set the number of ticks until the TNT blows up after being primed.
    pub fn set_fuse_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFuseTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn fuse_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFuseTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn set_source(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSource",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_yield(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = TNTPrimed::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Explosive = temp_clone.into();
        real.set_yield(arg0)
    }
    pub fn get_yield(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = TNTPrimed::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Explosive = temp_clone.into();
        real.get_yield()
    }
    pub fn set_is_incendiary(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = TNTPrimed::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Explosive = temp_clone.into();
        real.set_is_incendiary(arg0)
    }
    pub fn is_incendiary(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = TNTPrimed::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Explosive = temp_clone.into();
        real.is_incendiary()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Explosive<'mc>> for TNTPrimed<'mc> {
    fn into(self) -> crate::entity::Explosive<'mc> {
        crate::entity::Explosive::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting TNTPrimed into crate::entity::Explosive")
    }
}

pub enum PandaGene<'mc> {
    Normal { inner: PandaGeneStruct<'mc> },
    Lazy { inner: PandaGeneStruct<'mc> },
    Worried { inner: PandaGeneStruct<'mc> },
    Playful { inner: PandaGeneStruct<'mc> },
    Brown { inner: PandaGeneStruct<'mc> },
    Weak { inner: PandaGeneStruct<'mc> },
    Aggressive { inner: PandaGeneStruct<'mc> },
}
impl<'mc> std::fmt::Display for PandaGene<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PandaGene::Normal { .. } => f.write_str("NORMAL"),
            PandaGene::Lazy { .. } => f.write_str("LAZY"),
            PandaGene::Worried { .. } => f.write_str("WORRIED"),
            PandaGene::Playful { .. } => f.write_str("PLAYFUL"),
            PandaGene::Brown { .. } => f.write_str("BROWN"),
            PandaGene::Weak { .. } => f.write_str("WEAK"),
            PandaGene::Aggressive { .. } => f.write_str("AGGRESSIVE"),
        }
    }
}

impl<'mc> PandaGene<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<PandaGene<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Panda$Gene");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Panda$Gene;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NORMAL" => Ok(PandaGene::Normal {
                inner: PandaGeneStruct::from_raw(env, obj)?,
            }),
            "LAZY" => Ok(PandaGene::Lazy {
                inner: PandaGeneStruct::from_raw(env, obj)?,
            }),
            "WORRIED" => Ok(PandaGene::Worried {
                inner: PandaGeneStruct::from_raw(env, obj)?,
            }),
            "PLAYFUL" => Ok(PandaGene::Playful {
                inner: PandaGeneStruct::from_raw(env, obj)?,
            }),
            "BROWN" => Ok(PandaGene::Brown {
                inner: PandaGeneStruct::from_raw(env, obj)?,
            }),
            "WEAK" => Ok(PandaGene::Weak {
                inner: PandaGeneStruct::from_raw(env, obj)?,
            }),
            "AGGRESSIVE" => Ok(PandaGene::Aggressive {
                inner: PandaGeneStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct PandaGeneStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for PandaGene<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Normal { inner } => inner.0.clone(),
            Self::Lazy { inner } => inner.0.clone(),
            Self::Worried { inner } => inner.0.clone(),
            Self::Playful { inner } => inner.0.clone(),
            Self::Brown { inner } => inner.0.clone(),
            Self::Weak { inner } => inner.0.clone(),
            Self::Aggressive { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Normal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Lazy { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Worried { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Playful { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Brown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Weak { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Aggressive { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for PandaGene<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate PandaGene from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Panda$Gene")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PandaGene object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NORMAL" => Ok(PandaGene::Normal {
                    inner: PandaGeneStruct::from_raw(env, obj)?,
                }),
                "LAZY" => Ok(PandaGene::Lazy {
                    inner: PandaGeneStruct::from_raw(env, obj)?,
                }),
                "WORRIED" => Ok(PandaGene::Worried {
                    inner: PandaGeneStruct::from_raw(env, obj)?,
                }),
                "PLAYFUL" => Ok(PandaGene::Playful {
                    inner: PandaGeneStruct::from_raw(env, obj)?,
                }),
                "BROWN" => Ok(PandaGene::Brown {
                    inner: PandaGeneStruct::from_raw(env, obj)?,
                }),
                "WEAK" => Ok(PandaGene::Weak {
                    inner: PandaGeneStruct::from_raw(env, obj)?,
                }),
                "AGGRESSIVE" => Ok(PandaGene::Aggressive {
                    inner: PandaGeneStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for PandaGeneStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for PandaGeneStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate PandaGeneStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Panda$Gene")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PandaGeneStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> PandaGeneStruct<'mc> {
    pub fn is_recessive(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isRecessive", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a thrown splash potion bottle
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct SplashPotion<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SplashPotion<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SplashPotion<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SplashPotion from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SplashPotion")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SplashPotion object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SplashPotion<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::ThrownPotion<'mc>> for SplashPotion<'mc> {
    fn into(self) -> crate::entity::ThrownPotion<'mc> {
        crate::entity::ThrownPotion::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting SplashPotion into crate::entity::ThrownPotion")
    }
}
/// Represents the current spell the Evoker is using.
pub enum EvokerSpell<'mc> {
    None { inner: EvokerSpellStruct<'mc> },
    Summon { inner: EvokerSpellStruct<'mc> },
    Fangs { inner: EvokerSpellStruct<'mc> },
    Wololo { inner: EvokerSpellStruct<'mc> },
    Disappear { inner: EvokerSpellStruct<'mc> },
    Blindness { inner: EvokerSpellStruct<'mc> },
}
impl<'mc> std::fmt::Display for EvokerSpell<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EvokerSpell::None { .. } => f.write_str("NONE"),
            EvokerSpell::Summon { .. } => f.write_str("SUMMON"),
            EvokerSpell::Fangs { .. } => f.write_str("FANGS"),
            EvokerSpell::Wololo { .. } => f.write_str("WOLOLO"),
            EvokerSpell::Disappear { .. } => f.write_str("DISAPPEAR"),
            EvokerSpell::Blindness { .. } => f.write_str("BLINDNESS"),
        }
    }
}

impl<'mc> EvokerSpell<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<EvokerSpell<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Evoker$Spell");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Evoker$Spell;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NONE" => Ok(EvokerSpell::None {
                inner: EvokerSpellStruct::from_raw(env, obj)?,
            }),
            "SUMMON" => Ok(EvokerSpell::Summon {
                inner: EvokerSpellStruct::from_raw(env, obj)?,
            }),
            "FANGS" => Ok(EvokerSpell::Fangs {
                inner: EvokerSpellStruct::from_raw(env, obj)?,
            }),
            "WOLOLO" => Ok(EvokerSpell::Wololo {
                inner: EvokerSpellStruct::from_raw(env, obj)?,
            }),
            "DISAPPEAR" => Ok(EvokerSpell::Disappear {
                inner: EvokerSpellStruct::from_raw(env, obj)?,
            }),
            "BLINDNESS" => Ok(EvokerSpell::Blindness {
                inner: EvokerSpellStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct EvokerSpellStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EvokerSpell<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::None { inner } => inner.0.clone(),
            Self::Summon { inner } => inner.0.clone(),
            Self::Fangs { inner } => inner.0.clone(),
            Self::Wololo { inner } => inner.0.clone(),
            Self::Disappear { inner } => inner.0.clone(),
            Self::Blindness { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Summon { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Fangs { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Wololo { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Disappear { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Blindness { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EvokerSpell<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate EvokerSpell from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Evoker$Spell")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EvokerSpell object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NONE" => Ok(EvokerSpell::None {
                    inner: EvokerSpellStruct::from_raw(env, obj)?,
                }),
                "SUMMON" => Ok(EvokerSpell::Summon {
                    inner: EvokerSpellStruct::from_raw(env, obj)?,
                }),
                "FANGS" => Ok(EvokerSpell::Fangs {
                    inner: EvokerSpellStruct::from_raw(env, obj)?,
                }),
                "WOLOLO" => Ok(EvokerSpell::Wololo {
                    inner: EvokerSpellStruct::from_raw(env, obj)?,
                }),
                "DISAPPEAR" => Ok(EvokerSpell::Disappear {
                    inner: EvokerSpellStruct::from_raw(env, obj)?,
                }),
                "BLINDNESS" => Ok(EvokerSpell::Blindness {
                    inner: EvokerSpellStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for EvokerSpellStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EvokerSpellStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate EvokerSpellStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Evoker$Spell")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EvokerSpellStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EvokerSpellStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a Water Mob
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct WaterMob<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for WaterMob<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WaterMob<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate WaterMob from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/WaterMob")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WaterMob object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> WaterMob<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Creature<'mc>> for WaterMob<'mc> {
    fn into(self) -> crate::entity::Creature<'mc> {
        crate::entity::Creature::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting WaterMob into crate::entity::Creature")
    }
}
/// Represents a Spider.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Spider<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Spider<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Spider<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Spider from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Spider")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Spider object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Spider<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Spider<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Spider into crate::entity::Monster")
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ThrowableProjectile<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ThrowableProjectile<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ThrowableProjectile<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ThrowableProjectile from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ThrowableProjectile")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ThrowableProjectile object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ThrowableProjectile<'mc> {
    pub fn item(&self) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getItem", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_item(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setItem",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn shooter(
        &self,
    ) -> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ThrowableProjectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.shooter()
    }
    pub fn set_shooter(
        &self,
        arg0: impl Into<crate::projectiles::ProjectileSource<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ThrowableProjectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.set_shooter(arg0)
    }
    pub fn does_bounce(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ThrowableProjectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.does_bounce()
    }
    pub fn set_bounce(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ThrowableProjectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.set_bounce(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for ThrowableProjectile<'mc> {
    fn into(self) -> crate::entity::Projectile<'mc> {
        crate::entity::Projectile::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ThrowableProjectile into crate::entity::Projectile")
    }
}
/// Represents a single part of a <a href="ComplexLivingEntity.html" title="interface in org.bukkit.entity"><code>ComplexLivingEntity</code></a>
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ComplexEntityPart<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ComplexEntityPart<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ComplexEntityPart<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ComplexEntityPart from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ComplexEntityPart")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ComplexEntityPart object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ComplexEntityPart<'mc> {
    pub fn parent(
        &self,
    ) -> Result<crate::entity::ComplexLivingEntity<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/ComplexLivingEntity;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getParent", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::ComplexLivingEntity::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexEntityPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for ComplexEntityPart<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ComplexEntityPart into crate::entity::Entity")
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Dolphin<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Dolphin<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Dolphin<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Dolphin from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Dolphin")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Dolphin object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Dolphin<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::WaterMob<'mc>> for Dolphin<'mc> {
    fn into(self) -> crate::entity::WaterMob<'mc> {
        crate::entity::WaterMob::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Dolphin into crate::entity::WaterMob")
    }
}
/// Represents a block display entity.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct BlockDisplay<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for BlockDisplay<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for BlockDisplay<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate BlockDisplay from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/BlockDisplay")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a BlockDisplay object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> BlockDisplay<'mc> {
    pub fn block(&self) -> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/block/data/BlockData;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBlock", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::data::BlockData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_block(
        &self,
        arg0: impl Into<crate::block::data::BlockData<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/block/data/BlockData;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBlock",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn transformation(
        &self,
    ) -> Result<crate::util::Transformation<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.transformation()
    }
    pub fn set_transformation(
        &self,
        arg0: impl Into<crate::util::Transformation<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_transformation(arg0)
    }
    pub fn set_transformation_matrix(
        &self,
        arg0: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_transformation_matrix(arg0)
    }
    pub fn interpolation_duration(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.interpolation_duration()
    }
    pub fn set_interpolation_duration(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_interpolation_duration(arg0)
    }
    pub fn view_range(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.view_range()
    }
    pub fn set_view_range(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_view_range(arg0)
    }
    pub fn shadow_radius(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getShadowRadius", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    pub fn set_shadow_radius(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setShadowRadius",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn shadow_strength(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.shadow_strength()
    }
    pub fn set_shadow_strength(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_shadow_strength(arg0)
    }
    pub fn display_width(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.display_width()
    }
    pub fn set_display_width(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_display_width(arg0)
    }
    pub fn display_height(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.display_height()
    }
    pub fn set_display_height(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_display_height(arg0)
    }
    pub fn interpolation_delay(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.interpolation_delay()
    }
    pub fn set_interpolation_delay(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_interpolation_delay(arg0)
    }
    pub fn billboard(
        &self,
    ) -> Result<crate::entity::DisplayBillboard<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.billboard()
    }
    pub fn set_billboard(
        &self,
        arg0: impl Into<crate::entity::DisplayBillboard<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_billboard(arg0)
    }
    pub fn glow_color_override(
        &self,
    ) -> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.glow_color_override()
    }
    pub fn set_glow_color_override(
        &self,
        arg0: impl Into<crate::Color<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = BlockDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_glow_color_override(arg0)
    }
    pub fn brightness(
        &self,
    ) -> Result<Option<crate::entity::DisplayBrightness<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Display$Brightness;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBrightness", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::DisplayBrightness::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    pub fn set_brightness(
        &self,
        arg0: impl Into<crate::entity::DisplayBrightness<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Display$Brightness;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBrightness",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Display<'mc>> for BlockDisplay<'mc> {
    fn into(self) -> crate::entity::Display<'mc> {
        crate::entity::Display::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting BlockDisplay into crate::entity::Display")
    }
}
/// Piglin / Piglin Brute.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct PiglinAbstract<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for PiglinAbstract<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for PiglinAbstract<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate PiglinAbstract from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/PiglinAbstract")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PiglinAbstract object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> PiglinAbstract<'mc> {
    pub fn is_immune_to_zombification(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isImmuneToZombification",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the piglin is immune to zombification.
    pub fn set_immune_to_zombification(
        &self,
        arg0: bool,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setImmuneToZombification",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated = "see <a href='Ageable.html#setBaby()'><code>Ageable.setBaby()</code></a> and <a href='Ageable.html#setAdult()'><code>Ageable.setAdult()</code></a> "]
    /// Sets whether the piglin is a baby
    pub fn set_baby(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBaby",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn is_baby(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBaby", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn is_converting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isConverting", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn conversion_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getConversionTime",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the amount of ticks until this entity will be converted to a Zombified Piglin. When this reaches 0, the entity will be converted. A value of less than 0 will stop the current conversion process without converting the current entity.
    pub fn set_conversion_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setConversionTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn age(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = PiglinAbstract::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.age()
    }
    pub fn set_age(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = PiglinAbstract::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_age(arg0)
    }

    pub fn set_age_lock(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = PiglinAbstract::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_age_lock(arg0)
    }

    pub fn age_lock(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = PiglinAbstract::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.age_lock()
    }

    pub fn can_breed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = PiglinAbstract::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.can_breed()
    }

    pub fn set_breed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = PiglinAbstract::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_breed(arg0)
    }
    pub fn set_adult(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = PiglinAbstract::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_adult()
    }
    pub fn is_adult(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = PiglinAbstract::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.is_adult()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for PiglinAbstract<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting PiglinAbstract into crate::entity::Monster")
    }
}
impl<'mc> Into<crate::entity::Ageable<'mc>> for PiglinAbstract<'mc> {
    fn into(self) -> crate::entity::Ageable<'mc> {
        crate::entity::Ageable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting PiglinAbstract into crate::entity::Ageable")
    }
}
/// Describes the axes/points around which the entity can pivot.
pub enum DisplayBillboard<'mc> {
    Fixed { inner: DisplayBillboardStruct<'mc> },
    Vertical { inner: DisplayBillboardStruct<'mc> },
    Horizontal { inner: DisplayBillboardStruct<'mc> },
    Center { inner: DisplayBillboardStruct<'mc> },
}
impl<'mc> std::fmt::Display for DisplayBillboard<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DisplayBillboard::Fixed { .. } => f.write_str("FIXED"),
            DisplayBillboard::Vertical { .. } => f.write_str("VERTICAL"),
            DisplayBillboard::Horizontal { .. } => f.write_str("HORIZONTAL"),
            DisplayBillboard::Center { .. } => f.write_str("CENTER"),
        }
    }
}

impl<'mc> DisplayBillboard<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<DisplayBillboard<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Display$Billboard");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Display$Billboard;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "FIXED" => Ok(DisplayBillboard::Fixed {
                inner: DisplayBillboardStruct::from_raw(env, obj)?,
            }),
            "VERTICAL" => Ok(DisplayBillboard::Vertical {
                inner: DisplayBillboardStruct::from_raw(env, obj)?,
            }),
            "HORIZONTAL" => Ok(DisplayBillboard::Horizontal {
                inner: DisplayBillboardStruct::from_raw(env, obj)?,
            }),
            "CENTER" => Ok(DisplayBillboard::Center {
                inner: DisplayBillboardStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct DisplayBillboardStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for DisplayBillboard<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Fixed { inner } => inner.0.clone(),
            Self::Vertical { inner } => inner.0.clone(),
            Self::Horizontal { inner } => inner.0.clone(),
            Self::Center { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Fixed { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Vertical { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Horizontal { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Center { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for DisplayBillboard<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate DisplayBillboard from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Display$Billboard")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a DisplayBillboard object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "FIXED" => Ok(DisplayBillboard::Fixed {
                    inner: DisplayBillboardStruct::from_raw(env, obj)?,
                }),
                "VERTICAL" => Ok(DisplayBillboard::Vertical {
                    inner: DisplayBillboardStruct::from_raw(env, obj)?,
                }),
                "HORIZONTAL" => Ok(DisplayBillboard::Horizontal {
                    inner: DisplayBillboardStruct::from_raw(env, obj)?,
                }),
                "CENTER" => Ok(DisplayBillboard::Center {
                    inner: DisplayBillboardStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for DisplayBillboardStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for DisplayBillboardStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate DisplayBillboardStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Display$Billboard")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a DisplayBillboardStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> DisplayBillboardStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents the brightness rendering parameters of the entity.
#[repr(C)]
pub struct DisplayBrightness<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for DisplayBrightness<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for DisplayBrightness<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate DisplayBrightness from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Display$Brightness")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a DisplayBrightness object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> DisplayBrightness<'mc> {
    pub fn new(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: i32,
        arg1: i32,
    ) -> Result<crate::entity::DisplayBrightness<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(II)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let cls = jni.find_class("org/bukkit/entity/Display$Brightness");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.new_object(
            cls,
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = jni.translate_error_no_gen(res)?;
        crate::entity::DisplayBrightness::from_raw(&jni, res)
    }

    pub fn block_light(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBlockLight", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn sky_light(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getSkyLight", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn equals(
        &self,
        arg0: jni::objects::JObject<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/Object;)Z");
        let val_1 = jni::objects::JValueGen::Object(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "equals",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    #[doc(hidden)]
    pub fn internal_to_string(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "toString", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn hash_code(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hashCode", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}

impl<'mc> std::string::ToString for DisplayBrightness<'mc> {
    fn to_string(&self) -> String {
        match &self.internal_to_string() {
            Ok(a) => a.clone(),
            Err(err) => format!("Error calling DisplayBrightness.toString: {}", err),
        }
    }
}

/// Represents the item model transform to be applied to the displayed item.
pub enum ItemDisplayItemDisplayTransform<'mc> {
    None {
        inner: ItemDisplayItemDisplayTransformStruct<'mc>,
    },
    ThirdpersonLefthand {
        inner: ItemDisplayItemDisplayTransformStruct<'mc>,
    },
    ThirdpersonRighthand {
        inner: ItemDisplayItemDisplayTransformStruct<'mc>,
    },
    FirstpersonLefthand {
        inner: ItemDisplayItemDisplayTransformStruct<'mc>,
    },
    FirstpersonRighthand {
        inner: ItemDisplayItemDisplayTransformStruct<'mc>,
    },
    Head {
        inner: ItemDisplayItemDisplayTransformStruct<'mc>,
    },
    Gui {
        inner: ItemDisplayItemDisplayTransformStruct<'mc>,
    },
    Ground {
        inner: ItemDisplayItemDisplayTransformStruct<'mc>,
    },
    Fixed {
        inner: ItemDisplayItemDisplayTransformStruct<'mc>,
    },
}
impl<'mc> std::fmt::Display for ItemDisplayItemDisplayTransform<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ItemDisplayItemDisplayTransform::None { .. } => f.write_str("NONE"),
            ItemDisplayItemDisplayTransform::ThirdpersonLefthand { .. } => {
                f.write_str("THIRDPERSON_LEFTHAND")
            }
            ItemDisplayItemDisplayTransform::ThirdpersonRighthand { .. } => {
                f.write_str("THIRDPERSON_RIGHTHAND")
            }
            ItemDisplayItemDisplayTransform::FirstpersonLefthand { .. } => {
                f.write_str("FIRSTPERSON_LEFTHAND")
            }
            ItemDisplayItemDisplayTransform::FirstpersonRighthand { .. } => {
                f.write_str("FIRSTPERSON_RIGHTHAND")
            }
            ItemDisplayItemDisplayTransform::Head { .. } => f.write_str("HEAD"),
            ItemDisplayItemDisplayTransform::Gui { .. } => f.write_str("GUI"),
            ItemDisplayItemDisplayTransform::Ground { .. } => f.write_str("GROUND"),
            ItemDisplayItemDisplayTransform::Fixed { .. } => f.write_str("FIXED"),
        }
    }
}

impl<'mc> ItemDisplayItemDisplayTransform<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<ItemDisplayItemDisplayTransform<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/ItemDisplay$ItemDisplayTransform");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/ItemDisplay$ItemDisplayTransform;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NONE" => Ok(ItemDisplayItemDisplayTransform::None {
                inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "THIRDPERSON_LEFTHAND" => Ok(ItemDisplayItemDisplayTransform::ThirdpersonLefthand {
                inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "THIRDPERSON_RIGHTHAND" => Ok(ItemDisplayItemDisplayTransform::ThirdpersonRighthand {
                inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "FIRSTPERSON_LEFTHAND" => Ok(ItemDisplayItemDisplayTransform::FirstpersonLefthand {
                inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "FIRSTPERSON_RIGHTHAND" => Ok(ItemDisplayItemDisplayTransform::FirstpersonRighthand {
                inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "HEAD" => Ok(ItemDisplayItemDisplayTransform::Head {
                inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "GUI" => Ok(ItemDisplayItemDisplayTransform::Gui {
                inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "GROUND" => Ok(ItemDisplayItemDisplayTransform::Ground {
                inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
            }),
            "FIXED" => Ok(ItemDisplayItemDisplayTransform::Fixed {
                inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct ItemDisplayItemDisplayTransformStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ItemDisplayItemDisplayTransform<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::None { inner } => inner.0.clone(),
            Self::ThirdpersonLefthand { inner } => inner.0.clone(),
            Self::ThirdpersonRighthand { inner } => inner.0.clone(),
            Self::FirstpersonLefthand { inner } => inner.0.clone(),
            Self::FirstpersonRighthand { inner } => inner.0.clone(),
            Self::Head { inner } => inner.0.clone(),
            Self::Gui { inner } => inner.0.clone(),
            Self::Ground { inner } => inner.0.clone(),
            Self::Fixed { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::ThirdpersonLefthand { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ThirdpersonRighthand { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::FirstpersonLefthand { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::FirstpersonRighthand { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Head { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Gui { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Ground { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Fixed { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ItemDisplayItemDisplayTransform<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate ItemDisplayItemDisplayTransform from null object."
            )
            .into());
        }
        let (valid, name) =
            env.validate_name(&obj, "org/bukkit/entity/ItemDisplay$ItemDisplayTransform")?;
        if !valid {
            Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ItemDisplayItemDisplayTransform object, got {}",
                    name
                )
                .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NONE" => Ok(ItemDisplayItemDisplayTransform::None {
                    inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                "THIRDPERSON_LEFTHAND" => {
                    Ok(ItemDisplayItemDisplayTransform::ThirdpersonLefthand {
                        inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
                    })
                }
                "THIRDPERSON_RIGHTHAND" => {
                    Ok(ItemDisplayItemDisplayTransform::ThirdpersonRighthand {
                        inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
                    })
                }
                "FIRSTPERSON_LEFTHAND" => {
                    Ok(ItemDisplayItemDisplayTransform::FirstpersonLefthand {
                        inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
                    })
                }
                "FIRSTPERSON_RIGHTHAND" => {
                    Ok(ItemDisplayItemDisplayTransform::FirstpersonRighthand {
                        inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
                    })
                }
                "HEAD" => Ok(ItemDisplayItemDisplayTransform::Head {
                    inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                "GUI" => Ok(ItemDisplayItemDisplayTransform::Gui {
                    inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                "GROUND" => Ok(ItemDisplayItemDisplayTransform::Ground {
                    inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                "FIXED" => Ok(ItemDisplayItemDisplayTransform::Fixed {
                    inner: ItemDisplayItemDisplayTransformStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for ItemDisplayItemDisplayTransformStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ItemDisplayItemDisplayTransformStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate ItemDisplayItemDisplayTransformStruct from null object."
            )
            .into());
        }
        let (valid, name) =
            env.validate_name(&obj, "org/bukkit/entity/ItemDisplay$ItemDisplayTransform")?;
        if !valid {
            Err(eyre::eyre!(
                    "Invalid argument passed. Expected a ItemDisplayItemDisplayTransformStruct object, got {}",
                    name
                )
                .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ItemDisplayItemDisplayTransformStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a dropped item.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Item<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Item<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Item<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Item from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Item")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Item object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Item<'mc> {
    pub fn owner(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/UUID;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getOwner", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(blackboxmc_java::util::JavaUUID::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_owner(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/UUID;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setOwner",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets if this Item should live forever
    pub fn set_unlimited_lifetime(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setUnlimitedLifetime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn item_stack(
        &self,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getItemStack", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_item_stack(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setItemStack",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn pickup_delay(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPickupDelay", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the delay before this Item is available to be picked up by players
    pub fn set_pickup_delay(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPickupDelay",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_unlimited_lifetime(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isUnlimitedLifetime",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn set_thrower(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/UUID;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setThrower",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn thrower(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/UUID;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getThrower", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(blackboxmc_java::util::JavaUUID::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Item::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Item<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Item into crate::entity::Entity")
    }
}
/// Represents a Fireball.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Fireball<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Fireball<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Fireball<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Fireball from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Fireball")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Fireball object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Fireball<'mc> {
    pub fn direction(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/Vector;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDirection", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::Vector::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_direction(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/Vector;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDirection",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn shooter(
        &self,
    ) -> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Fireball::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.shooter()
    }
    pub fn set_shooter(
        &self,
        arg0: impl Into<crate::projectiles::ProjectileSource<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Fireball::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.set_shooter(arg0)
    }
    pub fn does_bounce(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Fireball::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.does_bounce()
    }
    pub fn set_bounce(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Fireball::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.set_bounce(arg0)
    }
    pub fn set_yield(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Fireball::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Explosive = temp_clone.into();
        real.set_yield(arg0)
    }
    pub fn get_yield(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = Fireball::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Explosive = temp_clone.into();
        real.get_yield()
    }
    pub fn set_is_incendiary(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Fireball::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Explosive = temp_clone.into();
        real.set_is_incendiary(arg0)
    }
    pub fn is_incendiary(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Fireball::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Explosive = temp_clone.into();
        real.is_incendiary()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for Fireball<'mc> {
    fn into(self) -> crate::entity::Projectile<'mc> {
        crate::entity::Projectile::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Fireball into crate::entity::Projectile")
    }
}
impl<'mc> Into<crate::entity::Explosive<'mc>> for Fireball<'mc> {
    fn into(self) -> crate::entity::Explosive<'mc> {
        crate::entity::Explosive::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Fireball into crate::entity::Explosive")
    }
}
pub enum Gene<'mc> {
    Normal { inner: GeneStruct<'mc> },
    Lazy { inner: GeneStruct<'mc> },
    Worried { inner: GeneStruct<'mc> },
    Playful { inner: GeneStruct<'mc> },
    Brown { inner: GeneStruct<'mc> },
    Weak { inner: GeneStruct<'mc> },
    Aggressive { inner: GeneStruct<'mc> },
}
impl<'mc> std::fmt::Display for Gene<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Gene::Normal { .. } => f.write_str("NORMAL"),
            Gene::Lazy { .. } => f.write_str("LAZY"),
            Gene::Worried { .. } => f.write_str("WORRIED"),
            Gene::Playful { .. } => f.write_str("PLAYFUL"),
            Gene::Brown { .. } => f.write_str("BROWN"),
            Gene::Weak { .. } => f.write_str("WEAK"),
            Gene::Aggressive { .. } => f.write_str("AGGRESSIVE"),
        }
    }
}

impl<'mc> Gene<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Gene<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Gene");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Gene;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NORMAL" => Ok(Gene::Normal {
                inner: GeneStruct::from_raw(env, obj)?,
            }),
            "LAZY" => Ok(Gene::Lazy {
                inner: GeneStruct::from_raw(env, obj)?,
            }),
            "WORRIED" => Ok(Gene::Worried {
                inner: GeneStruct::from_raw(env, obj)?,
            }),
            "PLAYFUL" => Ok(Gene::Playful {
                inner: GeneStruct::from_raw(env, obj)?,
            }),
            "BROWN" => Ok(Gene::Brown {
                inner: GeneStruct::from_raw(env, obj)?,
            }),
            "WEAK" => Ok(Gene::Weak {
                inner: GeneStruct::from_raw(env, obj)?,
            }),
            "AGGRESSIVE" => Ok(Gene::Aggressive {
                inner: GeneStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct GeneStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Gene<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Normal { inner } => inner.0.clone(),
            Self::Lazy { inner } => inner.0.clone(),
            Self::Worried { inner } => inner.0.clone(),
            Self::Playful { inner } => inner.0.clone(),
            Self::Brown { inner } => inner.0.clone(),
            Self::Weak { inner } => inner.0.clone(),
            Self::Aggressive { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Normal { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Lazy { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Worried { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Playful { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Brown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Weak { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Aggressive { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Gene<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Gene from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Gene")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Gene object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NORMAL" => Ok(Gene::Normal {
                    inner: GeneStruct::from_raw(env, obj)?,
                }),
                "LAZY" => Ok(Gene::Lazy {
                    inner: GeneStruct::from_raw(env, obj)?,
                }),
                "WORRIED" => Ok(Gene::Worried {
                    inner: GeneStruct::from_raw(env, obj)?,
                }),
                "PLAYFUL" => Ok(Gene::Playful {
                    inner: GeneStruct::from_raw(env, obj)?,
                }),
                "BROWN" => Ok(Gene::Brown {
                    inner: GeneStruct::from_raw(env, obj)?,
                }),
                "WEAK" => Ok(Gene::Weak {
                    inner: GeneStruct::from_raw(env, obj)?,
                }),
                "AGGRESSIVE" => Ok(Gene::Aggressive {
                    inner: GeneStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for GeneStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for GeneStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate GeneStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Gene")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a GeneStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> GeneStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a villager NPC
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Villager<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Villager<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Villager<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Villager from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Villager")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Villager object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Villager<'mc> {
    pub fn wakeup(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "wakeup", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn villager_experience(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getVillagerExperience",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the trading experience of this villager.
    pub fn set_villager_experience(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVillagerExperience",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn villager_type(
        &self,
    ) -> Result<crate::entity::VillagerType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Villager$Type;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getVillagerType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::VillagerType::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_villager_type(
        &self,
        arg0: impl Into<crate::entity::VillagerType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Villager$Type;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVillagerType",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn profession(
        &self,
    ) -> Result<crate::entity::VillagerProfession<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Villager$Profession;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getProfession", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::VillagerProfession::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_profession(
        &self,
        arg0: impl Into<crate::entity::VillagerProfession<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Villager$Profession;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setProfession",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn villager_level(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getVillagerLevel",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the level of this villager. A villager with a level of 1 and no experience is liable to lose its profession.
    pub fn set_villager_level(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVillagerLevel",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn shake_head(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "shakeHead", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn zombify(
        &self,
    ) -> Result<Option<crate::entity::ZombieVillager<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/ZombieVillager;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "zombify", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::ZombieVillager::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn sleep(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "sleep",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn inventory(
        &self,
    ) -> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Villager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractVillager = temp_clone.into();
        real.inventory()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::AbstractVillager<'mc>> for Villager<'mc> {
    fn into(self) -> crate::entity::AbstractVillager<'mc> {
        crate::entity::AbstractVillager::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Villager into crate::entity::AbstractVillager")
    }
}
/// Represents a human entity, such as an NPC or a player
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct HumanEntity<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for HumanEntity<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for HumanEntity<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate HumanEntity from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/HumanEntity")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a HumanEntity object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> HumanEntity<'mc> {
    /// Causes the player to wakeup if they are currently sleeping.
    pub fn wakeup(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "wakeup",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn inventory(
        &self,
    ) -> Result<crate::inventory::PlayerInventory<'mc>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Lorg/bukkit/inventory/PlayerInventory;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getInventory", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::PlayerInventory::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    #[deprecated]

    pub fn item_in_hand(
        &self,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getItemInHand", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_item_in_hand(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setItemInHand",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn ender_chest(
        &self,
    ) -> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/Inventory;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getEnderChest", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::Inventory::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn main_hand(&self) -> Result<crate::inventory::MainHand<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/MainHand;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMainHand", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::MainHand::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_window_property(
        &self,
        arg0: impl Into<crate::inventory::InventoryViewProperty<'mc>>,
        arg1: i32,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/InventoryView$Property;I)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWindowProperty",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn enchantment_seed(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getEnchantmentSeed",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the player's enchantment seed. The Seed is used to generate enchantment options in the enchanting table for the player.
    pub fn set_enchantment_seed(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setEnchantmentSeed",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn open_inventory_with_inventory(
        &self,
        arg0: std::option::Option<impl Into<crate::inventory::Inventory<'mc>>>,
    ) -> Result<crate::inventory::InventoryView<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = arg0 {
            sig += "Lorg/bukkit/inventory/Inventory;";
            let val_1 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_1);
        }
        sig += ")Lorg/bukkit/inventory/InventoryView;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "openInventory", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::InventoryView::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn open_workbench(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: bool,
    ) -> Result<crate::inventory::InventoryView<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;Z)Lorg/bukkit/inventory/InventoryView;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Bool(arg1.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "openWorkbench",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::InventoryView::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn open_enchanting(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: bool,
    ) -> Result<crate::inventory::InventoryView<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;Z)Lorg/bukkit/inventory/InventoryView;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Bool(arg1.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "openEnchanting",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::InventoryView::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn open_merchant_with_villager(
        &self,
        arg0: impl Into<crate::entity::Villager<'mc>>,
        arg1: bool,
    ) -> Result<crate::inventory::InventoryView<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Villager;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Z";
        let val_2 = jni::objects::JValueGen::Bool(arg1.into());
        args.push(val_2);
        sig += ")Lorg/bukkit/inventory/InventoryView;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "openMerchant", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::InventoryView::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn close_inventory(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "closeInventory", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn item_on_cursor(
        &self,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getItemOnCursor", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_item_on_cursor(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setItemOnCursor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn has_cooldown(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Material;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasCooldown",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn get_cooldown(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Material;)I");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCooldown",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn set_cooldown(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
        arg1: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Material;I)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCooldown",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn sleep_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getSleepTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn bed_location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBedLocation", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn game_mode(&self) -> Result<crate::GameMode<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/GameMode;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getGameMode", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::GameMode::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_game_mode(
        &self,
        arg0: impl Into<crate::GameMode<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/GameMode;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setGameMode",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_blocking(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isBlocking", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn is_hand_raised(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isHandRaised", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn item_in_use(
        &self,
    ) -> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getItemInUse", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::inventory::ItemStack::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn exp_to_level(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getExpToLevel", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn attack_cooldown(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getAttackCooldown",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }

    pub fn discover_recipe(
        &self,
        arg0: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "discoverRecipe",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn undiscover_recipe(
        &self,
        arg0: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "undiscoverRecipe",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn has_discovered_recipe(
        &self,
        arg0: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasDiscoveredRecipe",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn discovered_recipes(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDiscoveredRecipes",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    #[deprecated]

    pub fn shoulder_entity_left(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Entity;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getShoulderEntityLeft",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Entity::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_shoulder_entity_left(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setShoulderEntityLeft",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn shoulder_entity_right(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Entity;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getShoulderEntityRight",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Entity::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_shoulder_entity_right(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setShoulderEntityRight",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Make the entity drop the item in their hand.
    ///
    /// This will force the entity to drop the item they are holding with an option to drop the entire <a href="../inventory/ItemStack.html" title="class in org.bukkit.inventory"><code>ItemStack</code></a> or just 1 of the items.
    pub fn drop_item(&self, arg0: bool) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Z)Z");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "dropItem",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn exhaustion(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getExhaustion", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the players current exhaustion level
    pub fn set_exhaustion(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setExhaustion",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn saturation(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getSaturation", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the players current saturation level
    pub fn set_saturation(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSaturation",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn food_level(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFoodLevel", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the players current food level
    pub fn set_food_level(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFoodLevel",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn saturated_regen_rate(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getSaturatedRegenRate",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the regeneration rate (1 health per x ticks) of the HumanEntity when they have saturation and their food level is &gt;= 20. Default is 10. Not affected if the world's difficulty is peaceful.
    pub fn set_saturated_regen_rate(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSaturatedRegenRate",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn unsaturated_regen_rate(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getUnsaturatedRegenRate",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Get the regeneration rate (1 health per x ticks) of the HumanEntity when they have no saturation and their food level is &gt;= 18. Default is 80. Not affected if the world's difficulty is peaceful.
    pub fn set_unsaturated_regen_rate(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setUnsaturatedRegenRate",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn starvation_rate(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getStarvationRate",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Get the starvation rate (1 health per x ticks) of the HumanEntity. Default is 80.
    pub fn set_starvation_rate(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setStarvationRate",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn last_death_location(
        &self,
    ) -> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLastDeathLocation",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn set_last_death_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLastDeathLocation",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn firework_boost(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<crate::entity::Firework<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lorg/bukkit/entity/Firework;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "fireworkBoost",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::Firework::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn name(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getName", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn sleep(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: bool,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;Z)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Bool(arg1.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "sleep",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn maximum_no_damage_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaximumNoDamageTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_arrows_in_body(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_arrows_in_body(arg0)
    }
    pub fn get_eye_height(&self, arg0: bool) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_eye_height(arg0)
    }
    pub fn eye_location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.eye_location()
    }
    pub fn get_line_of_sight(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<Vec<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_line_of_sight(arg0, arg1)
    }
    pub fn get_target_block(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_target_block(arg0, arg1)
    }
    pub fn get_last_two_target_blocks(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<Vec<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/Set;I)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLastTwoTargetBlocks",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::block::Block::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn get_target_block_exact_with_int(
        &self,
        arg0: i32,
        arg1: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>,
    ) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/FluidCollisionMode;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/block/Block;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTargetBlockExact",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Block::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn ray_trace_blocks_with_double(
        &self,
        arg0: f64,
        arg1: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>,
    ) -> Result<crate::util::RayTraceResult<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "D";
        let val_1 = jni::objects::JValueGen::Double(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/FluidCollisionMode;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/util/RayTraceResult;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "rayTraceBlocks", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::RayTraceResult::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn remaining_air(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.remaining_air()
    }
    pub fn set_remaining_air(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_remaining_air(arg0)
    }
    pub fn maximum_air(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.maximum_air()
    }
    pub fn set_maximum_air(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_maximum_air(arg0)
    }
    pub fn arrow_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.arrow_cooldown()
    }
    pub fn set_arrow_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_arrow_cooldown(arg0)
    }
    pub fn arrows_in_body(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.arrows_in_body()
    }
    pub fn set_maximum_no_damage_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaximumNoDamageTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn last_damage(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.last_damage()
    }
    pub fn set_last_damage(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_last_damage(arg0)
    }
    pub fn no_damage_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNoDamageTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_no_damage_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setNoDamageTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn no_action_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNoActionTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_no_action_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setNoActionTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn killer(&self) -> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.killer()
    }
    pub fn add_potion_effect_with_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffect<'mc>>,
        arg1: std::option::Option<bool>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/potion/PotionEffect;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Z";
            let val_2 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_2);
        }
        sig += ")Z";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "addPotionEffect", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn has_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasPotionEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn get_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<crate::potion::PotionEffect<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_potion_effect(arg0)
    }
    pub fn remove_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.remove_potion_effect(arg0)
    }
    pub fn active_potion_effects(
        &self,
    ) -> Result<Vec<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getActivePotionEffects",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::potion::PotionEffect::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn has_line_of_sight(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.has_line_of_sight(arg0)
    }
    pub fn remove_when_far_away(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.remove_when_far_away()
    }
    pub fn set_remove_when_far_away(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_remove_when_far_away(arg0)
    }
    pub fn equipment(
        &self,
    ) -> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.equipment()
    }
    pub fn set_can_pickup_items(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCanPickupItems",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn can_pickup_items(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCanPickupItems",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn is_leashed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_leashed()
    }
    pub fn leash_holder(&self) -> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.leash_holder()
    }
    pub fn set_leash_holder(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_leash_holder(arg0)
    }
    pub fn is_gliding(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_gliding()
    }
    pub fn set_gliding(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_gliding(arg0)
    }
    pub fn is_swimming(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_swimming()
    }
    pub fn set_swimming(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_swimming(arg0)
    }
    pub fn is_riptiding(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_riptiding()
    }
    pub fn is_sleeping(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_sleeping()
    }
    pub fn is_climbing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_climbing()
    }
    pub fn set_ai(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_ai(arg0)
    }
    pub fn has_ai(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.has_ai()
    }
    pub fn attack(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.attack(arg0)
    }
    pub fn swing_main_hand(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.swing_main_hand()
    }
    pub fn swing_off_hand(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.swing_off_hand()
    }
    pub fn play_hurt_animation(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.play_hurt_animation(arg0)
    }
    pub fn set_collidable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_collidable(arg0)
    }
    pub fn is_collidable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_collidable()
    }
    pub fn collidable_exemptions(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCollidableExemptions",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn get_memory(
        &self,
        arg0: impl Into<crate::entity::memory::MemoryKey<'mc>>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_memory(arg0)
    }
    pub fn hurt_sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.hurt_sound()
    }
    pub fn death_sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.death_sound()
    }
    pub fn get_fall_damage_sound(
        &self,
        arg0: i32,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_fall_damage_sound(arg0)
    }
    pub fn fall_damage_sound_small(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.fall_damage_sound_small()
    }
    pub fn fall_damage_sound_big(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.fall_damage_sound_big()
    }
    pub fn get_drinking_sound(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_drinking_sound(arg0)
    }
    pub fn get_eating_sound(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_eating_sound(arg0)
    }
    pub fn can_breathe_underwater(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.can_breathe_underwater()
    }
    pub fn category(
        &self,
    ) -> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.category()
    }
    pub fn set_invisible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_invisible(arg0)
    }
    pub fn is_invisible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_invisible()
    }
    pub fn set_memory(
        &self,
        arg0: impl Into<crate::entity::memory::MemoryKey<'mc>>,
        arg1: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_memory(arg0, arg1)
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = HumanEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AnimalTamer = temp_clone.into();
        real.unique_id()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::LivingEntity<'mc>> for HumanEntity<'mc> {
    fn into(self) -> crate::entity::LivingEntity<'mc> {
        crate::entity::LivingEntity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting HumanEntity into crate::entity::LivingEntity")
    }
}
impl<'mc> Into<crate::entity::AnimalTamer<'mc>> for HumanEntity<'mc> {
    fn into(self) -> crate::entity::AnimalTamer<'mc> {
        crate::entity::AnimalTamer::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting HumanEntity into crate::entity::AnimalTamer")
    }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for HumanEntity<'mc> {
    fn into(self) -> crate::inventory::InventoryHolder<'mc> {
        crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting HumanEntity into crate::inventory::InventoryHolder")
    }
}
/// Represents a thrown potion bottle
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ThrownPotion<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ThrownPotion<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ThrownPotion<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ThrownPotion from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ThrownPotion")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ThrownPotion object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ThrownPotion<'mc> {
    pub fn item(&self) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getItem", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_item(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setItem",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn effects(
        &self,
    ) -> Result<Vec<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getEffects", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::potion::PotionEffect::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::ThrowableProjectile<'mc>> for ThrownPotion<'mc> {
    fn into(self) -> crate::entity::ThrowableProjectile<'mc> {
        crate::entity::ThrowableProjectile::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ThrownPotion into crate::entity::ThrowableProjectile")
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Guardian<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Guardian<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Guardian<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Guardian from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Guardian")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Guardian object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Guardian<'mc> {
    /// Sets whether the guardian laser should show or not. A target must be present. If no target is present the laser will not show and the method will return false.
    pub fn set_laser(&self, arg0: bool) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Z)Z");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLaser",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn has_laser(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hasLaser", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn laser_duration(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLaserDuration",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the amount of ticks that have elapsed since this guardian has initiated a laser attack. If set to <a href="#getLaserDuration()"><code>getLaserDuration()</code></a> or greater, the guardian will inflict damage upon its target and the laser attack will complete.
    /// <p>For this value to have any effect, the guardian must have an active target (see <a href="Mob.html#setTarget(org.bukkit.entity.LivingEntity)"><code>Mob.setTarget(LivingEntity)</code></a>) and be charging a laser attack (where <a href="#hasLaser()"><code>hasLaser()</code></a> is true). The client may display a different animation of the guardian laser than the set ticks.</p>
    pub fn set_laser_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLaserTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn laser_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLaserTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]

    pub fn is_elder(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isElder", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated = "Must spawn a new <a title='interface in org.bukkit.entity' href='ElderGuardian.html'><code>ElderGuardian</code></a>. "]

    pub fn set_elder(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setElder",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_moving(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isMoving", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Guardian<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Guardian into crate::entity::Monster")
    }
}
/// A Goat.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Goat<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Goat<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Goat<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Goat from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Goat")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Goat object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Goat<'mc> {
    pub fn has_left_horn(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "hasLeftHorn", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if this goat has its left horn.
    pub fn set_left_horn(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLeftHorn",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn has_right_horn(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "hasRightHorn", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if this goat has its right horn.
    pub fn set_right_horn(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRightHorn",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_screaming(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isScreaming", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if this is a screaming goat. A screaming goat makes screaming sounds and rams more often. They do not offer home loans.
    pub fn set_screaming(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setScreaming",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Goat::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Goat::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Goat::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Goat<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Goat into crate::entity::Animals")
    }
}
pub enum Billboard<'mc> {
    Fixed { inner: BillboardStruct<'mc> },
    Vertical { inner: BillboardStruct<'mc> },
    Horizontal { inner: BillboardStruct<'mc> },
    Center { inner: BillboardStruct<'mc> },
}
impl<'mc> std::fmt::Display for Billboard<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Billboard::Fixed { .. } => f.write_str("FIXED"),
            Billboard::Vertical { .. } => f.write_str("VERTICAL"),
            Billboard::Horizontal { .. } => f.write_str("HORIZONTAL"),
            Billboard::Center { .. } => f.write_str("CENTER"),
        }
    }
}

impl<'mc> Billboard<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Billboard<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Billboard");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Billboard;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "FIXED" => Ok(Billboard::Fixed {
                inner: BillboardStruct::from_raw(env, obj)?,
            }),
            "VERTICAL" => Ok(Billboard::Vertical {
                inner: BillboardStruct::from_raw(env, obj)?,
            }),
            "HORIZONTAL" => Ok(Billboard::Horizontal {
                inner: BillboardStruct::from_raw(env, obj)?,
            }),
            "CENTER" => Ok(Billboard::Center {
                inner: BillboardStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct BillboardStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Billboard<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Fixed { inner } => inner.0.clone(),
            Self::Vertical { inner } => inner.0.clone(),
            Self::Horizontal { inner } => inner.0.clone(),
            Self::Center { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Fixed { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Vertical { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Horizontal { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Center { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Billboard<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Billboard from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Billboard")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Billboard object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "FIXED" => Ok(Billboard::Fixed {
                    inner: BillboardStruct::from_raw(env, obj)?,
                }),
                "VERTICAL" => Ok(Billboard::Vertical {
                    inner: BillboardStruct::from_raw(env, obj)?,
                }),
                "HORIZONTAL" => Ok(Billboard::Horizontal {
                    inner: BillboardStruct::from_raw(env, obj)?,
                }),
                "CENTER" => Ok(Billboard::Center {
                    inner: BillboardStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for BillboardStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for BillboardStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate BillboardStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Billboard")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a BillboardStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> BillboardStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Illager entity.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Pillager<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Pillager<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Pillager<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Pillager from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Pillager")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Pillager object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Pillager<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Illager<'mc>> for Pillager<'mc> {
    fn into(self) -> crate::entity::Illager<'mc> {
        crate::entity::Illager::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Pillager into crate::entity::Illager")
    }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for Pillager<'mc> {
    fn into(self) -> crate::inventory::InventoryHolder<'mc> {
        crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Pillager into crate::inventory::InventoryHolder")
    }
}
/// An animal that can sit still.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Sittable<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Sittable<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Sittable<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Sittable from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Sittable")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Sittable object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Sittable<'mc> {
    pub fn is_sitting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isSitting", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if this animal is sitting. Will remove any path that the animal was following beforehand.
    pub fn set_sitting(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSitting",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a mushroom <a href="Cow.html" title="interface in org.bukkit.entity"><code>Cow</code></a>
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct MushroomCow<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for MushroomCow<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for MushroomCow<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate MushroomCow from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/MushroomCow")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a MushroomCow object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> MushroomCow<'mc> {
    pub fn variant(
        &self,
    ) -> Result<crate::entity::MushroomCowVariant<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/MushroomCow$Variant;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getVariant", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::MushroomCowVariant::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_variant(
        &self,
        arg0: impl Into<crate::entity::MushroomCowVariant<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/MushroomCow$Variant;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVariant",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Cow<'mc>> for MushroomCow<'mc> {
    fn into(self) -> crate::entity::Cow<'mc> {
        crate::entity::Cow::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting MushroomCow into crate::entity::Cow")
    }
}
/// Represents a thrown lingering potion bottle
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct LingeringPotion<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for LingeringPotion<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for LingeringPotion<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate LingeringPotion from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LingeringPotion")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a LingeringPotion object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> LingeringPotion<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::ThrownPotion<'mc>> for LingeringPotion<'mc> {
    fn into(self) -> crate::entity::ThrownPotion<'mc> {
        crate::entity::ThrownPotion::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting LingeringPotion into crate::entity::ThrownPotion")
    }
}
/// Panda entity.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Panda<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Panda<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Panda<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Panda from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Panda")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Panda object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Panda<'mc> {
    pub fn main_gene(&self) -> Result<crate::entity::PandaGene<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Panda$Gene;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMainGene", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::PandaGene::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_main_gene(
        &self,
        arg0: impl Into<crate::entity::PandaGene<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Panda$Gene;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMainGene",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn hidden_gene(&self) -> Result<crate::entity::PandaGene<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Panda$Gene;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getHiddenGene", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::PandaGene::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_hidden_gene(
        &self,
        arg0: impl Into<crate::entity::PandaGene<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Panda$Gene;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setHiddenGene",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_rolling(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isRolling", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the Panda is rolling
    pub fn set_rolling(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRolling",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_sneezing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isSneezing", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the Panda is sneezing
    pub fn set_sneezing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSneezing",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_on_back(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isOnBack", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the Panda is on its back
    pub fn set_on_back(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setOnBack",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_eating(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isEating", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets the Panda's eating status. The panda must be holding food for this to work
    pub fn set_eating(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setEating",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_scared(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isScared", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn unhappy_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getUnhappyTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Panda::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Panda::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Panda::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn is_sitting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Panda::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Sittable = temp_clone.into();
        real.is_sitting()
    }
    pub fn set_sitting(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Panda::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Sittable = temp_clone.into();
        real.set_sitting(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Panda<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Panda into crate::entity::Animals")
    }
}
impl<'mc> Into<crate::entity::Sittable<'mc>> for Panda<'mc> {
    fn into(self) -> crate::entity::Sittable<'mc> {
        crate::entity::Sittable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Panda into crate::entity::Sittable")
    }
}
pub enum Variant<'mc> {
    Red { inner: VariantStruct<'mc> },
    Brown { inner: VariantStruct<'mc> },
}
impl<'mc> std::fmt::Display for Variant<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Variant::Red { .. } => f.write_str("RED"),
            Variant::Brown { .. } => f.write_str("BROWN"),
        }
    }
}

impl<'mc> Variant<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Variant<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Variant");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Variant;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "RED" => Ok(Variant::Red {
                inner: VariantStruct::from_raw(env, obj)?,
            }),
            "BROWN" => Ok(Variant::Brown {
                inner: VariantStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct VariantStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Variant<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Red { inner } => inner.0.clone(),
            Self::Brown { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Red { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Brown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Variant<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Variant from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Variant object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "RED" => Ok(Variant::Red {
                    inner: VariantStruct::from_raw(env, obj)?,
                }),
                "BROWN" => Ok(Variant::Brown {
                    inner: VariantStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for VariantStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for VariantStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate VariantStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a VariantStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> VariantStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a snowball.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Snowball<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Snowball<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Snowball<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Snowball from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Snowball")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Snowball object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Snowball<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::ThrowableProjectile<'mc>> for Snowball<'mc> {
    fn into(self) -> crate::entity::ThrowableProjectile<'mc> {
        crate::entity::ThrowableProjectile::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Snowball into crate::entity::ThrowableProjectile")
    }
}
/// Represents a Flying Entity.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Flying<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Flying<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Flying<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Flying from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Flying")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Flying object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Flying<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Mob<'mc>> for Flying<'mc> {
    fn into(self) -> crate::entity::Mob<'mc> {
        crate::entity::Mob::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Flying into crate::entity::Mob")
    }
}
/// Represents an item display entity.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ItemDisplay<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ItemDisplay<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ItemDisplay<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ItemDisplay from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ItemDisplay")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ItemDisplay object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ItemDisplay<'mc> {
    pub fn item_display_transform(
        &self,
    ) -> Result<crate::entity::ItemDisplayItemDisplayTransform<'mc>, Box<dyn std::error::Error>>
    {
        let sig = String::from("()Lorg/bukkit/entity/ItemDisplay$ItemDisplayTransform;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getItemDisplayTransform",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::ItemDisplayItemDisplayTransform::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn item_stack(
        &self,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getItemStack", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_item_stack(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setItemStack",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_item_display_transform(
        &self,
        arg0: impl Into<crate::entity::ItemDisplayItemDisplayTransform<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/ItemDisplay$ItemDisplayTransform;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setItemDisplayTransform",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn transformation(
        &self,
    ) -> Result<crate::util::Transformation<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.transformation()
    }
    pub fn set_transformation(
        &self,
        arg0: impl Into<crate::util::Transformation<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_transformation(arg0)
    }
    pub fn set_transformation_matrix(
        &self,
        arg0: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_transformation_matrix(arg0)
    }
    pub fn interpolation_duration(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.interpolation_duration()
    }
    pub fn set_interpolation_duration(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_interpolation_duration(arg0)
    }
    pub fn view_range(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.view_range()
    }
    pub fn set_view_range(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_view_range(arg0)
    }
    pub fn shadow_radius(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getShadowRadius", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    pub fn set_shadow_radius(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setShadowRadius",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn shadow_strength(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.shadow_strength()
    }
    pub fn set_shadow_strength(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_shadow_strength(arg0)
    }
    pub fn display_width(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.display_width()
    }
    pub fn set_display_width(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_display_width(arg0)
    }
    pub fn display_height(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.display_height()
    }
    pub fn set_display_height(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_display_height(arg0)
    }
    pub fn interpolation_delay(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.interpolation_delay()
    }
    pub fn set_interpolation_delay(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_interpolation_delay(arg0)
    }
    pub fn billboard(
        &self,
    ) -> Result<crate::entity::DisplayBillboard<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.billboard()
    }
    pub fn set_billboard(
        &self,
        arg0: impl Into<crate::entity::DisplayBillboard<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_billboard(arg0)
    }
    pub fn glow_color_override(
        &self,
    ) -> Result<Option<crate::Color<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.glow_color_override()
    }
    pub fn set_glow_color_override(
        &self,
        arg0: impl Into<crate::Color<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ItemDisplay::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Display = temp_clone.into();
        real.set_glow_color_override(arg0)
    }
    pub fn brightness(
        &self,
    ) -> Result<Option<crate::entity::DisplayBrightness<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Display$Brightness;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBrightness", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::DisplayBrightness::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    pub fn set_brightness(
        &self,
        arg0: impl Into<crate::entity::DisplayBrightness<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Display$Brightness;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBrightness",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Display<'mc>> for ItemDisplay<'mc> {
    fn into(self) -> crate::entity::Display<'mc> {
        crate::entity::Display::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ItemDisplay into crate::entity::Display")
    }
}
/// Represents a Spider.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct CaveSpider<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for CaveSpider<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for CaveSpider<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate CaveSpider from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/CaveSpider")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a CaveSpider object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> CaveSpider<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Spider<'mc>> for CaveSpider<'mc> {
    fn into(self) -> crate::entity::Spider<'mc> {
        crate::entity::Spider::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting CaveSpider into crate::entity::Spider")
    }
}
/// A <a title="interface in org.bukkit.entity" href="Boat.html"><code>Boat</code></a> with a chest.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ChestBoat<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ChestBoat<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ChestBoat<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ChestBoat from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ChestBoat")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ChestBoat object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ChestBoat<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Boat<'mc>> for ChestBoat<'mc> {
    fn into(self) -> crate::entity::Boat<'mc> {
        crate::entity::Boat::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ChestBoat into crate::entity::Boat")
    }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for ChestBoat<'mc> {
    fn into(self) -> crate::inventory::InventoryHolder<'mc> {
        crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ChestBoat into crate::inventory::InventoryHolder")
    }
}
impl<'mc> Into<crate::loot::Lootable<'mc>> for ChestBoat<'mc> {
    fn into(self) -> crate::loot::Lootable<'mc> {
        crate::loot::Lootable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ChestBoat into crate::loot::Lootable")
    }
}
/// Represents a <a title="interface in org.bukkit.entity" href="Zombie.html"><code>Zombie</code></a> which was once a <a title="interface in org.bukkit.entity" href="Villager.html"><code>Villager</code></a>.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ZombieVillager<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ZombieVillager<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ZombieVillager<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ZombieVillager from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ZombieVillager")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ZombieVillager object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ZombieVillager<'mc> {
    pub fn set_villager_profession(
        &self,
        arg0: impl Into<crate::entity::VillagerProfession<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Villager$Profession;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVillagerProfession",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn villager_profession(
        &self,
    ) -> Result<crate::entity::VillagerProfession<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Villager$Profession;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getVillagerProfession",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::VillagerProfession::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn is_converting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isConverting", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn conversion_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getConversionTime",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the amount of ticks until this entity will be converted to a Villager as a result of being cured. When this reaches 0, the entity will be converted. A value of less than 0 will stop the current conversion process without converting the current entity.
    pub fn set_conversion_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setConversionTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn conversion_player(
        &self,
    ) -> Result<Option<crate::OfflinePlayer<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/OfflinePlayer;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getConversionPlayer",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::OfflinePlayer::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn villager_type(
        &self,
    ) -> Result<crate::entity::VillagerType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Villager$Type;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getVillagerType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::VillagerType::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_villager_type(
        &self,
        arg0: impl Into<crate::entity::VillagerType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Villager$Type;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVillagerType",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_conversion_player(
        &self,
        arg0: impl Into<crate::OfflinePlayer<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/OfflinePlayer;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setConversionPlayer",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_baby(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ZombieVillager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.set_baby(arg0)
    }

    pub fn is_baby(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ZombieVillager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.is_baby()
    }

    pub fn is_villager(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ZombieVillager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.is_villager()
    }
    pub fn set_villager(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ZombieVillager::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Zombie = temp_clone.into();
        real.set_villager(arg0)
    }
    pub fn can_break_doors(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "canBreakDoors", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn set_can_break_doors(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCanBreakDoors",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Zombie<'mc>> for ZombieVillager<'mc> {
    fn into(self) -> crate::entity::Zombie<'mc> {
        crate::entity::Zombie::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ZombieVillager into crate::entity::Zombie")
    }
}
/// This interface defines or represents the abstract concept of skeleton-like entities on the server. The interface is hence not a direct representation of an entity but rather serves as a parent to interfaces/entity types like <a href="Skeleton.html" title="interface in org.bukkit.entity"><code>Skeleton</code></a>, <a href="WitherSkeleton.html" title="interface in org.bukkit.entity"><code>WitherSkeleton</code></a> or <a title="interface in org.bukkit.entity" href="Stray.html"><code>Stray</code></a>. To compute what specific type of skeleton is present in a variable/field of this type, instanceOf checks against the specific subtypes listed prior are recommended.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct AbstractSkeleton<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for AbstractSkeleton<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for AbstractSkeleton<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate AbstractSkeleton from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AbstractSkeleton")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a AbstractSkeleton object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> AbstractSkeleton<'mc> {
    #[deprecated]

    pub fn skeleton_type(
        &self,
    ) -> Result<crate::entity::SkeletonSkeletonType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Skeleton$SkeletonType;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getSkeletonType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::SkeletonSkeletonType::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_skeleton_type(
        &self,
        arg0: impl Into<crate::entity::SkeletonSkeletonType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Skeleton$SkeletonType;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSkeletonType",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for AbstractSkeleton<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting AbstractSkeleton into crate::entity::Monster")
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Rabbit<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Rabbit<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Rabbit<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Rabbit from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Rabbit")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Rabbit object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Rabbit<'mc> {
    pub fn rabbit_type(
        &self,
    ) -> Result<crate::entity::RabbitType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Rabbit$Type;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getRabbitType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::RabbitType::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_rabbit_type(
        &self,
        arg0: impl Into<crate::entity::RabbitType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Rabbit$Type;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRabbitType",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Rabbit::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Rabbit::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Rabbit::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Rabbit<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Rabbit into crate::entity::Animals")
    }
}
/// Represents a Camel.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Camel<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Camel<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Camel<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Camel from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Camel")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Camel object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Camel<'mc> {
    pub fn is_dashing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isDashing", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether this camel is dashing (sprinting).
    pub fn set_dashing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDashing",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn variant(&self) -> Result<crate::entity::HorseVariant<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Camel::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.variant()
    }
    pub fn inventory(
        &self,
    ) -> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Camel::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.inventory()
    }
    pub fn set_variant(
        &self,
        arg0: impl Into<crate::entity::HorseVariant<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Camel::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_variant(arg0)
    }
    pub fn domestication(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Camel::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.domestication()
    }
    pub fn set_domestication(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Camel::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_domestication(arg0)
    }
    pub fn max_domestication(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Camel::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.max_domestication()
    }
    pub fn set_max_domestication(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Camel::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_max_domestication(arg0)
    }
    pub fn jump_strength(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Camel::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.jump_strength()
    }
    pub fn set_jump_strength(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Camel::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_jump_strength(arg0)
    }
    pub fn is_eating_haystack(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Camel::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.is_eating_haystack()
    }
    pub fn set_eating_haystack(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Camel::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_eating_haystack(arg0)
    }
    pub fn is_sitting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Camel::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Sittable = temp_clone.into();
        real.is_sitting()
    }
    pub fn set_sitting(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Camel::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Sittable = temp_clone.into();
        real.set_sitting(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::AbstractHorse<'mc>> for Camel<'mc> {
    fn into(self) -> crate::entity::AbstractHorse<'mc> {
        crate::entity::AbstractHorse::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Camel into crate::entity::AbstractHorse")
    }
}
impl<'mc> Into<crate::entity::Sittable<'mc>> for Camel<'mc> {
    fn into(self) -> crate::entity::Sittable<'mc> {
        crate::entity::Sittable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Camel into crate::entity::Sittable")
    }
}
/// An iron Golem that protects Villages.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct IronGolem<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for IronGolem<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for IronGolem<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate IronGolem from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/IronGolem")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a IronGolem object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> IronGolem<'mc> {
    pub fn is_player_created(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isPlayerCreated", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether this iron golem was built by a player or not.
    pub fn set_player_created(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPlayerCreated",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Golem<'mc>> for IronGolem<'mc> {
    fn into(self) -> crate::entity::Golem<'mc> {
        crate::entity::Golem::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting IronGolem into crate::entity::Golem")
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ShulkerBullet<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ShulkerBullet<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ShulkerBullet<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ShulkerBullet from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ShulkerBullet")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ShulkerBullet object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ShulkerBullet<'mc> {
    pub fn target(&self) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Entity;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getTarget", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Entity::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_target(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTarget",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn shooter(
        &self,
    ) -> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ShulkerBullet::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.shooter()
    }
    pub fn set_shooter(
        &self,
        arg0: impl Into<crate::projectiles::ProjectileSource<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ShulkerBullet::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.set_shooter(arg0)
    }
    pub fn does_bounce(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ShulkerBullet::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.does_bounce()
    }
    pub fn set_bounce(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ShulkerBullet::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.set_bounce(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for ShulkerBullet<'mc> {
    fn into(self) -> crate::entity::Projectile<'mc> {
        crate::entity::Projectile::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ShulkerBullet into crate::entity::Projectile")
    }
}
/// Represents an entity that can age.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Ageable<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Ageable<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Ageable<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Ageable from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ageable")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Ageable object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Ageable<'mc> {
    pub fn age(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getAge", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the age of this mob.
    pub fn set_age(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAge",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated = "see <a href='Breedable.html#setAgeLock(boolean)'><code>Breedable.setAgeLock(boolean)</code></a> "]
    /// Lock the age of the animal, setting this will prevent the animal from maturing or getting ready for mating.
    pub fn set_age_lock(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAgeLock",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn age_lock(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getAgeLock", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]

    pub fn can_breed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "canBreed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated = "see <a href='Breedable.html#setBreed(boolean)'><code>Breedable.setBreed(boolean)</code></a> "]
    /// Set breedability of the animal, if the animal is a baby and set to breed it will instantly grow up.
    pub fn set_breed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBreed",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_baby(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "setBaby", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_adult(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "setAdult", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_adult(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isAdult", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Creature<'mc>> for Ageable<'mc> {
    fn into(self) -> crate::entity::Creature<'mc> {
        crate::entity::Creature::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Ageable into crate::entity::Creature")
    }
}
/// Represents a previous interaction with this entity.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct InteractionPreviousInteraction<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for InteractionPreviousInteraction<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for InteractionPreviousInteraction<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate InteractionPreviousInteraction from null object."
            )
            .into());
        }
        let (valid, name) =
            env.validate_name(&obj, "org/bukkit/entity/Interaction$PreviousInteraction")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a InteractionPreviousInteraction object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> InteractionPreviousInteraction<'mc> {
    pub fn timestamp(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getTimestamp", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }

    pub fn player(&self) -> Result<Option<crate::OfflinePlayer<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/OfflinePlayer;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getPlayer", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::OfflinePlayer::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents the variant of a frog - ie its color.
pub enum FrogVariant<'mc> {
    Temperate { inner: FrogVariantStruct<'mc> },
    Warm { inner: FrogVariantStruct<'mc> },
    Cold { inner: FrogVariantStruct<'mc> },
}
impl<'mc> std::fmt::Display for FrogVariant<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FrogVariant::Temperate { .. } => f.write_str("TEMPERATE"),
            FrogVariant::Warm { .. } => f.write_str("WARM"),
            FrogVariant::Cold { .. } => f.write_str("COLD"),
        }
    }
}

impl<'mc> FrogVariant<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<FrogVariant<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Frog$Variant");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Frog$Variant;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "TEMPERATE" => Ok(FrogVariant::Temperate {
                inner: FrogVariantStruct::from_raw(env, obj)?,
            }),
            "WARM" => Ok(FrogVariant::Warm {
                inner: FrogVariantStruct::from_raw(env, obj)?,
            }),
            "COLD" => Ok(FrogVariant::Cold {
                inner: FrogVariantStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct FrogVariantStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for FrogVariant<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Temperate { inner } => inner.0.clone(),
            Self::Warm { inner } => inner.0.clone(),
            Self::Cold { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Temperate { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Warm { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cold { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FrogVariant<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate FrogVariant from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Frog$Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FrogVariant object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "TEMPERATE" => Ok(FrogVariant::Temperate {
                    inner: FrogVariantStruct::from_raw(env, obj)?,
                }),
                "WARM" => Ok(FrogVariant::Warm {
                    inner: FrogVariantStruct::from_raw(env, obj)?,
                }),
                "COLD" => Ok(FrogVariant::Cold {
                    inner: FrogVariantStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for FrogVariantStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FrogVariantStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate FrogVariantStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Frog$Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FrogVariantStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> FrogVariantStruct<'mc> {
    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents the various different Villager professions there may be. Villagers have different trading options depending on their profession,
pub enum VillagerProfession<'mc> {
    None {
        inner: VillagerProfessionStruct<'mc>,
    },
    Armorer {
        inner: VillagerProfessionStruct<'mc>,
    },
    Butcher {
        inner: VillagerProfessionStruct<'mc>,
    },
    Cartographer {
        inner: VillagerProfessionStruct<'mc>,
    },
    Cleric {
        inner: VillagerProfessionStruct<'mc>,
    },
    Farmer {
        inner: VillagerProfessionStruct<'mc>,
    },
    Fisherman {
        inner: VillagerProfessionStruct<'mc>,
    },
    Fletcher {
        inner: VillagerProfessionStruct<'mc>,
    },
    Leatherworker {
        inner: VillagerProfessionStruct<'mc>,
    },
    Librarian {
        inner: VillagerProfessionStruct<'mc>,
    },
    Mason {
        inner: VillagerProfessionStruct<'mc>,
    },
    Nitwit {
        inner: VillagerProfessionStruct<'mc>,
    },
    Shepherd {
        inner: VillagerProfessionStruct<'mc>,
    },
    Toolsmith {
        inner: VillagerProfessionStruct<'mc>,
    },
    Weaponsmith {
        inner: VillagerProfessionStruct<'mc>,
    },
}
impl<'mc> std::fmt::Display for VillagerProfession<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VillagerProfession::None { .. } => f.write_str("NONE"),
            VillagerProfession::Armorer { .. } => f.write_str("ARMORER"),
            VillagerProfession::Butcher { .. } => f.write_str("BUTCHER"),
            VillagerProfession::Cartographer { .. } => f.write_str("CARTOGRAPHER"),
            VillagerProfession::Cleric { .. } => f.write_str("CLERIC"),
            VillagerProfession::Farmer { .. } => f.write_str("FARMER"),
            VillagerProfession::Fisherman { .. } => f.write_str("FISHERMAN"),
            VillagerProfession::Fletcher { .. } => f.write_str("FLETCHER"),
            VillagerProfession::Leatherworker { .. } => f.write_str("LEATHERWORKER"),
            VillagerProfession::Librarian { .. } => f.write_str("LIBRARIAN"),
            VillagerProfession::Mason { .. } => f.write_str("MASON"),
            VillagerProfession::Nitwit { .. } => f.write_str("NITWIT"),
            VillagerProfession::Shepherd { .. } => f.write_str("SHEPHERD"),
            VillagerProfession::Toolsmith { .. } => f.write_str("TOOLSMITH"),
            VillagerProfession::Weaponsmith { .. } => f.write_str("WEAPONSMITH"),
        }
    }
}

impl<'mc> VillagerProfession<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<VillagerProfession<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Villager$Profession");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Villager$Profession;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NONE" => Ok(VillagerProfession::None {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "ARMORER" => Ok(VillagerProfession::Armorer {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "BUTCHER" => Ok(VillagerProfession::Butcher {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "CARTOGRAPHER" => Ok(VillagerProfession::Cartographer {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "CLERIC" => Ok(VillagerProfession::Cleric {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "FARMER" => Ok(VillagerProfession::Farmer {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "FISHERMAN" => Ok(VillagerProfession::Fisherman {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "FLETCHER" => Ok(VillagerProfession::Fletcher {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "LEATHERWORKER" => Ok(VillagerProfession::Leatherworker {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "LIBRARIAN" => Ok(VillagerProfession::Librarian {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "MASON" => Ok(VillagerProfession::Mason {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "NITWIT" => Ok(VillagerProfession::Nitwit {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "SHEPHERD" => Ok(VillagerProfession::Shepherd {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "TOOLSMITH" => Ok(VillagerProfession::Toolsmith {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),
            "WEAPONSMITH" => Ok(VillagerProfession::Weaponsmith {
                inner: VillagerProfessionStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct VillagerProfessionStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for VillagerProfession<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::None { inner } => inner.0.clone(),
            Self::Armorer { inner } => inner.0.clone(),
            Self::Butcher { inner } => inner.0.clone(),
            Self::Cartographer { inner } => inner.0.clone(),
            Self::Cleric { inner } => inner.0.clone(),
            Self::Farmer { inner } => inner.0.clone(),
            Self::Fisherman { inner } => inner.0.clone(),
            Self::Fletcher { inner } => inner.0.clone(),
            Self::Leatherworker { inner } => inner.0.clone(),
            Self::Librarian { inner } => inner.0.clone(),
            Self::Mason { inner } => inner.0.clone(),
            Self::Nitwit { inner } => inner.0.clone(),
            Self::Shepherd { inner } => inner.0.clone(),
            Self::Toolsmith { inner } => inner.0.clone(),
            Self::Weaponsmith { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Armorer { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Butcher { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cartographer { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Cleric { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Farmer { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Fisherman { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Fletcher { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Leatherworker { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Librarian { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Mason { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Nitwit { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Shepherd { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Toolsmith { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Weaponsmith { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for VillagerProfession<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate VillagerProfession from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Villager$Profession")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a VillagerProfession object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NONE" => Ok(VillagerProfession::None {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "ARMORER" => Ok(VillagerProfession::Armorer {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "BUTCHER" => Ok(VillagerProfession::Butcher {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "CARTOGRAPHER" => Ok(VillagerProfession::Cartographer {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "CLERIC" => Ok(VillagerProfession::Cleric {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "FARMER" => Ok(VillagerProfession::Farmer {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "FISHERMAN" => Ok(VillagerProfession::Fisherman {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "FLETCHER" => Ok(VillagerProfession::Fletcher {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "LEATHERWORKER" => Ok(VillagerProfession::Leatherworker {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "LIBRARIAN" => Ok(VillagerProfession::Librarian {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "MASON" => Ok(VillagerProfession::Mason {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "NITWIT" => Ok(VillagerProfession::Nitwit {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "SHEPHERD" => Ok(VillagerProfession::Shepherd {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "TOOLSMITH" => Ok(VillagerProfession::Toolsmith {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                "WEAPONSMITH" => Ok(VillagerProfession::Weaponsmith {
                    inner: VillagerProfessionStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for VillagerProfessionStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for VillagerProfessionStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate VillagerProfessionStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Villager$Profession")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a VillagerProfessionStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> VillagerProfessionStruct<'mc> {
    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents an entity which may be saddled, ridden and steered using an item.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Steerable<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Steerable<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Steerable<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Steerable from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Steerable")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Steerable object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Steerable<'mc> {
    pub fn has_saddle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hasSaddle", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if the pig has a saddle or not
    pub fn set_saddle(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSaddle",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn boost_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBoostTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the time in ticks this entity's movement will be increased. This will reset the current boost ticks to 0 (<a href="#getCurrentBoostTicks()"><code>getCurrentBoostTicks()</code></a>).
    pub fn set_boost_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBoostTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn current_boost_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCurrentBoostTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the time in ticks this entity's movement has been increased relative to the most recent boost.
    pub fn set_current_boost_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCurrentBoostTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn steer_material(&self) -> Result<crate::Material<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Material;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getSteerMaterial",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Material::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Steerable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Steerable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Steerable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Steerable<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Steerable into crate::entity::Animals")
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct TippedArrow<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for TippedArrow<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TippedArrow<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate TippedArrow from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TippedArrow")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TippedArrow object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> TippedArrow<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Arrow<'mc>> for TippedArrow<'mc> {
    fn into(self) -> crate::entity::Arrow<'mc> {
        crate::entity::Arrow::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting TippedArrow into crate::entity::Arrow")
    }
}
/// Tropical fish.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct TropicalFish<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for TropicalFish<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TropicalFish<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate TropicalFish from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TropicalFish")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TropicalFish object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> TropicalFish<'mc> {
    pub fn pattern(
        &self,
    ) -> Result<crate::entity::TropicalFishPattern<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/TropicalFish$Pattern;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPattern", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::TropicalFishPattern::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_pattern(
        &self,
        arg0: impl Into<crate::entity::TropicalFishPattern<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/TropicalFish$Pattern;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPattern",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn pattern_color(&self) -> Result<crate::DyeColor<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/DyeColor;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPatternColor", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::DyeColor::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_pattern_color(
        &self,
        arg0: impl Into<crate::DyeColor<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/DyeColor;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPatternColor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn body_color(&self) -> Result<crate::DyeColor<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/DyeColor;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBodyColor", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::DyeColor::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_body_color(
        &self,
        arg0: impl Into<crate::DyeColor<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/DyeColor;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBodyColor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Fish<'mc>> for TropicalFish<'mc> {
    fn into(self) -> crate::entity::Fish<'mc> {
        crate::entity::Fish::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting TropicalFish into crate::entity::Fish")
    }
}
/// Represents a Monster.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Monster<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Monster<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Monster<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Monster from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Monster")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Monster object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Monster<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Creature<'mc>> for Monster<'mc> {
    fn into(self) -> crate::entity::Creature<'mc> {
        crate::entity::Creature::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Monster into crate::entity::Creature")
    }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for Monster<'mc> {
    fn into(self) -> crate::entity::Enemy<'mc> {
        crate::entity::Enemy::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Monster into crate::entity::Enemy")
    }
}
/// Represents a Hoglin.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Hoglin<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Hoglin<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Hoglin<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Hoglin from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Hoglin")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Hoglin object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Hoglin<'mc> {
    pub fn is_immune_to_zombification(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isImmuneToZombification",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the hoglin is immune to zombification.
    pub fn set_immune_to_zombification(
        &self,
        arg0: bool,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setImmuneToZombification",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_converting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isConverting", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn conversion_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getConversionTime",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the amount of ticks until this entity will be converted to a Zoglin. When this reaches 0, the entity will be converted. A value of less than 0 will stop the current conversion process without converting the current entity.
    pub fn set_conversion_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setConversionTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_able_to_be_hunted(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isAbleToBeHunted",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the hoglin is able to be hunted by piglins.
    pub fn set_is_able_to_be_hunted(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setIsAbleToBeHunted",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Hoglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Hoglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Hoglin::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Hoglin<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Hoglin into crate::entity::Animals")
    }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for Hoglin<'mc> {
    fn into(self) -> crate::entity::Enemy<'mc> {
        crate::entity::Enemy::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Hoglin into crate::entity::Enemy")
    }
}
/// Represents a cod fish.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Cod<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Cod<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Cod<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Cod from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Cod")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Cod object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Cod<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Fish<'mc>> for Cod<'mc> {
    fn into(self) -> crate::entity::Fish<'mc> {
        crate::entity::Fish::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Cod into crate::entity::Fish")
    }
}
pub enum Style<'mc> {
    None { inner: StyleStruct<'mc> },
    White { inner: StyleStruct<'mc> },
    Whitefield { inner: StyleStruct<'mc> },
    WhiteDots { inner: StyleStruct<'mc> },
    BlackDots { inner: StyleStruct<'mc> },
}
impl<'mc> std::fmt::Display for Style<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Style::None { .. } => f.write_str("NONE"),
            Style::White { .. } => f.write_str("WHITE"),
            Style::Whitefield { .. } => f.write_str("WHITEFIELD"),
            Style::WhiteDots { .. } => f.write_str("WHITE_DOTS"),
            Style::BlackDots { .. } => f.write_str("BLACK_DOTS"),
        }
    }
}

impl<'mc> Style<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Style<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Style");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Style;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NONE" => Ok(Style::None {
                inner: StyleStruct::from_raw(env, obj)?,
            }),
            "WHITE" => Ok(Style::White {
                inner: StyleStruct::from_raw(env, obj)?,
            }),
            "WHITEFIELD" => Ok(Style::Whitefield {
                inner: StyleStruct::from_raw(env, obj)?,
            }),
            "WHITE_DOTS" => Ok(Style::WhiteDots {
                inner: StyleStruct::from_raw(env, obj)?,
            }),
            "BLACK_DOTS" => Ok(Style::BlackDots {
                inner: StyleStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct StyleStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Style<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::None { inner } => inner.0.clone(),
            Self::White { inner } => inner.0.clone(),
            Self::Whitefield { inner } => inner.0.clone(),
            Self::WhiteDots { inner } => inner.0.clone(),
            Self::BlackDots { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::White { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Whitefield { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::WhiteDots { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlackDots { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Style<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Style from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Style")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Style object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NONE" => Ok(Style::None {
                    inner: StyleStruct::from_raw(env, obj)?,
                }),
                "WHITE" => Ok(Style::White {
                    inner: StyleStruct::from_raw(env, obj)?,
                }),
                "WHITEFIELD" => Ok(Style::Whitefield {
                    inner: StyleStruct::from_raw(env, obj)?,
                }),
                "WHITE_DOTS" => Ok(Style::WhiteDots {
                    inner: StyleStruct::from_raw(env, obj)?,
                }),
                "BLACK_DOTS" => Ok(Style::BlackDots {
                    inner: StyleStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for StyleStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for StyleStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate StyleStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Style")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a StyleStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> StyleStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a Witch
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Witch<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Witch<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Witch<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Witch from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Witch")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Witch object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Witch<'mc> {
    pub fn is_drinking_potion(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isDrinkingPotion",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn set_raid(
        &self,
        arg0: impl Into<crate::Raid<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.set_raid(arg0)
    }
    pub fn raid(&self) -> Result<Option<crate::Raid<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.raid()
    }
    pub fn wave(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.wave()
    }
    pub fn set_wave(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.set_wave(arg0)
    }
    pub fn patrol_target(
        &self,
    ) -> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.patrol_target()
    }
    pub fn set_patrol_target(
        &self,
        arg0: impl Into<crate::block::Block<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.set_patrol_target(arg0)
    }
    pub fn is_patrol_leader(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.is_patrol_leader()
    }
    pub fn set_patrol_leader(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.set_patrol_leader(arg0)
    }
    pub fn is_can_join_raid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.is_can_join_raid()
    }
    pub fn set_can_join_raid(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.set_can_join_raid(arg0)
    }
    pub fn ticks_outside_raid(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.ticks_outside_raid()
    }
    pub fn set_ticks_outside_raid(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.set_ticks_outside_raid(arg0)
    }
    pub fn is_celebrating(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.is_celebrating()
    }
    pub fn set_celebrating(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.set_celebrating(arg0)
    }
    pub fn celebration_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Witch::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Raider = temp_clone.into();
        real.celebration_sound()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Raider<'mc>> for Witch<'mc> {
    fn into(self) -> crate::entity::Raider<'mc> {
        crate::entity::Raider::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Witch into crate::entity::Raider")
    }
}
pub enum Pattern<'mc> {
    Kob { inner: PatternStruct<'mc> },
    Sunstreak { inner: PatternStruct<'mc> },
    Snooper { inner: PatternStruct<'mc> },
    Dasher { inner: PatternStruct<'mc> },
    Brinely { inner: PatternStruct<'mc> },
    Spotty { inner: PatternStruct<'mc> },
    Flopper { inner: PatternStruct<'mc> },
    Stripey { inner: PatternStruct<'mc> },
    Glitter { inner: PatternStruct<'mc> },
    Blockfish { inner: PatternStruct<'mc> },
    Betty { inner: PatternStruct<'mc> },
    Clayfish { inner: PatternStruct<'mc> },
}
impl<'mc> std::fmt::Display for Pattern<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Pattern::Kob { .. } => f.write_str("KOB"),
            Pattern::Sunstreak { .. } => f.write_str("SUNSTREAK"),
            Pattern::Snooper { .. } => f.write_str("SNOOPER"),
            Pattern::Dasher { .. } => f.write_str("DASHER"),
            Pattern::Brinely { .. } => f.write_str("BRINELY"),
            Pattern::Spotty { .. } => f.write_str("SPOTTY"),
            Pattern::Flopper { .. } => f.write_str("FLOPPER"),
            Pattern::Stripey { .. } => f.write_str("STRIPEY"),
            Pattern::Glitter { .. } => f.write_str("GLITTER"),
            Pattern::Blockfish { .. } => f.write_str("BLOCKFISH"),
            Pattern::Betty { .. } => f.write_str("BETTY"),
            Pattern::Clayfish { .. } => f.write_str("CLAYFISH"),
        }
    }
}

impl<'mc> Pattern<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Pattern<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Pattern");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Pattern;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "KOB" => Ok(Pattern::Kob {
                inner: PatternStruct::from_raw(env, obj)?,
            }),
            "SUNSTREAK" => Ok(Pattern::Sunstreak {
                inner: PatternStruct::from_raw(env, obj)?,
            }),
            "SNOOPER" => Ok(Pattern::Snooper {
                inner: PatternStruct::from_raw(env, obj)?,
            }),
            "DASHER" => Ok(Pattern::Dasher {
                inner: PatternStruct::from_raw(env, obj)?,
            }),
            "BRINELY" => Ok(Pattern::Brinely {
                inner: PatternStruct::from_raw(env, obj)?,
            }),
            "SPOTTY" => Ok(Pattern::Spotty {
                inner: PatternStruct::from_raw(env, obj)?,
            }),
            "FLOPPER" => Ok(Pattern::Flopper {
                inner: PatternStruct::from_raw(env, obj)?,
            }),
            "STRIPEY" => Ok(Pattern::Stripey {
                inner: PatternStruct::from_raw(env, obj)?,
            }),
            "GLITTER" => Ok(Pattern::Glitter {
                inner: PatternStruct::from_raw(env, obj)?,
            }),
            "BLOCKFISH" => Ok(Pattern::Blockfish {
                inner: PatternStruct::from_raw(env, obj)?,
            }),
            "BETTY" => Ok(Pattern::Betty {
                inner: PatternStruct::from_raw(env, obj)?,
            }),
            "CLAYFISH" => Ok(Pattern::Clayfish {
                inner: PatternStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct PatternStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Pattern<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Kob { inner } => inner.0.clone(),
            Self::Sunstreak { inner } => inner.0.clone(),
            Self::Snooper { inner } => inner.0.clone(),
            Self::Dasher { inner } => inner.0.clone(),
            Self::Brinely { inner } => inner.0.clone(),
            Self::Spotty { inner } => inner.0.clone(),
            Self::Flopper { inner } => inner.0.clone(),
            Self::Stripey { inner } => inner.0.clone(),
            Self::Glitter { inner } => inner.0.clone(),
            Self::Blockfish { inner } => inner.0.clone(),
            Self::Betty { inner } => inner.0.clone(),
            Self::Clayfish { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Kob { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Sunstreak { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Snooper { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Dasher { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Brinely { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Spotty { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Flopper { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Stripey { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Glitter { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Blockfish { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Betty { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Clayfish { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Pattern<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Pattern from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Pattern")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Pattern object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "KOB" => Ok(Pattern::Kob {
                    inner: PatternStruct::from_raw(env, obj)?,
                }),
                "SUNSTREAK" => Ok(Pattern::Sunstreak {
                    inner: PatternStruct::from_raw(env, obj)?,
                }),
                "SNOOPER" => Ok(Pattern::Snooper {
                    inner: PatternStruct::from_raw(env, obj)?,
                }),
                "DASHER" => Ok(Pattern::Dasher {
                    inner: PatternStruct::from_raw(env, obj)?,
                }),
                "BRINELY" => Ok(Pattern::Brinely {
                    inner: PatternStruct::from_raw(env, obj)?,
                }),
                "SPOTTY" => Ok(Pattern::Spotty {
                    inner: PatternStruct::from_raw(env, obj)?,
                }),
                "FLOPPER" => Ok(Pattern::Flopper {
                    inner: PatternStruct::from_raw(env, obj)?,
                }),
                "STRIPEY" => Ok(Pattern::Stripey {
                    inner: PatternStruct::from_raw(env, obj)?,
                }),
                "GLITTER" => Ok(Pattern::Glitter {
                    inner: PatternStruct::from_raw(env, obj)?,
                }),
                "BLOCKFISH" => Ok(Pattern::Blockfish {
                    inner: PatternStruct::from_raw(env, obj)?,
                }),
                "BETTY" => Ok(Pattern::Betty {
                    inner: PatternStruct::from_raw(env, obj)?,
                }),
                "CLAYFISH" => Ok(Pattern::Clayfish {
                    inner: PatternStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for PatternStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for PatternStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate PatternStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Pattern")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PatternStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> PatternStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Tameable<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Tameable<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Tameable<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Tameable from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Tameable")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Tameable object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Tameable<'mc> {
    pub fn owner(
        &self,
    ) -> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/AnimalTamer;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getOwner", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::AnimalTamer::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_owner(
        &self,
        arg0: impl Into<crate::entity::AnimalTamer<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/AnimalTamer;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setOwner",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_tamed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isTamed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if this has been tamed. Not necessary if the method setOwner has been used, as it tames automatically.
    /// <p>If something is tamed then a player can not tame it through normal methods, even if it does not belong to anyone in particular.</p>
    pub fn set_tamed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTamed",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Tameable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Tameable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Tameable::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Tameable<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Tameable into crate::entity::Animals")
    }
}
/// Represents a thrown Ender Pearl entity
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct EnderPearl<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EnderPearl<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EnderPearl<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate EnderPearl from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderPearl")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EnderPearl object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EnderPearl<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::ThrowableProjectile<'mc>> for EnderPearl<'mc> {
    fn into(self) -> crate::entity::ThrowableProjectile<'mc> {
        crate::entity::ThrowableProjectile::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting EnderPearl into crate::entity::ThrowableProjectile")
    }
}
/// Represents a Mule - variant of <a title="interface in org.bukkit.entity" href="ChestedHorse.html"><code>ChestedHorse</code></a>.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Mule<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Mule<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Mule<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Mule from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Mule")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Mule object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Mule<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::ChestedHorse<'mc>> for Mule<'mc> {
    fn into(self) -> crate::entity::ChestedHorse<'mc> {
        crate::entity::ChestedHorse::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Mule into crate::entity::ChestedHorse")
    }
}
/// Represents types of locking mechanisms for ArmorStand equipment.
pub enum ArmorStandLockType<'mc> {
    AddingOrChanging {
        inner: ArmorStandLockTypeStruct<'mc>,
    },
    RemovingOrChanging {
        inner: ArmorStandLockTypeStruct<'mc>,
    },
    Adding {
        inner: ArmorStandLockTypeStruct<'mc>,
    },
}
impl<'mc> std::fmt::Display for ArmorStandLockType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ArmorStandLockType::AddingOrChanging { .. } => f.write_str("ADDING_OR_CHANGING"),
            ArmorStandLockType::RemovingOrChanging { .. } => f.write_str("REMOVING_OR_CHANGING"),
            ArmorStandLockType::Adding { .. } => f.write_str("ADDING"),
        }
    }
}

impl<'mc> ArmorStandLockType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<ArmorStandLockType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/ArmorStand$LockType");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/ArmorStand$LockType;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "ADDING_OR_CHANGING" => Ok(ArmorStandLockType::AddingOrChanging {
                inner: ArmorStandLockTypeStruct::from_raw(env, obj)?,
            }),
            "REMOVING_OR_CHANGING" => Ok(ArmorStandLockType::RemovingOrChanging {
                inner: ArmorStandLockTypeStruct::from_raw(env, obj)?,
            }),
            "ADDING" => Ok(ArmorStandLockType::Adding {
                inner: ArmorStandLockTypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct ArmorStandLockTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ArmorStandLockType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::AddingOrChanging { inner } => inner.0.clone(),
            Self::RemovingOrChanging { inner } => inner.0.clone(),
            Self::Adding { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::AddingOrChanging { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::RemovingOrChanging { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Adding { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ArmorStandLockType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ArmorStandLockType from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ArmorStand$LockType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ArmorStandLockType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "ADDING_OR_CHANGING" => Ok(ArmorStandLockType::AddingOrChanging {
                    inner: ArmorStandLockTypeStruct::from_raw(env, obj)?,
                }),
                "REMOVING_OR_CHANGING" => Ok(ArmorStandLockType::RemovingOrChanging {
                    inner: ArmorStandLockTypeStruct::from_raw(env, obj)?,
                }),
                "ADDING" => Ok(ArmorStandLockType::Adding {
                    inner: ArmorStandLockTypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for ArmorStandLockTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ArmorStandLockTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate ArmorStandLockTypeStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ArmorStand$LockType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ArmorStandLockTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ArmorStandLockTypeStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// A baby <a href="Frog.html" title="interface in org.bukkit.entity"><code>Frog</code></a>.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Tadpole<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Tadpole<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Tadpole<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Tadpole from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Tadpole")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Tadpole object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Tadpole<'mc> {
    pub fn age(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getAge", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the age of this mob.
    pub fn set_age(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAge",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Fish<'mc>> for Tadpole<'mc> {
    fn into(self) -> crate::entity::Fish<'mc> {
        crate::entity::Fish::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Tadpole into crate::entity::Fish")
    }
}
/// Represents a Cow.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Cow<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Cow<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Cow<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Cow from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Cow")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Cow object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Cow<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Cow<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Cow into crate::entity::Animals")
    }
}
/// Represents an Experience Orb.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ExperienceOrb<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ExperienceOrb<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ExperienceOrb<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ExperienceOrb from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ExperienceOrb")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ExperienceOrb object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ExperienceOrb<'mc> {
    pub fn experience(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getExperience", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets how much experience is contained within this orb
    pub fn set_experience(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setExperience",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ExperienceOrb::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for ExperienceOrb<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ExperienceOrb into crate::entity::Entity")
    }
}
/// Represents the base color that the horse has.
pub enum HorseColor<'mc> {
    White { inner: HorseColorStruct<'mc> },
    Creamy { inner: HorseColorStruct<'mc> },
    Chestnut { inner: HorseColorStruct<'mc> },
    Brown { inner: HorseColorStruct<'mc> },
    Black { inner: HorseColorStruct<'mc> },
    Gray { inner: HorseColorStruct<'mc> },
    DarkBrown { inner: HorseColorStruct<'mc> },
}
impl<'mc> std::fmt::Display for HorseColor<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HorseColor::White { .. } => f.write_str("WHITE"),
            HorseColor::Creamy { .. } => f.write_str("CREAMY"),
            HorseColor::Chestnut { .. } => f.write_str("CHESTNUT"),
            HorseColor::Brown { .. } => f.write_str("BROWN"),
            HorseColor::Black { .. } => f.write_str("BLACK"),
            HorseColor::Gray { .. } => f.write_str("GRAY"),
            HorseColor::DarkBrown { .. } => f.write_str("DARK_BROWN"),
        }
    }
}

impl<'mc> HorseColor<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<HorseColor<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Horse$Color");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Horse$Color;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "WHITE" => Ok(HorseColor::White {
                inner: HorseColorStruct::from_raw(env, obj)?,
            }),
            "CREAMY" => Ok(HorseColor::Creamy {
                inner: HorseColorStruct::from_raw(env, obj)?,
            }),
            "CHESTNUT" => Ok(HorseColor::Chestnut {
                inner: HorseColorStruct::from_raw(env, obj)?,
            }),
            "BROWN" => Ok(HorseColor::Brown {
                inner: HorseColorStruct::from_raw(env, obj)?,
            }),
            "BLACK" => Ok(HorseColor::Black {
                inner: HorseColorStruct::from_raw(env, obj)?,
            }),
            "GRAY" => Ok(HorseColor::Gray {
                inner: HorseColorStruct::from_raw(env, obj)?,
            }),
            "DARK_BROWN" => Ok(HorseColor::DarkBrown {
                inner: HorseColorStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct HorseColorStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for HorseColor<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::White { inner } => inner.0.clone(),
            Self::Creamy { inner } => inner.0.clone(),
            Self::Chestnut { inner } => inner.0.clone(),
            Self::Brown { inner } => inner.0.clone(),
            Self::Black { inner } => inner.0.clone(),
            Self::Gray { inner } => inner.0.clone(),
            Self::DarkBrown { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::White { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Creamy { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Chestnut { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Brown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Black { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Gray { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::DarkBrown { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for HorseColor<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate HorseColor from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse$Color")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a HorseColor object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "WHITE" => Ok(HorseColor::White {
                    inner: HorseColorStruct::from_raw(env, obj)?,
                }),
                "CREAMY" => Ok(HorseColor::Creamy {
                    inner: HorseColorStruct::from_raw(env, obj)?,
                }),
                "CHESTNUT" => Ok(HorseColor::Chestnut {
                    inner: HorseColorStruct::from_raw(env, obj)?,
                }),
                "BROWN" => Ok(HorseColor::Brown {
                    inner: HorseColorStruct::from_raw(env, obj)?,
                }),
                "BLACK" => Ok(HorseColor::Black {
                    inner: HorseColorStruct::from_raw(env, obj)?,
                }),
                "GRAY" => Ok(HorseColor::Gray {
                    inner: HorseColorStruct::from_raw(env, obj)?,
                }),
                "DARK_BROWN" => Ok(HorseColor::DarkBrown {
                    inner: HorseColorStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for HorseColorStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for HorseColorStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate HorseColorStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse$Color")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a HorseColorStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> HorseColorStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a Pig.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Pig<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Pig<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Pig<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Pig from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Pig")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Pig object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Pig<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Steerable<'mc>> for Pig<'mc> {
    fn into(self) -> crate::entity::Steerable<'mc> {
        crate::entity::Steerable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Pig into crate::entity::Steerable")
    }
}
impl<'mc> Into<crate::entity::Vehicle<'mc>> for Pig<'mc> {
    fn into(self) -> crate::entity::Vehicle<'mc> {
        crate::entity::Vehicle::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Pig into crate::entity::Vehicle")
    }
}
/// Represents an Illusioner "Illager".
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Illusioner<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Illusioner<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Illusioner<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Illusioner from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Illusioner")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Illusioner object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Illusioner<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Spellcaster<'mc>> for Illusioner<'mc> {
    fn into(self) -> crate::entity::Spellcaster<'mc> {
        crate::entity::Spellcaster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Illusioner into crate::entity::Spellcaster")
    }
}
/// Represents a shootable entity.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Projectile<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Projectile<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Projectile<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Projectile from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Projectile")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Projectile object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Projectile<'mc> {
    pub fn shooter(
        &self,
    ) -> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/projectiles/ProjectileSource;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getShooter", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::projectiles::ProjectileSource::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_shooter(
        &self,
        arg0: impl Into<crate::projectiles::ProjectileSource<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/projectiles/ProjectileSource;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setShooter",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn does_bounce(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "doesBounce", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set whether or not this projectile should bounce or not when it hits something.
    pub fn set_bounce(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBounce",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Projectile::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Projectile<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Projectile into crate::entity::Entity")
    }
}
pub enum Type<'mc> {
    WildOcelot { inner: TypeStruct<'mc> },
    BlackCat { inner: TypeStruct<'mc> },
    RedCat { inner: TypeStruct<'mc> },
    SiameseCat { inner: TypeStruct<'mc> },
}
impl<'mc> std::fmt::Display for Type<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Type::WildOcelot { .. } => f.write_str("WILD_OCELOT"),
            Type::BlackCat { .. } => f.write_str("BLACK_CAT"),
            Type::RedCat { .. } => f.write_str("RED_CAT"),
            Type::SiameseCat { .. } => f.write_str("SIAMESE_CAT"),
        }
    }
}

impl<'mc> Type<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Type<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Type");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Type;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "WILD_OCELOT" => Ok(Type::WildOcelot {
                inner: TypeStruct::from_raw(env, obj)?,
            }),
            "BLACK_CAT" => Ok(Type::BlackCat {
                inner: TypeStruct::from_raw(env, obj)?,
            }),
            "RED_CAT" => Ok(Type::RedCat {
                inner: TypeStruct::from_raw(env, obj)?,
            }),
            "SIAMESE_CAT" => Ok(Type::SiameseCat {
                inner: TypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct TypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Type<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::WildOcelot { inner } => inner.0.clone(),
            Self::BlackCat { inner } => inner.0.clone(),
            Self::RedCat { inner } => inner.0.clone(),
            Self::SiameseCat { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::WildOcelot { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlackCat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::RedCat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::SiameseCat { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Type<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Type from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Type object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "WILD_OCELOT" => Ok(Type::WildOcelot {
                    inner: TypeStruct::from_raw(env, obj)?,
                }),
                "BLACK_CAT" => Ok(Type::BlackCat {
                    inner: TypeStruct::from_raw(env, obj)?,
                }),
                "RED_CAT" => Ok(Type::RedCat {
                    inner: TypeStruct::from_raw(env, obj)?,
                }),
                "SIAMESE_CAT" => Ok(Type::SiameseCat {
                    inner: TypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for TypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate TypeStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> TypeStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}

#[repr(C)]
pub struct EntitySpigot<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EntitySpigot<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EntitySpigot<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate EntitySpigot from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Entity$Spigot")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EntitySpigot object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EntitySpigot<'mc> {
    pub fn new(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::entity::EntitySpigot<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let cls = jni.find_class("org/bukkit/entity/Entity$Spigot");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.new_object(cls, sig.as_str(), vec![]);
        let res = jni.translate_error_no_gen(res)?;
        crate::entity::EntitySpigot::from_raw(&jni, res)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::command::CommandSenderSpigot<'mc>> for EntitySpigot<'mc> {
    fn into(self) -> crate::command::CommandSenderSpigot<'mc> {
        crate::command::CommandSenderSpigot::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting EntitySpigot into crate::command::CommandSenderSpigot")
    }
}
/// Represents a Blaze monster
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Blaze<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Blaze<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Blaze<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Blaze from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Blaze")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Blaze object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Blaze<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Blaze<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Blaze into crate::entity::Monster")
    }
}
/// Represents an ender dragon part
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct EnderDragonPart<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EnderDragonPart<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EnderDragonPart<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate EnderDragonPart from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderDragonPart")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EnderDragonPart object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EnderDragonPart<'mc> {
    pub fn parent(
        &self,
    ) -> Result<crate::entity::ComplexLivingEntity<'mc>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Lorg/bukkit/entity/ComplexLivingEntity;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getParent", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::ComplexLivingEntity::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn damage_with_double(
        &self,
        arg0: f64,
        arg1: std::option::Option<impl Into<crate::entity::Entity<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "D";
        let val_1 = jni::objects::JValueGen::Double(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/entity/Entity;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "damage", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn health(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = EnderDragonPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.health()
    }
    pub fn set_health(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderDragonPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.set_health(arg0)
    }
    pub fn absorption_amount(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = EnderDragonPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.absorption_amount()
    }
    pub fn set_absorption_amount(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderDragonPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.set_absorption_amount(arg0)
    }

    pub fn max_health(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = EnderDragonPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.max_health()
    }

    pub fn set_max_health(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderDragonPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.set_max_health(arg0)
    }

    pub fn reset_max_health(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderDragonPart::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.reset_max_health()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::ComplexEntityPart<'mc>> for EnderDragonPart<'mc> {
    fn into(self) -> crate::entity::ComplexEntityPart<'mc> {
        crate::entity::ComplexEntityPart::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting EnderDragonPart into crate::entity::ComplexEntityPart")
    }
}
impl<'mc> Into<crate::entity::Damageable<'mc>> for EnderDragonPart<'mc> {
    fn into(self) -> crate::entity::Damageable<'mc> {
        crate::entity::Damageable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting EnderDragonPart into crate::entity::Damageable")
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct AnimalTamer<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for AnimalTamer<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for AnimalTamer<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate AnimalTamer from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AnimalTamer")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a AnimalTamer object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> AnimalTamer<'mc> {
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/UUID;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getUniqueId", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn name(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getName", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a wither skull <a href="Fireball.html" title="interface in org.bukkit.entity"><code>Fireball</code></a>.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct WitherSkull<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for WitherSkull<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WitherSkull<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate WitherSkull from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/WitherSkull")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WitherSkull object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> WitherSkull<'mc> {
    /// Sets the charged status of the wither skull.
    pub fn set_charged(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCharged",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_charged(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isCharged", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn direction(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = WitherSkull::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Fireball = temp_clone.into();
        real.direction()
    }
    pub fn set_direction(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = WitherSkull::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Fireball = temp_clone.into();
        real.set_direction(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Fireball<'mc>> for WitherSkull<'mc> {
    fn into(self) -> crate::entity::Fireball<'mc> {
        crate::entity::Fireball::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting WitherSkull into crate::entity::Fireball")
    }
}
pub enum TypeType<'mc> {
    Desert { inner: TypeTypeStruct<'mc> },
    Jungle { inner: TypeTypeStruct<'mc> },
    Plains { inner: TypeTypeStruct<'mc> },
    Savanna { inner: TypeTypeStruct<'mc> },
    Snow { inner: TypeTypeStruct<'mc> },
    Swamp { inner: TypeTypeStruct<'mc> },
    Taiga { inner: TypeTypeStruct<'mc> },
}
impl<'mc> std::fmt::Display for TypeType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TypeType::Desert { .. } => f.write_str("DESERT"),
            TypeType::Jungle { .. } => f.write_str("JUNGLE"),
            TypeType::Plains { .. } => f.write_str("PLAINS"),
            TypeType::Savanna { .. } => f.write_str("SAVANNA"),
            TypeType::Snow { .. } => f.write_str("SNOW"),
            TypeType::Swamp { .. } => f.write_str("SWAMP"),
            TypeType::Taiga { .. } => f.write_str("TAIGA"),
        }
    }
}

impl<'mc> TypeType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<TypeType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Type$Type");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Type$Type;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "DESERT" => Ok(TypeType::Desert {
                inner: TypeTypeStruct::from_raw(env, obj)?,
            }),
            "JUNGLE" => Ok(TypeType::Jungle {
                inner: TypeTypeStruct::from_raw(env, obj)?,
            }),
            "PLAINS" => Ok(TypeType::Plains {
                inner: TypeTypeStruct::from_raw(env, obj)?,
            }),
            "SAVANNA" => Ok(TypeType::Savanna {
                inner: TypeTypeStruct::from_raw(env, obj)?,
            }),
            "SNOW" => Ok(TypeType::Snow {
                inner: TypeTypeStruct::from_raw(env, obj)?,
            }),
            "SWAMP" => Ok(TypeType::Swamp {
                inner: TypeTypeStruct::from_raw(env, obj)?,
            }),
            "TAIGA" => Ok(TypeType::Taiga {
                inner: TypeTypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct TypeTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for TypeType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Desert { inner } => inner.0.clone(),
            Self::Jungle { inner } => inner.0.clone(),
            Self::Plains { inner } => inner.0.clone(),
            Self::Savanna { inner } => inner.0.clone(),
            Self::Snow { inner } => inner.0.clone(),
            Self::Swamp { inner } => inner.0.clone(),
            Self::Taiga { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Desert { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Jungle { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Plains { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Savanna { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Snow { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Swamp { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Taiga { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TypeType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate TypeType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Type$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TypeType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "DESERT" => Ok(TypeType::Desert {
                    inner: TypeTypeStruct::from_raw(env, obj)?,
                }),
                "JUNGLE" => Ok(TypeType::Jungle {
                    inner: TypeTypeStruct::from_raw(env, obj)?,
                }),
                "PLAINS" => Ok(TypeType::Plains {
                    inner: TypeTypeStruct::from_raw(env, obj)?,
                }),
                "SAVANNA" => Ok(TypeType::Savanna {
                    inner: TypeTypeStruct::from_raw(env, obj)?,
                }),
                "SNOW" => Ok(TypeType::Snow {
                    inner: TypeTypeStruct::from_raw(env, obj)?,
                }),
                "SWAMP" => Ok(TypeType::Swamp {
                    inner: TypeTypeStruct::from_raw(env, obj)?,
                }),
                "TAIGA" => Ok(TypeType::Taiga {
                    inner: TypeTypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for TypeTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TypeTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate TypeTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Type$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TypeTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> TypeTypeStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a boat entity.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Boat<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Boat<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Boat<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Boat from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Boat")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Boat object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Boat<'mc> {
    pub fn max_speed(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxSpeed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// <span class="deprecated-label">Deprecated.</span>
    /// <div class="deprecation-comment">
    /// boats are complex and many of these methods do not work correctly across multiple versions.
    /// </div>
    /// boats are complex and many of these methods do not work correctly across multiple versions.
    ///
    /// Sets the maximum speed of a boat. Must be nonnegative. Default is 0.4D.
    pub fn set_max_speed(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaxSpeed",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn status(&self) -> Result<crate::entity::BoatStatus<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Boat$Status;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getStatus", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::BoatStatus::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    #[deprecated]

    pub fn wood_type(&self) -> Result<crate::TreeSpecies<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/TreeSpecies;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getWoodType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::TreeSpecies::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_wood_type(
        &self,
        arg0: impl Into<crate::TreeSpecies<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/TreeSpecies;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWoodType",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn boat_type(&self) -> Result<crate::entity::BoatType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Boat$Type;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBoatType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::BoatType::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_boat_type(
        &self,
        arg0: impl Into<crate::entity::BoatType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Boat$Type;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBoatType",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn occupied_deceleration(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getOccupiedDeceleration",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    #[deprecated = "boats are complex and many of these methods do not work correctly across multiple versions. "]
    /// Sets the deceleration rate (newSpeed = curSpeed * rate) of occupied boats. Setting this to a higher value allows for quicker acceleration. The default is 0.2.
    pub fn set_occupied_deceleration(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setOccupiedDeceleration",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn unoccupied_deceleration(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getUnoccupiedDeceleration",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    #[deprecated = "boats are complex and many of these methods do not work correctly across multiple versions. "]
    /// Sets the deceleration rate (newSpeed = curSpeed * rate) of unoccupied boats. Setting this to a higher value allows for quicker deceleration of boats when a player disembarks. The default is -1. Values below 0 indicate that no additional deceleration is imposed.
    pub fn set_unoccupied_deceleration(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setUnoccupiedDeceleration",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn work_on_land(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getWorkOnLand", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated = "boats are complex and many of these methods do not work correctly across multiple versions. "]
    /// Set whether boats can work on land.
    pub fn set_work_on_land(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWorkOnLand",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boat::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Vehicle = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boat::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Vehicle = temp_clone.into();
        real.velocity()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Vehicle<'mc>> for Boat<'mc> {
    fn into(self) -> crate::entity::Vehicle<'mc> {
        crate::entity::Vehicle::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Boat into crate::entity::Vehicle")
    }
}
/// Represents a Horse-like creature.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct AbstractHorse<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for AbstractHorse<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for AbstractHorse<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate AbstractHorse from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/AbstractHorse")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a AbstractHorse object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> AbstractHorse<'mc> {
    pub fn variant(&self) -> Result<crate::entity::HorseVariant<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Horse$Variant;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getVariant", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::HorseVariant::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn inventory(
        &self,
    ) -> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Lorg/bukkit/inventory/Inventory;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getInventory", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::Inventory::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_variant(
        &self,
        arg0: impl Into<crate::entity::HorseVariant<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Horse$Variant;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVariant",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn domestication(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDomestication",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the domestication level of this horse.
    /// <p>Setting the domestication level to a high value will increase the horse's chances of becoming tame.</p>
    /// <p>Domestication level must be greater than zero and no greater than the max domestication level of the horse, determined with <a href="#getMaxDomestication()"><code>getMaxDomestication()</code></a></p>
    pub fn set_domestication(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDomestication",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn max_domestication(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxDomestication",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the maximum domestication level of this horse.
    /// <p>Setting a higher max domestication will increase the amount of domesticating (feeding, riding, etc.) necessary in order to tame it, while setting a lower max value will have the opposite effect.</p>
    /// <p>Maximum domestication must be greater than zero.</p>
    pub fn set_max_domestication(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaxDomestication",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn jump_strength(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getJumpStrength", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Sets the jump strength of this horse.
    /// <p>A higher jump strength increases how high a jump will go. Setting a jump strength to 0 will result in no jump. You cannot set a jump strength to a value below 0 or above 2.</p>
    pub fn set_jump_strength(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setJumpStrength",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_eating_haystack(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isEatingHaystack",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the horse is grazing hay.
    pub fn set_eating_haystack(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setEatingHaystack",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AbstractHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Vehicle = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = AbstractHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Vehicle = temp_clone.into();
        real.velocity()
    }
    pub fn owner(
        &self,
    ) -> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = AbstractHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.owner()
    }
    pub fn set_owner(
        &self,
        arg0: impl Into<crate::entity::AnimalTamer<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AbstractHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.set_owner(arg0)
    }
    pub fn is_tamed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = AbstractHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.is_tamed()
    }
    pub fn set_tamed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = AbstractHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.set_tamed(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Vehicle<'mc>> for AbstractHorse<'mc> {
    fn into(self) -> crate::entity::Vehicle<'mc> {
        crate::entity::Vehicle::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting AbstractHorse into crate::entity::Vehicle")
    }
}
impl<'mc> Into<crate::inventory::InventoryHolder<'mc>> for AbstractHorse<'mc> {
    fn into(self) -> crate::inventory::InventoryHolder<'mc> {
        crate::inventory::InventoryHolder::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting AbstractHorse into crate::inventory::InventoryHolder")
    }
}
impl<'mc> Into<crate::entity::Tameable<'mc>> for AbstractHorse<'mc> {
    fn into(self) -> crate::entity::Tameable<'mc> {
        crate::entity::Tameable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting AbstractHorse into crate::entity::Tameable")
    }
}
/// Represents possible text alignments for this display.
pub enum TextDisplayTextAlignment<'mc> {
    Center {
        inner: TextDisplayTextAlignmentStruct<'mc>,
    },
    Left {
        inner: TextDisplayTextAlignmentStruct<'mc>,
    },
    Right {
        inner: TextDisplayTextAlignmentStruct<'mc>,
    },
}
impl<'mc> std::fmt::Display for TextDisplayTextAlignment<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TextDisplayTextAlignment::Center { .. } => f.write_str("CENTER"),
            TextDisplayTextAlignment::Left { .. } => f.write_str("LEFT"),
            TextDisplayTextAlignment::Right { .. } => f.write_str("RIGHT"),
        }
    }
}

impl<'mc> TextDisplayTextAlignment<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<TextDisplayTextAlignment<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/TextDisplay$TextAlignment");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/TextDisplay$TextAlignment;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "CENTER" => Ok(TextDisplayTextAlignment::Center {
                inner: TextDisplayTextAlignmentStruct::from_raw(env, obj)?,
            }),
            "LEFT" => Ok(TextDisplayTextAlignment::Left {
                inner: TextDisplayTextAlignmentStruct::from_raw(env, obj)?,
            }),
            "RIGHT" => Ok(TextDisplayTextAlignment::Right {
                inner: TextDisplayTextAlignmentStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct TextDisplayTextAlignmentStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for TextDisplayTextAlignment<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Center { inner } => inner.0.clone(),
            Self::Left { inner } => inner.0.clone(),
            Self::Right { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Center { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Left { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Right { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TextDisplayTextAlignment<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate TextDisplayTextAlignment from null object."
            )
            .into());
        }
        let (valid, name) =
            env.validate_name(&obj, "org/bukkit/entity/TextDisplay$TextAlignment")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TextDisplayTextAlignment object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "CENTER" => Ok(TextDisplayTextAlignment::Center {
                    inner: TextDisplayTextAlignmentStruct::from_raw(env, obj)?,
                }),
                "LEFT" => Ok(TextDisplayTextAlignment::Left {
                    inner: TextDisplayTextAlignmentStruct::from_raw(env, obj)?,
                }),
                "RIGHT" => Ok(TextDisplayTextAlignment::Right {
                    inner: TextDisplayTextAlignmentStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for TextDisplayTextAlignmentStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TextDisplayTextAlignmentStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate TextDisplayTextAlignmentStruct from null object."
            )
            .into());
        }
        let (valid, name) =
            env.validate_name(&obj, "org/bukkit/entity/TextDisplay$TextAlignment")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TextDisplayTextAlignmentStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> TextDisplayTextAlignmentStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents the type of boats.
pub enum BoatType<'mc> {
    Oak { inner: BoatTypeStruct<'mc> },
    Spruce { inner: BoatTypeStruct<'mc> },
    Birch { inner: BoatTypeStruct<'mc> },
    Jungle { inner: BoatTypeStruct<'mc> },
    Acacia { inner: BoatTypeStruct<'mc> },
    Cherry { inner: BoatTypeStruct<'mc> },
    DarkOak { inner: BoatTypeStruct<'mc> },
    Mangrove { inner: BoatTypeStruct<'mc> },
    Bamboo { inner: BoatTypeStruct<'mc> },
}
impl<'mc> std::fmt::Display for BoatType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            BoatType::Oak { .. } => f.write_str("OAK"),
            BoatType::Spruce { .. } => f.write_str("SPRUCE"),
            BoatType::Birch { .. } => f.write_str("BIRCH"),
            BoatType::Jungle { .. } => f.write_str("JUNGLE"),
            BoatType::Acacia { .. } => f.write_str("ACACIA"),
            BoatType::Cherry { .. } => f.write_str("CHERRY"),
            BoatType::DarkOak { .. } => f.write_str("DARK_OAK"),
            BoatType::Mangrove { .. } => f.write_str("MANGROVE"),
            BoatType::Bamboo { .. } => f.write_str("BAMBOO"),
        }
    }
}

impl<'mc> BoatType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<BoatType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Boat$Type");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Boat$Type;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "OAK" => Ok(BoatType::Oak {
                inner: BoatTypeStruct::from_raw(env, obj)?,
            }),
            "SPRUCE" => Ok(BoatType::Spruce {
                inner: BoatTypeStruct::from_raw(env, obj)?,
            }),
            "BIRCH" => Ok(BoatType::Birch {
                inner: BoatTypeStruct::from_raw(env, obj)?,
            }),
            "JUNGLE" => Ok(BoatType::Jungle {
                inner: BoatTypeStruct::from_raw(env, obj)?,
            }),
            "ACACIA" => Ok(BoatType::Acacia {
                inner: BoatTypeStruct::from_raw(env, obj)?,
            }),
            "CHERRY" => Ok(BoatType::Cherry {
                inner: BoatTypeStruct::from_raw(env, obj)?,
            }),
            "DARK_OAK" => Ok(BoatType::DarkOak {
                inner: BoatTypeStruct::from_raw(env, obj)?,
            }),
            "MANGROVE" => Ok(BoatType::Mangrove {
                inner: BoatTypeStruct::from_raw(env, obj)?,
            }),
            "BAMBOO" => Ok(BoatType::Bamboo {
                inner: BoatTypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct BoatTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for BoatType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Oak { inner } => inner.0.clone(),
            Self::Spruce { inner } => inner.0.clone(),
            Self::Birch { inner } => inner.0.clone(),
            Self::Jungle { inner } => inner.0.clone(),
            Self::Acacia { inner } => inner.0.clone(),
            Self::Cherry { inner } => inner.0.clone(),
            Self::DarkOak { inner } => inner.0.clone(),
            Self::Mangrove { inner } => inner.0.clone(),
            Self::Bamboo { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Oak { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Spruce { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Birch { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Jungle { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Acacia { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cherry { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::DarkOak { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Mangrove { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Bamboo { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for BoatType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate BoatType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Boat$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a BoatType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "OAK" => Ok(BoatType::Oak {
                    inner: BoatTypeStruct::from_raw(env, obj)?,
                }),
                "SPRUCE" => Ok(BoatType::Spruce {
                    inner: BoatTypeStruct::from_raw(env, obj)?,
                }),
                "BIRCH" => Ok(BoatType::Birch {
                    inner: BoatTypeStruct::from_raw(env, obj)?,
                }),
                "JUNGLE" => Ok(BoatType::Jungle {
                    inner: BoatTypeStruct::from_raw(env, obj)?,
                }),
                "ACACIA" => Ok(BoatType::Acacia {
                    inner: BoatTypeStruct::from_raw(env, obj)?,
                }),
                "CHERRY" => Ok(BoatType::Cherry {
                    inner: BoatTypeStruct::from_raw(env, obj)?,
                }),
                "DARK_OAK" => Ok(BoatType::DarkOak {
                    inner: BoatTypeStruct::from_raw(env, obj)?,
                }),
                "MANGROVE" => Ok(BoatType::Mangrove {
                    inner: BoatTypeStruct::from_raw(env, obj)?,
                }),
                "BAMBOO" => Ok(BoatType::Bamboo {
                    inner: BoatTypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for BoatTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for BoatTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate BoatTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Boat$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a BoatTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> BoatTypeStruct<'mc> {
    pub fn material(&self) -> Result<crate::Material<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Material;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaterial", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Material::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a Vex.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Vex<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Vex<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Vex<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Vex from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Vex")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Vex object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Vex<'mc> {
    pub fn is_charging(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isCharging", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets the charging state of this entity. When this entity is charging it will having a glowing red texture.
    pub fn set_charging(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCharging",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn bound(&self) -> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBound", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn set_bound(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBound",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn life_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLifeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the remaining lifespan of this entity.
    pub fn set_life_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLifeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn has_limited_life(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "hasLimitedLife", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Vex<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Vex into crate::entity::Monster")
    }
}
/// Represents an Item Frame
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ItemFrame<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ItemFrame<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ItemFrame<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ItemFrame from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ItemFrame")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ItemFrame object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ItemFrame<'mc> {
    pub fn item(&self) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getItem", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_item_with_item_stack(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
        arg1: std::option::Option<bool>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/inventory/ItemStack;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Z";
            let val_2 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "setItem", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn item_drop_chance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getItemDropChance",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the chance of the off hand item being dropped upon this frame's destruction.
    /// <ul>
    /// <li>A drop chance of 0.0F will never drop</li>
    /// <li>A drop chance of 1.0F will always drop</li>
    /// </ul>
    pub fn set_item_drop_chance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setItemDropChance",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn rotation(&self) -> Result<crate::Rotation<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Rotation;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getRotation", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Rotation::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_rotation(
        &self,
        arg0: impl Into<crate::Rotation<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Rotation;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRotation",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isVisible", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the item frame should be visible or not.
    pub fn set_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVisible",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_fixed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isFixed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the item frame should be fixed or not. When set to true it's not possible to destroy/move the frame (e.g. by damage, interaction, pistons, or missing supporting blocks), rotate the item or place/remove items.
    pub fn set_fixed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFixed",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_facing_direction(
        &self,
        arg0: impl Into<crate::block::BlockFace<'mc>>,
        arg1: bool,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ItemFrame::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Hanging = temp_clone.into();
        real.set_facing_direction(arg0, arg1)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Hanging<'mc>> for ItemFrame<'mc> {
    fn into(self) -> crate::entity::Hanging<'mc> {
        crate::entity::Hanging::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ItemFrame into crate::entity::Hanging")
    }
}
/// Represents a spectral arrow.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct SpectralArrow<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SpectralArrow<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SpectralArrow<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SpectralArrow from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SpectralArrow")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SpectralArrow object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SpectralArrow<'mc> {
    pub fn glowing_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getGlowingTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the amount of time to apply the glowing effect for.
    pub fn set_glowing_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setGlowingTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_damage(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = SpectralArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.set_damage(arg0)
    }
    pub fn damage(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = SpectralArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.damage()
    }
    pub fn knockback_strength(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = SpectralArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.knockback_strength()
    }
    pub fn set_knockback_strength(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = SpectralArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.set_knockback_strength(arg0)
    }
    pub fn pierce_level(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = SpectralArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.pierce_level()
    }
    pub fn set_pierce_level(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = SpectralArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.set_pierce_level(arg0)
    }
    pub fn is_critical(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = SpectralArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.is_critical()
    }
    pub fn set_critical(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = SpectralArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.set_critical(arg0)
    }
    pub fn is_in_block(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = SpectralArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.is_in_block()
    }
    pub fn attached_block(
        &self,
    ) -> Result<Option<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = SpectralArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.attached_block()
    }
    pub fn pickup_status(
        &self,
    ) -> Result<crate::entity::AbstractArrowPickupStatus<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/AbstractArrow$PickupStatus;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPickupStatus", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::AbstractArrowPickupStatus::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn set_pickup_status(
        &self,
        arg0: impl Into<crate::entity::AbstractArrowPickupStatus<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/AbstractArrow$PickupStatus;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPickupStatus",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_shot_from_crossbow(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = SpectralArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.is_shot_from_crossbow()
    }
    pub fn set_shot_from_crossbow(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = SpectralArrow::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractArrow = temp_clone.into();
        real.set_shot_from_crossbow(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::AbstractArrow<'mc>> for SpectralArrow<'mc> {
    fn into(self) -> crate::entity::AbstractArrow<'mc> {
        crate::entity::AbstractArrow::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting SpectralArrow into crate::entity::AbstractArrow")
    }
}
/// Represents the Boss Entity.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Boss<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Boss<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Boss<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Boss from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Boss")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Boss object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Boss<'mc> {
    pub fn boss_bar(
        &self,
    ) -> Result<Option<crate::boss::BossBar<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/boss/BossBar;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBossBar", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::boss::BossBar::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Boss::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for Boss<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Boss into crate::entity::Entity")
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct DragonFireball<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for DragonFireball<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for DragonFireball<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate DragonFireball from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/DragonFireball")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a DragonFireball object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> DragonFireball<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Fireball<'mc>> for DragonFireball<'mc> {
    fn into(self) -> crate::entity::Fireball<'mc> {
        crate::entity::Fireball::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting DragonFireball into crate::entity::Fireball")
    }
}
/// Represents a Strider.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Strider<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Strider<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Strider<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Strider from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Strider")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Strider object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Strider<'mc> {
    pub fn is_shivering(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isShivering", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set whether or not this strider is shivering. Note that the shivering state is updated frequently on the server, therefore this method may not affect the entity for long enough to have a noticeable difference.
    pub fn set_shivering(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setShivering",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn has_saddle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Strider::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Steerable = temp_clone.into();
        real.has_saddle()
    }
    pub fn set_saddle(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Strider::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Steerable = temp_clone.into();
        real.set_saddle(arg0)
    }
    pub fn boost_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBoostTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_boost_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBoostTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn current_boost_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCurrentBoostTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_current_boost_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCurrentBoostTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn steer_material(&self) -> Result<crate::Material<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Strider::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Steerable = temp_clone.into();
        real.steer_material()
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Strider::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Vehicle = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Strider::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Vehicle = temp_clone.into();
        real.velocity()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Steerable<'mc>> for Strider<'mc> {
    fn into(self) -> crate::entity::Steerable<'mc> {
        crate::entity::Steerable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Strider into crate::entity::Steerable")
    }
}
impl<'mc> Into<crate::entity::Vehicle<'mc>> for Strider<'mc> {
    fn into(self) -> crate::entity::Vehicle<'mc> {
        crate::entity::Vehicle::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Strider into crate::entity::Vehicle")
    }
}
/// Represents a Horse.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Horse<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Horse<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Horse<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Horse from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Horse object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Horse<'mc> {
    pub fn set_color(
        &self,
        arg0: impl Into<crate::entity::HorseColor<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Horse$Color;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setColor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn inventory(
        &self,
    ) -> Result<crate::inventory::AbstractHorseInventory<'mc>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Lorg/bukkit/inventory/AbstractHorseInventory;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getInventory", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::AbstractHorseInventory::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn color(
        &self,
    ) -> Result<Option<crate::entity::HorseColor<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Horse$Color;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getColor", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::HorseColor::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn is_carrying_chest(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isCarryingChest", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// <span class="deprecated-label">Deprecated.</span>
    /// <div class="deprecation-comment">
    /// see <a title="interface in org.bukkit.entity" href="ChestedHorse.html"><code>ChestedHorse</code></a>
    /// </div>
    /// see <a title="interface in org.bukkit.entity" href="ChestedHorse.html"><code>ChestedHorse</code></a>
    ///
    pub fn set_carrying_chest(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCarryingChest",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn style(&self) -> Result<crate::entity::HorseStyle<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Horse$Style;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getStyle", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::HorseStyle::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_style(
        &self,
        arg0: impl Into<crate::entity::HorseStyle<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Horse$Style;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setStyle",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn variant(&self) -> Result<crate::entity::HorseVariant<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Horse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.variant()
    }
    pub fn set_variant(
        &self,
        arg0: impl Into<crate::entity::HorseVariant<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Horse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_variant(arg0)
    }
    pub fn domestication(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Horse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.domestication()
    }
    pub fn set_domestication(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Horse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_domestication(arg0)
    }
    pub fn max_domestication(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Horse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.max_domestication()
    }
    pub fn set_max_domestication(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Horse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_max_domestication(arg0)
    }
    pub fn jump_strength(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = Horse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.jump_strength()
    }
    pub fn set_jump_strength(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Horse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_jump_strength(arg0)
    }
    pub fn is_eating_haystack(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Horse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.is_eating_haystack()
    }
    pub fn set_eating_haystack(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Horse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_eating_haystack(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::AbstractHorse<'mc>> for Horse<'mc> {
    fn into(self) -> crate::entity::AbstractHorse<'mc> {
        crate::entity::AbstractHorse::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Horse into crate::entity::AbstractHorse")
    }
}
/// Represents a wandering trader NPC
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct WanderingTrader<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for WanderingTrader<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WanderingTrader<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate WanderingTrader from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/WanderingTrader")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WanderingTrader object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> WanderingTrader<'mc> {
    pub fn despawn_delay(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDespawnDelay", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the despawn delay before this <a title="interface in org.bukkit.entity" href="WanderingTrader.html"><code>WanderingTrader</code></a> is forcibly despawned. If this is less than or equal to 0, then the trader will not be despawned.
    pub fn set_despawn_delay(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDespawnDelay",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn inventory(
        &self,
    ) -> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = WanderingTrader::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractVillager = temp_clone.into();
        real.inventory()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::AbstractVillager<'mc>> for WanderingTrader<'mc> {
    fn into(self) -> crate::entity::AbstractVillager<'mc> {
        crate::entity::AbstractVillager::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting WanderingTrader into crate::entity::AbstractVillager")
    }
}
/// Represents the current spell the entity is using.
pub enum SpellcasterSpell<'mc> {
    None { inner: SpellcasterSpellStruct<'mc> },
    SummonVex { inner: SpellcasterSpellStruct<'mc> },
    Fangs { inner: SpellcasterSpellStruct<'mc> },
    Wololo { inner: SpellcasterSpellStruct<'mc> },
    Disappear { inner: SpellcasterSpellStruct<'mc> },
    Blindness { inner: SpellcasterSpellStruct<'mc> },
}
impl<'mc> std::fmt::Display for SpellcasterSpell<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SpellcasterSpell::None { .. } => f.write_str("NONE"),
            SpellcasterSpell::SummonVex { .. } => f.write_str("SUMMON_VEX"),
            SpellcasterSpell::Fangs { .. } => f.write_str("FANGS"),
            SpellcasterSpell::Wololo { .. } => f.write_str("WOLOLO"),
            SpellcasterSpell::Disappear { .. } => f.write_str("DISAPPEAR"),
            SpellcasterSpell::Blindness { .. } => f.write_str("BLINDNESS"),
        }
    }
}

impl<'mc> SpellcasterSpell<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<SpellcasterSpell<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Spellcaster$Spell");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Spellcaster$Spell;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NONE" => Ok(SpellcasterSpell::None {
                inner: SpellcasterSpellStruct::from_raw(env, obj)?,
            }),
            "SUMMON_VEX" => Ok(SpellcasterSpell::SummonVex {
                inner: SpellcasterSpellStruct::from_raw(env, obj)?,
            }),
            "FANGS" => Ok(SpellcasterSpell::Fangs {
                inner: SpellcasterSpellStruct::from_raw(env, obj)?,
            }),
            "WOLOLO" => Ok(SpellcasterSpell::Wololo {
                inner: SpellcasterSpellStruct::from_raw(env, obj)?,
            }),
            "DISAPPEAR" => Ok(SpellcasterSpell::Disappear {
                inner: SpellcasterSpellStruct::from_raw(env, obj)?,
            }),
            "BLINDNESS" => Ok(SpellcasterSpell::Blindness {
                inner: SpellcasterSpellStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct SpellcasterSpellStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SpellcasterSpell<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::None { inner } => inner.0.clone(),
            Self::SummonVex { inner } => inner.0.clone(),
            Self::Fangs { inner } => inner.0.clone(),
            Self::Wololo { inner } => inner.0.clone(),
            Self::Disappear { inner } => inner.0.clone(),
            Self::Blindness { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::SummonVex { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Fangs { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Wololo { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Disappear { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Blindness { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SpellcasterSpell<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate SpellcasterSpell from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Spellcaster$Spell")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SpellcasterSpell object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NONE" => Ok(SpellcasterSpell::None {
                    inner: SpellcasterSpellStruct::from_raw(env, obj)?,
                }),
                "SUMMON_VEX" => Ok(SpellcasterSpell::SummonVex {
                    inner: SpellcasterSpellStruct::from_raw(env, obj)?,
                }),
                "FANGS" => Ok(SpellcasterSpell::Fangs {
                    inner: SpellcasterSpellStruct::from_raw(env, obj)?,
                }),
                "WOLOLO" => Ok(SpellcasterSpell::Wololo {
                    inner: SpellcasterSpellStruct::from_raw(env, obj)?,
                }),
                "DISAPPEAR" => Ok(SpellcasterSpell::Disappear {
                    inner: SpellcasterSpellStruct::from_raw(env, obj)?,
                }),
                "BLINDNESS" => Ok(SpellcasterSpell::Blindness {
                    inner: SpellcasterSpellStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for SpellcasterSpellStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SpellcasterSpellStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate SpellcasterSpellStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Spellcaster$Spell")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SpellcasterSpellStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SpellcasterSpellStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a fishing hook.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct FishHook<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for FishHook<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FishHook<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate FishHook from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/FishHook")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FishHook object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> FishHook<'mc> {
    /// Set both the minimum (default 100) and maximum (default 600) amount of ticks one has to wait for a fish appearing.
    pub fn set_wait_time(&self, arg0: i32, arg1: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(II)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWaitTime",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Set the minimum number of ticks one has to wait for a fish appearing.
    /// <p>The default is 100 ticks (5 seconds).
    ///
    /// Note that this is before applying lure.</p>
    pub fn set_min_wait_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMinWaitTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn max_wait_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxWaitTime", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the maximum number of ticks one has to wait for a fish appearing.
    /// <p>The default is 600 ticks (30 seconds).
    ///
    /// Note that this is before applying lure.</p>
    pub fn set_max_wait_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaxWaitTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn min_lure_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMinLureTime", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the minimum number of ticks one has to wait for a fish to bite after appearing.
    /// <p>The default is 20 ticks (1 second).
    ///
    /// Lure does not affect this value. This will also effect the radius (0.1 * lureTime) of where the fish will appear.</p>
    pub fn set_min_lure_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMinLureTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn max_lure_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxLureTime", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the maximum number of ticks one has to wait for a fish to bite after appearing.
    /// <p>The default is 80 ticks (4 second).
    ///
    /// Lure does not affect this value. This will also effect the radius (0.1 * lureTime) of where the fish will appear.</p>
    pub fn set_max_lure_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaxLureTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Set both the minimum (default 20) and maximum (default 80) amount of ticks one has to wait for a fish to bite after appearing.
    pub fn set_lure_time(&self, arg0: i32, arg1: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(II)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLureTime",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn min_lure_angle(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMinLureAngle", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Set the minimum angle (in degrees, 0 being positive Z 90 being negative X) of where a fish will appear after the wait time.
    /// <p>The default is 0 degrees.</p>
    pub fn set_min_lure_angle(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMinLureAngle",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn max_lure_angle(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxLureAngle", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Set the maximum angle (in degrees, 0 being positive Z 90 being negative X) of where a fish will appear after the wait time.
    /// <p>The default is 360 degrees.</p>
    pub fn set_max_lure_angle(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaxLureAngle",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Set both the minimum (default 0) and maximum (default 360) angle of where a fish will appear after the wait time. 0 degrees is positive Z, 90 degrees is negative X.
    pub fn set_lure_angle(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(FF)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let val_2 = jni::objects::JValueGen::Float(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLureAngle",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn apply_lure(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getApplyLure", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set whether the lure enchantment should be applied to reduce the wait time.
    /// <p>The default is true.
    ///
    /// Lure reduces the wait time by 100 ticks (5 seconds) for each level of the enchantment.</p>
    pub fn set_apply_lure(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setApplyLure",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn bite_chance(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBiteChance", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }

    pub fn min_wait_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMinWaitTime", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated = "has no effect in newer Minecraft versions "]
    /// Sets the chance of a fish biting.<p>0.0 = No Chance.
    ///
    /// 1.0 = Instant catch.</p>
    pub fn set_bite_chance(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBiteChance",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_in_open_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isInOpenWater", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn hooked_entity(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Entity;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getHookedEntity", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Entity::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_hooked_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setHookedEntity",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn pull_hooked_entity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "pullHookedEntity",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn is_sky_influenced(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isSkyInfluenced", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set whether or not wait and lure time will be impacted by direct sky access. True by default, causes a 50% time increase on average.
    pub fn set_sky_influenced(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSkyInfluenced",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_rain_influenced(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isRainInfluenced",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set whether or not wait and lure time will be impacted by rain. True by default, causes a 25% time decrease on average.
    pub fn set_rain_influenced(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRainInfluenced",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn state(
        &self,
    ) -> Result<crate::entity::FishHookHookState<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/FishHook$HookState;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getState", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::FishHookHookState::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn shooter(
        &self,
    ) -> Result<Option<crate::projectiles::ProjectileSource<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = FishHook::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.shooter()
    }
    pub fn set_shooter(
        &self,
        arg0: impl Into<crate::projectiles::ProjectileSource<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FishHook::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.set_shooter(arg0)
    }
    pub fn does_bounce(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = FishHook::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.does_bounce()
    }
    pub fn set_bounce(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = FishHook::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Projectile = temp_clone.into();
        real.set_bounce(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for FishHook<'mc> {
    fn into(self) -> crate::entity::Projectile<'mc> {
        crate::entity::Projectile::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting FishHook into crate::entity::Projectile")
    }
}
/// Represents a player, connected or not
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Player<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Player<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Player<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Player from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Player")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Player object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Player<'mc> {
    /// Sets the players current experience level
    pub fn set_level(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLevel",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn display_name(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDisplayName", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn set_bed_spawn_location_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<bool>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Z";
            let val_2 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_2);
        }
        sig += ")V";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBedSpawnLocation",
            sig.as_str(),
            args,
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn level(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getLevel", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isOnGround", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn play_effect_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: impl Into<crate::Effect<'mc>>,
        arg2: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/Effect;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg1.into().jni_object().clone())
        });
        args.push(val_2);
        sig += "Ljava/lang/Object;";
        let val_3 = jni::objects::JValueGen::Object(arg2);
        args.push(val_3);
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "playEffect", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn spigot(&self) -> Result<crate::entity::EntitySpigot<'mc>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Lorg/bukkit/entity/Entity$Spigot;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "spigot", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::EntitySpigot::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_display_name(
        &self,
        arg0: impl Into<String>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDisplayName",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn send_raw_message(
        &self,
        arg0: impl Into<String>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "sendRawMessage",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn can_see_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "canSee", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn allow_flight(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getAllowFlight", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn scoreboard(
        &self,
    ) -> Result<Option<crate::scoreboard::Scoreboard<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/scoreboard/Scoreboard;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getScoreboard", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::scoreboard::Scoreboard::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn bed_spawn_location(
        &self,
    ) -> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBedSpawnLocation",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn ban_with_string(
        &self,
        arg0: impl Into<String>,
        arg1: jni::objects::JObject<'mc>,
        arg2: impl Into<String>,
        arg3: bool,
    ) -> Result<crate::BanEntry<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        args.push(val_1);
        sig += "Ljava/time/Duration;";
        let val_2 = jni::objects::JValueGen::Object(arg1);
        args.push(val_2);
        sig += "Ljava/lang/String;";
        let val_3 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg2.into())?,
        ));
        args.push(val_3);
        sig += "Z";
        let val_4 = jni::objects::JValueGen::Bool(arg3.into());
        args.push(val_4);
        sig += ")Lorg/bukkit/BanEntry;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "ban", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::BanEntry::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn player_list_name(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPlayerListName",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn send_block_change_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: impl Into<crate::Material<'mc>>,
        arg2: std::option::Option<i8>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/Material;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg1.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = arg2 {
            sig += "B";
            let val_3 = jni::objects::JValueGen::Byte(a);
            args.push(val_3);
        }
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "sendBlockChange", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn send_block_damage_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: f32,
        arg2: std::option::Option<impl Into<crate::entity::Entity<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "F";
        let val_2 = jni::objects::JValueGen::Float(arg1);
        args.push(val_2);
        if let Some(a) = arg2 {
            sig += "Lorg/bukkit/entity/Entity;";
            let val_3 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_3);
        }
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "sendBlockDamage", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn send_equipment_change_with_living_entity(
        &self,
        arg0: impl Into<crate::entity::LivingEntity<'mc>>,
        arg1: impl Into<crate::inventory::EquipmentSlot<'mc>>,
        arg2: std::option::Option<impl Into<crate::inventory::ItemStack<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/LivingEntity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/inventory/EquipmentSlot;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg1.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = arg2 {
            sig += "Lorg/bukkit/inventory/ItemStack;";
            let val_3 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_3);
        }
        sig += ")V";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "sendEquipmentChange",
            sig.as_str(),
            args,
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn send_sign_change_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: Vec<String>,
        arg2: std::option::Option<impl Into<crate::DyeColor<'mc>>>,
        arg3: std::option::Option<bool>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "[Ljava/lang/String;";
        let arr = self.jni_ref().new_object_array(
            arg1.len() as i32,
            "java/lang/String",
            jni::objects::JObject::null(),
        );
        let arr = self.jni_ref().translate_error_no_gen(arr)?;
        for i in 0..arg1.len() {
            let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                self.jni_ref().new_string(arg1.get(i).unwrap().clone())?,
            ));
            self.jni_ref()
                .set_object_array_element(&arr, i as i32, val_2.l()?)?;
        }
        let val_2 = jni::objects::JValueGen::Object(arr);
        args.push(val_2.l()?.into());
        if let Some(a) = arg2 {
            sig += "Lorg/bukkit/DyeColor;";
            let val_3 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_3);
        }
        if let Some(a) = arg3 {
            sig += "Z";
            let val_4 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_4);
        }
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "sendSignChange", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn send_block_update(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: impl Into<crate::block::TileState<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;Lorg/bukkit/block/TileState;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg1.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "sendBlockUpdate",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn send_map(
        &self,
        arg0: impl Into<crate::map::MapView<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/map/MapView;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "sendMap",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Send a hurt animation. This fakes incoming damage towards the player from the given yaw relative to the player's direction.
    pub fn send_hurt_animation(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "sendHurtAnimation",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn update_inventory(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "updateInventory", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn previous_game_mode(
        &self,
    ) -> Result<Option<crate::GameMode<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/GameMode;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPreviousGameMode",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::GameMode::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Sets the current time on the player's client. When relative is true the player's time will be kept synchronized to its world time with the specified offset.
    /// <p>When using non relative time the player's time will stay fixed at the specified time parameter. It's up to the caller to continue updating the player's time. To restore player time to normal use resetPlayerTime().</p>
    pub fn set_player_time(&self, arg0: i64, arg1: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(JZ)V");
        let val_1 = jni::objects::JValueGen::Long(arg0);
        let val_2 = jni::objects::JValueGen::Bool(arg1.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPlayerTime",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn player_time(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPlayerTime", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }

    pub fn player_time_offset(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPlayerTimeOffset",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }

    pub fn is_player_time_relative(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isPlayerTimeRelative",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn reset_player_time(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "resetPlayerTime", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_player_weather(
        &self,
        arg0: impl Into<crate::WeatherType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/WeatherType;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPlayerWeather",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn player_weather(
        &self,
    ) -> Result<Option<crate::WeatherType<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/WeatherType;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPlayerWeather",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::WeatherType::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn reset_player_weather(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "resetPlayerWeather",
            sig.as_str(),
            vec![],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn exp_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getExpCooldown", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the player's cooldown between picking up experience orbs.. <strong>Note:</strong> Setting this to 0 allows the player to pick up instantly, but setting this to a negative value will cause the player to be unable to pick up xp-orbs. Calling this Method will result in <a title="class in org.bukkit.event.player" href="../event/player/PlayerExpCooldownChangeEvent.html"><code>PlayerExpCooldownChangeEvent</code></a> being called.
    pub fn set_exp_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setExpCooldown",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gives the player the amount of experience specified.
    /// Gives the player the amount of experience levels specified. Levels can be taken by specifying a negative amount.
    pub fn give_exp(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "giveExp",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gives the player the amount of experience levels specified. Levels can be taken by specifying a negative amount.
    pub fn give_exp_levels(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "giveExpLevels",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn exp(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getExp", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the players current experience points towards the next level
    /// <p>This is a percentage value. 0 is "no progress" and 1 is "next level".</p>
    pub fn set_exp(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setExp",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn total_experience(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTotalExperience",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the players current experience points.
    ///
    /// This refers to the total amount of experience the player has collected over time and is not currently displayed to the client.
    pub fn set_total_experience(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTotalExperience",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Send an experience change. This fakes an experience change packet for a user. This will not actually change the experience points in any way.
    pub fn send_experience_change_with_float(
        &self,
        arg0: f32,
        arg1: std::option::Option<i32>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "F";
        let val_1 = jni::objects::JValueGen::Float(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        sig += ")V";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "sendExperienceChange",
            sig.as_str(),
            args,
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets if the Player is allowed to fly via jump key double-tap like in creative mode.
    pub fn set_allow_flight(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAllowFlight",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn hide_player_with_plugin(
        &self,
        arg0: impl Into<crate::plugin::Plugin<'mc>>,
        arg1: std::option::Option<impl Into<crate::entity::Player<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/plugin/Plugin;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/entity/Player;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hidePlayer", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn show_player_with_plugin(
        &self,
        arg0: impl Into<crate::plugin::Plugin<'mc>>,
        arg1: std::option::Option<impl Into<crate::entity::Player<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/plugin/Plugin;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/entity/Player;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "showPlayer", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn hide_entity(
        &self,
        arg0: impl Into<crate::plugin::Plugin<'mc>>,
        arg1: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/plugin/Plugin;Lorg/bukkit/entity/Entity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg1.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hideEntity",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn show_entity(
        &self,
        arg0: impl Into<crate::plugin::Plugin<'mc>>,
        arg1: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/plugin/Plugin;Lorg/bukkit/entity/Entity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg1.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "showEntity",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_flying(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isFlying", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Makes this player start or stop flying.
    pub fn set_flying(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFlying",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets the speed at which a client will fly. Negative values indicate reverse directions.
    pub fn set_fly_speed(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFlySpeed",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets the speed at which a client will walk. Negative values indicate reverse directions.
    pub fn set_walk_speed(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWalkSpeed",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn fly_speed(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFlySpeed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }

    pub fn walk_speed(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getWalkSpeed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }

    pub fn set_texture_pack(
        &self,
        arg0: impl Into<String>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTexturePack",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_resource_pack_with_string(
        &self,
        arg0: impl Into<String>,
        arg1: std::option::Option<Vec<i8>>,
        arg2: std::option::Option<impl Into<String>>,
        arg3: std::option::Option<bool>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "[B";
            let arr = self.jni_ref().new_byte_array(a.len() as i32);
            let mut vec = Vec::new();
            let arr = self.jni_ref().translate_error_no_gen(arr)?;
            for i in 0..a.len() {
                let val_2 = *a.get(i).unwrap();
                vec.push(val_2)
            }
            self.jni_ref().set_byte_array_region(&arr, 0, &vec)?;
            let val_2 = jni::objects::JValueGen::Object(arr);
            args.push(val_2.l()?.into());
        }
        if let Some(a) = arg2 {
            sig += "Ljava/lang/String;";
            let val_3 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                self.jni_ref().new_string(a.into())?,
            ));
            args.push(val_3);
        }
        if let Some(a) = arg3 {
            sig += "Z";
            let val_4 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_4);
        }
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "setResourcePack", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_scoreboard(
        &self,
        arg0: impl Into<crate::scoreboard::Scoreboard<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/scoreboard/Scoreboard;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setScoreboard",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn world_border(
        &self,
    ) -> Result<Option<crate::WorldBorder<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/WorldBorder;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getWorldBorder", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::WorldBorder::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_world_border(
        &self,
        arg0: impl Into<crate::WorldBorder<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/WorldBorder;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWorldBorder",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Send a health update to the player. This will adjust the health, food, and saturation on the client and will not affect the player's actual values on the server. As soon as any of these values change on the server, changes sent by this method will no longer be visible.
    pub fn send_health_update_with_double(
        &self,
        arg0: std::option::Option<f64>,
        arg1: std::option::Option<i32>,
        arg2: std::option::Option<f32>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = arg0 {
            sig += "D";
            let val_1 = jni::objects::JValueGen::Double(a);
            args.push(val_1);
        }
        if let Some(a) = arg1 {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = arg2 {
            sig += "F";
            let val_3 = jni::objects::JValueGen::Float(a);
            args.push(val_3);
        }
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "sendHealthUpdate", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_health_scaled(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isHealthScaled", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if the client is displayed a 'scaled' health, that is, health on a scale from 0-<a href="#getHealthScale()"><code>getHealthScale()</code></a>.
    /// <p>Displayed health follows a simple formula <code>displayedHealth = getHealth() / getMaxHealth() * getHealthScale()</code>.</p>
    pub fn set_health_scaled(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setHealthScaled",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets the number to scale health to for the client; this will also <a href="#setHealthScaled(boolean)"><code>setHealthScaled(true)</code></a>.
    /// <p>Displayed health follows a simple formula <code>displayedHealth = getHealth() / getMaxHealth() * getHealthScale()</code>.</p>
    pub fn set_health_scale(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setHealthScale",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn health_scale(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getHealthScale", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }

    pub fn spectator_target(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Entity;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getSpectatorTarget",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Entity::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_spectator_target(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSpectatorTarget",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn send_title_with_string(
        &self,
        arg0: impl Into<String>,
        arg1: impl Into<String>,
        arg2: std::option::Option<i32>,
        arg3: std::option::Option<i32>,
        arg4: std::option::Option<i32>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        args.push(val_1);
        sig += "Ljava/lang/String;";
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg1.into())?,
        ));
        args.push(val_2);
        if let Some(a) = arg2 {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        if let Some(a) = arg3 {
            sig += "I";
            let val_4 = jni::objects::JValueGen::Int(a);
            args.push(val_4);
        }
        if let Some(a) = arg4 {
            sig += "I";
            let val_5 = jni::objects::JValueGen::Int(a);
            args.push(val_5);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "sendTitle", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn reset_title(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "resetTitle", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn spawn_particle_with_particle(
        &self,
        arg0: impl Into<crate::Particle<'mc>>,
        arg1: f64,
        arg2: f64,
        arg3: std::option::Option<f64>,
        arg4: std::option::Option<i32>,
        arg5: std::option::Option<f64>,
        arg6: std::option::Option<f64>,
        arg7: std::option::Option<f64>,
        arg8: std::option::Option<f64>,
        arg9: std::option::Option<jni::objects::JObject<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Particle;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "D";
        let val_2 = jni::objects::JValueGen::Double(arg1);
        args.push(val_2);
        sig += "D";
        let val_3 = jni::objects::JValueGen::Double(arg2);
        args.push(val_3);
        if let Some(a) = arg3 {
            sig += "D";
            let val_4 = jni::objects::JValueGen::Double(a);
            args.push(val_4);
        }
        if let Some(a) = arg4 {
            sig += "I";
            let val_5 = jni::objects::JValueGen::Int(a);
            args.push(val_5);
        }
        if let Some(a) = arg5 {
            sig += "D";
            let val_6 = jni::objects::JValueGen::Double(a);
            args.push(val_6);
        }
        if let Some(a) = arg6 {
            sig += "D";
            let val_7 = jni::objects::JValueGen::Double(a);
            args.push(val_7);
        }
        if let Some(a) = arg7 {
            sig += "D";
            let val_8 = jni::objects::JValueGen::Double(a);
            args.push(val_8);
        }
        if let Some(a) = arg8 {
            sig += "D";
            let val_9 = jni::objects::JValueGen::Double(a);
            args.push(val_9);
        }
        if let Some(a) = arg9 {
            sig += "Ljava/lang/Object;";
            let val_10 = jni::objects::JValueGen::Object(a);
            args.push(val_10);
        }
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "spawnParticle", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn get_advancement_progress(
        &self,
        arg0: impl Into<crate::advancement::Advancement<'mc>>,
    ) -> Result<crate::advancement::AdvancementProgress<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from(
            "(Lorg/bukkit/advancement/Advancement;)Lorg/bukkit/advancement/AdvancementProgress;",
        );
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getAdvancementProgress",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::advancement::AdvancementProgress::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn client_view_distance(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getClientViewDistance",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn ping(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getPing", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn locale(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getLocale", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn update_commands(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "updateCommands", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn open_book(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "openBook",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn open_sign_with_sign(
        &self,
        arg0: impl Into<crate::block::Sign<'mc>>,
        arg1: std::option::Option<impl Into<crate::block::sign::Side<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/block/Sign;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/block/sign/Side;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "openSign", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn show_demo_screen(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "showDemoScreen", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_allowing_server_listings(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isAllowingServerListings",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn set_player_list_name(
        &self,
        arg0: impl Into<String>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPlayerListName",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn player_list_header(&self) -> Result<Option<String>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPlayerListHeader",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(
            self.jni_ref()
                .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
                .to_string_lossy()
                .to_string(),
        ))
    }

    pub fn player_list_footer(&self) -> Result<Option<String>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPlayerListFooter",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(
            self.jni_ref()
                .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
                .to_string_lossy()
                .to_string(),
        ))
    }

    pub fn set_player_list_header(
        &self,
        arg0: impl Into<String>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPlayerListHeader",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_player_list_footer(
        &self,
        arg0: impl Into<String>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPlayerListFooter",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_player_list_header_footer(
        &self,
        arg0: impl Into<String>,
        arg1: impl Into<String>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg1.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPlayerListHeaderFooter",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_compass_target(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCompassTarget",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn compass_target(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCompassTarget",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn kick_player(&self, arg0: impl Into<String>) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "kickPlayer",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn ban_ip_with_string(
        &self,
        arg0: impl Into<String>,
        arg1: impl Into<blackboxmc_java::util::JavaDate<'mc>>,
        arg2: impl Into<String>,
        arg3: bool,
    ) -> Result<crate::BanEntry<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        args.push(val_1);
        sig += "Ljava/util/Date;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg1.into().jni_object().clone())
        });
        args.push(val_2);
        sig += "Ljava/lang/String;";
        let val_3 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg2.into())?,
        ));
        args.push(val_3);
        sig += "Z";
        let val_4 = jni::objects::JValueGen::Bool(arg3.into());
        args.push(val_4);
        sig += ")Lorg/bukkit/BanEntry;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "banIp", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::BanEntry::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn chat(&self, arg0: impl Into<String>) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "chat",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn perform_command(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Z");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "performCommand",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn is_sneaking(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isSneaking", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets the sneak mode the player
    pub fn set_sneaking(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSneaking",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_sprinting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isSprinting", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the player is sprinting or not.
    pub fn set_sprinting(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSprinting",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn save_data(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "saveData", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn load_data(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "loadData", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets whether the player is ignored as not sleeping. If everyone is either sleeping or has this flag set, then time will advance to the next day. If everyone has this flag set but no one is actually in bed, then nothing will happen.
    pub fn set_sleeping_ignored(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSleepingIgnored",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_sleeping_ignored(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isSleepingIgnored",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn play_note_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: impl Into<crate::Instrument<'mc>>,
        arg2: impl Into<crate::Note<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/Instrument;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg1.into().jni_object().clone())
        });
        args.push(val_2);
        sig += "Lorg/bukkit/Note;";
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg2.into().jni_object().clone())
        });
        args.push(val_3);
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "playNote", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn play_sound_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: impl Into<String>,
        arg2: impl Into<crate::SoundCategory<'mc>>,
        arg3: f32,
        arg4: std::option::Option<f32>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Ljava/lang/String;";
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg1.into())?,
        ));
        args.push(val_2);
        sig += "Lorg/bukkit/SoundCategory;";
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg2.into().jni_object().clone())
        });
        args.push(val_3);
        sig += "F";
        let val_4 = jni::objects::JValueGen::Float(arg3);
        args.push(val_4);
        if let Some(a) = arg4 {
            sig += "F";
            let val_5 = jni::objects::JValueGen::Float(a);
            args.push(val_5);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "playSound", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn play_sound_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: impl Into<String>,
        arg2: impl Into<crate::SoundCategory<'mc>>,
        arg3: f32,
        arg4: std::option::Option<f32>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Ljava/lang/String;";
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg1.into())?,
        ));
        args.push(val_2);
        sig += "Lorg/bukkit/SoundCategory;";
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg2.into().jni_object().clone())
        });
        args.push(val_3);
        sig += "F";
        let val_4 = jni::objects::JValueGen::Float(arg3);
        args.push(val_4);
        if let Some(a) = arg4 {
            sig += "F";
            let val_5 = jni::objects::JValueGen::Float(a);
            args.push(val_5);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "playSound", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn stop_sound_with_string(
        &self,
        arg0: impl Into<String>,
        arg1: std::option::Option<impl Into<crate::SoundCategory<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arg0.into())?,
        ));
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/SoundCategory;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "stopSound", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn stop_sound_with_sound_category(
        &self,
        arg0: impl Into<crate::SoundCategory<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/SoundCategory;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "stopSound", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn stop_sound_with_sound(
        &self,
        arg0: impl Into<crate::Sound<'mc>>,
        arg1: std::option::Option<impl Into<crate::SoundCategory<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Sound;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/SoundCategory;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "stopSound", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn stop_all_sounds(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "stopAllSounds", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn break_block(
        &self,
        arg0: impl Into<crate::block::Block<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/block/Block;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "breakBlock",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn name(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getName", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn address(&self) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/net/InetSocketAddress;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getAddress", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }
    pub fn wakeup(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.wakeup(arg0)
    }
    pub fn inventory(
        &self,
    ) -> Result<crate::inventory::PlayerInventory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.inventory()
    }

    pub fn item_in_hand(
        &self,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.item_in_hand()
    }
    pub fn set_item_in_hand(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_item_in_hand(arg0)
    }
    pub fn ender_chest(
        &self,
    ) -> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.ender_chest()
    }
    pub fn main_hand(&self) -> Result<crate::inventory::MainHand<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.main_hand()
    }
    pub fn set_window_property(
        &self,
        arg0: impl Into<crate::inventory::InventoryViewProperty<'mc>>,
        arg1: i32,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_window_property(arg0, arg1)
    }
    pub fn enchantment_seed(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.enchantment_seed()
    }
    pub fn set_enchantment_seed(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_enchantment_seed(arg0)
    }
    pub fn open_inventory_with_inventory(
        &self,
        arg0: std::option::Option<impl Into<crate::inventory::Inventory<'mc>>>,
    ) -> Result<crate::inventory::InventoryView<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = arg0 {
            sig += "Lorg/bukkit/inventory/Inventory;";
            let val_1 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_1);
        }
        sig += ")Lorg/bukkit/inventory/InventoryView;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "openInventory", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::InventoryView::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn open_workbench(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: bool,
    ) -> Result<crate::inventory::InventoryView<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.open_workbench(arg0, arg1)
    }
    pub fn open_enchanting(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: bool,
    ) -> Result<crate::inventory::InventoryView<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.open_enchanting(arg0, arg1)
    }
    pub fn open_merchant_with_villager(
        &self,
        arg0: impl Into<crate::entity::Villager<'mc>>,
        arg1: bool,
    ) -> Result<crate::inventory::InventoryView<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Villager;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Z";
        let val_2 = jni::objects::JValueGen::Bool(arg1.into());
        args.push(val_2);
        sig += ")Lorg/bukkit/inventory/InventoryView;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "openMerchant", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::InventoryView::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn close_inventory(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.close_inventory()
    }
    pub fn item_on_cursor(
        &self,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.item_on_cursor()
    }
    pub fn set_item_on_cursor(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_item_on_cursor(arg0)
    }
    pub fn has_cooldown(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.has_cooldown(arg0)
    }
    pub fn get_cooldown(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.get_cooldown(arg0)
    }
    pub fn set_cooldown(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
        arg1: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_cooldown(arg0, arg1)
    }
    pub fn sleep_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getSleepTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn bed_location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.bed_location()
    }
    pub fn game_mode(&self) -> Result<crate::GameMode<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.game_mode()
    }
    pub fn set_game_mode(
        &self,
        arg0: impl Into<crate::GameMode<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_game_mode(arg0)
    }
    pub fn is_blocking(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.is_blocking()
    }
    pub fn is_hand_raised(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.is_hand_raised()
    }
    pub fn item_in_use(
        &self,
    ) -> Result<Option<crate::inventory::ItemStack<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.item_in_use()
    }
    pub fn exp_to_level(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.exp_to_level()
    }
    pub fn attack_cooldown(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.attack_cooldown()
    }
    pub fn discover_recipe(
        &self,
        arg0: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.discover_recipe(arg0)
    }
    pub fn undiscover_recipe(
        &self,
        arg0: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "undiscoverRecipe",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn has_discovered_recipe(
        &self,
        arg0: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasDiscoveredRecipe",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn discovered_recipes(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDiscoveredRecipes",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn shoulder_entity_left(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.shoulder_entity_left()
    }
    pub fn set_shoulder_entity_left(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_shoulder_entity_left(arg0)
    }

    pub fn shoulder_entity_right(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.shoulder_entity_right()
    }
    pub fn set_shoulder_entity_right(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_shoulder_entity_right(arg0)
    }
    pub fn drop_item(&self, arg0: bool) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.drop_item(arg0)
    }
    pub fn exhaustion(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.exhaustion()
    }
    pub fn set_exhaustion(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_exhaustion(arg0)
    }
    pub fn saturation(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.saturation()
    }
    pub fn set_saturation(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_saturation(arg0)
    }
    pub fn food_level(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.food_level()
    }
    pub fn set_food_level(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_food_level(arg0)
    }
    pub fn saturated_regen_rate(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.saturated_regen_rate()
    }
    pub fn set_saturated_regen_rate(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_saturated_regen_rate(arg0)
    }
    pub fn unsaturated_regen_rate(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.unsaturated_regen_rate()
    }
    pub fn set_unsaturated_regen_rate(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_unsaturated_regen_rate(arg0)
    }
    pub fn starvation_rate(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.starvation_rate()
    }
    pub fn set_starvation_rate(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_starvation_rate(arg0)
    }
    pub fn last_death_location(
        &self,
    ) -> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.last_death_location()
    }
    pub fn set_last_death_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.set_last_death_location(arg0)
    }
    pub fn firework_boost(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<crate::entity::Firework<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.firework_boost(arg0)
    }
    pub fn sleep(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: bool,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::HumanEntity = temp_clone.into();
        real.sleep(arg0, arg1)
    }
    pub fn accept_conversation_input(
        &self,
        arg0: impl Into<String>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::conversations::Conversable = temp_clone.into();
        real.accept_conversation_input(arg0)
    }
    pub fn begin_conversation(
        &self,
        arg0: impl Into<crate::conversations::Conversation<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::conversations::Conversable = temp_clone.into();
        real.begin_conversation(arg0)
    }
    pub fn abandon_conversation_with_conversation(
        &self,
        arg0: impl Into<crate::conversations::Conversation<'mc>>,
        arg1: std::option::Option<impl Into<crate::conversations::ConversationAbandonedEvent<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/conversations/Conversation;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/conversations/ConversationAbandonedEvent;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")V";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "abandonConversation",
            sig.as_str(),
            args,
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_conversing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::conversations::Conversable = temp_clone.into();
        real.is_conversing()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::OfflinePlayer = temp_clone.into();
        real.unique_id()
    }
    pub fn is_banned(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::OfflinePlayer = temp_clone.into();
        real.is_banned()
    }
    pub fn player(&self) -> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::OfflinePlayer = temp_clone.into();
        real.player()
    }
    pub fn is_online(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::OfflinePlayer = temp_clone.into();
        real.is_online()
    }
    pub fn player_profile(
        &self,
    ) -> Result<crate::profile::PlayerProfile<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::OfflinePlayer = temp_clone.into();
        real.player_profile()
    }
    pub fn is_whitelisted(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::OfflinePlayer = temp_clone.into();
        real.is_whitelisted()
    }
    pub fn set_whitelisted(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::OfflinePlayer = temp_clone.into();
        real.set_whitelisted(arg0)
    }
    pub fn first_played(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::OfflinePlayer = temp_clone.into();
        real.first_played()
    }
    pub fn last_played(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::OfflinePlayer = temp_clone.into();
        real.last_played()
    }
    pub fn has_played_before(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::OfflinePlayer = temp_clone.into();
        real.has_played_before()
    }
    pub fn increment_statistic_with_statistic(
        &self,
        arg0: impl Into<crate::Statistic<'mc>>,
        arg1: std::option::Option<impl Into<crate::entity::EntityType<'mc>>>,
        arg2: std::option::Option<i32>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Statistic;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/entity/EntityType;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        if let Some(a) = arg2 {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")V";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "incrementStatistic",
            sig.as_str(),
            args,
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn decrement_statistic_with_statistic(
        &self,
        arg0: impl Into<crate::Statistic<'mc>>,
        arg1: std::option::Option<impl Into<crate::Material<'mc>>>,
        arg2: std::option::Option<i32>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Statistic;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/Material;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        if let Some(a) = arg2 {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")V";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "decrementStatistic",
            sig.as_str(),
            args,
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_statistic_with_statistic(
        &self,
        arg0: impl Into<crate::Statistic<'mc>>,
        arg1: impl Into<crate::Material<'mc>>,
        arg2: std::option::Option<i32>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Statistic;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/Material;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg1.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = arg2 {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "setStatistic", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn get_statistic_with_statistic(
        &self,
        arg0: impl Into<crate::Statistic<'mc>>,
        arg1: std::option::Option<impl Into<crate::entity::EntityType<'mc>>>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Statistic;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/entity/EntityType;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")I";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getStatistic", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn send_plugin_message(
        &self,
        arg0: impl Into<crate::plugin::Plugin<'mc>>,
        arg1: impl Into<String>,
        arg2: Vec<i8>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Player::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::plugin::messaging::PluginMessageRecipient = temp_clone.into();
        real.send_plugin_message(arg0, arg1, arg2)
    }
    pub fn listening_plugin_channels(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getListeningPluginChannels",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::HumanEntity<'mc>> for Player<'mc> {
    fn into(self) -> crate::entity::HumanEntity<'mc> {
        crate::entity::HumanEntity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Player into crate::entity::HumanEntity")
    }
}
impl<'mc> Into<crate::conversations::Conversable<'mc>> for Player<'mc> {
    fn into(self) -> crate::conversations::Conversable<'mc> {
        crate::conversations::Conversable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Player into crate::conversations::Conversable")
    }
}
impl<'mc> Into<crate::OfflinePlayer<'mc>> for Player<'mc> {
    fn into(self) -> crate::OfflinePlayer<'mc> {
        crate::OfflinePlayer::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Player into crate::OfflinePlayer")
    }
}
impl<'mc> Into<crate::plugin::messaging::PluginMessageRecipient<'mc>> for Player<'mc> {
    fn into(self) -> crate::plugin::messaging::PluginMessageRecipient<'mc> {
        crate::plugin::messaging::PluginMessageRecipient::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Player into crate::plugin::messaging::PluginMessageRecipient")
    }
}
/// Represents a salmon fish.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Salmon<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Salmon<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Salmon<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Salmon from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Salmon")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Salmon object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Salmon<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Fish<'mc>> for Salmon<'mc> {
    fn into(self) -> crate::entity::Fish<'mc> {
        crate::entity::Fish::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Salmon into crate::entity::Fish")
    }
}
/// Represents a Zombie.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Zombie<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Zombie<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Zombie<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Zombie from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Zombie")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Zombie object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Zombie<'mc> {
    #[deprecated = "see <a href='Ageable.html#setBaby()'><code>Ageable.setBaby()</code></a> and <a href='Ageable.html#setAdult()'><code>Ageable.setAdult()</code></a> "]
    /// Sets whether the zombie is a baby
    pub fn set_baby(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBaby",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]

    pub fn is_baby(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBaby", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]

    pub fn is_villager(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isVillager", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn set_villager_profession(
        &self,
        arg0: impl Into<crate::entity::VillagerProfession<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Villager$Profession;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVillagerProfession",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_villager(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVillager",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn villager_profession(
        &self,
    ) -> Result<crate::entity::VillagerProfession<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Villager$Profession;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getVillagerProfession",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::VillagerProfession::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn is_converting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isConverting", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn conversion_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getConversionTime",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the amount of ticks until this entity will be converted to a Drowned as a result of being underwater. When this reaches 0, the entity will be converted. A value of less than 0 will stop the current conversion process without converting the current entity.
    pub fn set_conversion_time(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setConversionTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn can_break_doors(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "canBreakDoors", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether this zombie can break doors This will be ignored if the entity is a Drowned. Will also stop the action if the entity is currently breaking a door.
    pub fn set_can_break_doors(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCanBreakDoors",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn age(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = Zombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.age()
    }
    pub fn set_age(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Zombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_age(arg0)
    }

    pub fn set_age_lock(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Zombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_age_lock(arg0)
    }

    pub fn age_lock(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Zombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.age_lock()
    }

    pub fn can_breed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Zombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.can_breed()
    }

    pub fn set_breed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Zombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_breed(arg0)
    }
    pub fn set_adult(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Zombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.set_adult()
    }
    pub fn is_adult(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Zombie::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Ageable = temp_clone.into();
        real.is_adult()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Zombie<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Zombie into crate::entity::Monster")
    }
}
impl<'mc> Into<crate::entity::Ageable<'mc>> for Zombie<'mc> {
    fn into(self) -> crate::entity::Ageable<'mc> {
        crate::entity::Ageable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Zombie into crate::entity::Ageable")
    }
}
/// Represents a Parrot.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Parrot<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Parrot<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Parrot<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Parrot from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Parrot")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Parrot object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Parrot<'mc> {
    pub fn variant(&self) -> Result<crate::entity::ParrotVariant<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Parrot$Variant;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getVariant", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::ParrotVariant::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_variant(
        &self,
        arg0: impl Into<crate::entity::ParrotVariant<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Parrot$Variant;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVariant",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_dancing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isDancing", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn owner(
        &self,
    ) -> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Parrot::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.owner()
    }
    pub fn set_owner(
        &self,
        arg0: impl Into<crate::entity::AnimalTamer<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Parrot::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.set_owner(arg0)
    }
    pub fn is_tamed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Parrot::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.is_tamed()
    }
    pub fn set_tamed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Parrot::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.set_tamed(arg0)
    }
    pub fn is_sitting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Parrot::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Sittable = temp_clone.into();
        real.is_sitting()
    }
    pub fn set_sitting(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Parrot::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Sittable = temp_clone.into();
        real.set_sitting(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Tameable<'mc>> for Parrot<'mc> {
    fn into(self) -> crate::entity::Tameable<'mc> {
        crate::entity::Tameable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Parrot into crate::entity::Tameable")
    }
}
impl<'mc> Into<crate::entity::Sittable<'mc>> for Parrot<'mc> {
    fn into(self) -> crate::entity::Sittable<'mc> {
        crate::entity::Sittable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Parrot into crate::entity::Sittable")
    }
}
/// A crystal that heals nearby EnderDragons
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct EnderCrystal<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EnderCrystal<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EnderCrystal<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate EnderCrystal from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EnderCrystal")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EnderCrystal object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EnderCrystal<'mc> {
    pub fn is_showing_bottom(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isShowingBottom", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether or not this end crystal is showing the bedrock slate underneath it.
    pub fn set_showing_bottom(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setShowingBottom",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn beam_target(&self) -> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBeamTarget", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn set_beam_target(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBeamTarget",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn facing(&self) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.facing()
    }
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.world()
    }
    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_silent()
    }
    pub fn portal_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.portal_cooldown()
    }
    pub fn piston_move_reaction(
        &self,
    ) -> Result<crate::block::PistonMoveReaction<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.piston_move_reaction()
    }
    pub fn is_valid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_valid()
    }
    pub fn get_nearby_entities(
        &self,
        arg0: f64,
        arg1: f64,
        arg2: f64,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(DDD)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let val_2 = jni::objects::JValueGen::Double(arg1);
        let val_3 = jni::objects::JValueGen::Double(arg2);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNearbyEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn set_rotation(&self, arg0: f32, arg1: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_rotation(arg0, arg1)
    }
    pub fn set_velocity(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_velocity(arg0)
    }
    pub fn velocity(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.velocity()
    }
    pub fn height(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.height()
    }
    pub fn width(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.width()
    }
    pub fn bounding_box(
        &self,
    ) -> Result<crate::util::BoundingBox<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.bounding_box()
    }
    pub fn is_on_ground(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_on_ground()
    }
    pub fn is_in_water(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_in_water()
    }
    pub fn teleport_with_entity(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/entity/Entity;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn teleport_with_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
        arg1: std::option::Option<
            impl Into<crate::event::player::PlayerTeleportEventTeleportCause<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/event/player/PlayerTeleportEvent$TeleportCause;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "teleport", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn entity_id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.entity_id()
    }
    pub fn fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_fire_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFireTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_fire_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFireTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_visual_fire(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visual_fire(arg0)
    }
    pub fn is_visual_fire(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visual_fire()
    }
    pub fn freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFreezeTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn max_freeze_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxFreezeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_freeze_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFreezeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_dead()
    }
    pub fn server(&self) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.server()
    }
    pub fn is_persistent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_persistent()
    }
    pub fn set_persistent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_persistent(arg0)
    }

    pub fn passenger(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.passenger()
    }
    pub fn set_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_passenger(arg0)
    }
    pub fn passengers(
        &self,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPassengers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn add_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_passenger(arg0)
    }
    pub fn remove_passenger(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_passenger(arg0)
    }
    pub fn eject(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.eject()
    }
    pub fn fall_distance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.fall_distance()
    }
    pub fn set_fall_distance(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_fall_distance(arg0)
    }
    pub fn set_last_damage_cause(
        &self,
        arg0: impl Into<crate::event::entity::EntityDamageEvent<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_last_damage_cause(arg0)
    }
    pub fn last_damage_cause(
        &self,
    ) -> Result<Option<crate::event::entity::EntityDamageEvent<'mc>>, Box<dyn std::error::Error>>
    {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.last_damage_cause()
    }
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.unique_id()
    }
    pub fn ticks_lived(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.ticks_lived()
    }
    pub fn set_ticks_lived(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_ticks_lived(arg0)
    }
    pub fn play_effect(
        &self,
        arg0: impl Into<crate::EntityEffect<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.play_effect(arg0)
    }
    pub fn swim_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_sound()
    }
    pub fn swim_splash_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_splash_sound()
    }
    pub fn swim_high_speed_splash_sound(
        &self,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.swim_high_speed_splash_sound()
    }
    pub fn is_inside_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_inside_vehicle()
    }
    pub fn leave_vehicle(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.leave_vehicle()
    }
    pub fn vehicle(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.vehicle()
    }
    pub fn set_custom_name_visible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_custom_name_visible(arg0)
    }
    pub fn is_custom_name_visible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_custom_name_visible()
    }
    pub fn set_visible_by_default(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_visible_by_default(arg0)
    }
    pub fn is_visible_by_default(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_visible_by_default()
    }
    pub fn set_glowing(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_glowing(arg0)
    }
    pub fn is_glowing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_glowing()
    }
    pub fn set_invulnerable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_invulnerable(arg0)
    }
    pub fn is_invulnerable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_invulnerable()
    }
    pub fn set_silent(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_silent(arg0)
    }
    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.has_gravity()
    }
    pub fn set_gravity(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_gravity(arg0)
    }
    pub fn set_portal_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.set_portal_cooldown(arg0)
    }
    pub fn scoreboard_tags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardTags",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn add_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.add_scoreboard_tag(arg0)
    }
    pub fn remove_scoreboard_tag(
        &self,
        arg0: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove_scoreboard_tag(arg0)
    }
    pub fn pose(&self) -> Result<crate::entity::Pose<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.pose()
    }
    pub fn spawn_category(
        &self,
    ) -> Result<crate::entity::SpawnCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spawn_category()
    }
    pub fn spigot(
        &self,
    ) -> Result<crate::command::CommandSenderSpigot<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.spigot()
    }
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.remove()
    }
    pub fn is_empty(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_empty()
    }
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.location()
    }
    pub fn get_type(&self) -> Result<crate::entity::EntityType<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.get_type()
    }
    pub fn is_frozen(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = EnderCrystal::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Entity = temp_clone.into();
        real.is_frozen()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Entity<'mc>> for EnderCrystal<'mc> {
    fn into(self) -> crate::entity::Entity<'mc> {
        crate::entity::Entity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting EnderCrystal into crate::entity::Entity")
    }
}
/// Represents an Evoker "Illager".
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Evoker<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Evoker<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Evoker<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Evoker from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Evoker")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Evoker object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Evoker<'mc> {
    #[deprecated]

    pub fn current_spell(
        &self,
    ) -> Result<crate::entity::EvokerSpell<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Evoker$Spell;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getCurrentSpell", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::EvokerSpell::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_current_spell(
        &self,
        arg0: impl Into<crate::entity::EvokerSpell<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Evoker$Spell;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCurrentSpell",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn spell(
        &self,
    ) -> Result<crate::entity::SpellcasterSpell<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = Evoker::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Spellcaster = temp_clone.into();
        real.spell()
    }
    pub fn set_spell(
        &self,
        arg0: impl Into<crate::entity::SpellcasterSpell<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Evoker::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Spellcaster = temp_clone.into();
        real.set_spell(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Spellcaster<'mc>> for Evoker<'mc> {
    fn into(self) -> crate::entity::Spellcaster<'mc> {
        crate::entity::Spellcaster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Evoker into crate::entity::Spellcaster")
    }
}
pub enum EntityType<'mc> {
    DroppedItem { inner: EntityTypeStruct<'mc> },
    ExperienceOrb { inner: EntityTypeStruct<'mc> },
    AreaEffectCloud { inner: EntityTypeStruct<'mc> },
    ElderGuardian { inner: EntityTypeStruct<'mc> },
    WitherSkeleton { inner: EntityTypeStruct<'mc> },
    Stray { inner: EntityTypeStruct<'mc> },
    Egg { inner: EntityTypeStruct<'mc> },
    LeashHitch { inner: EntityTypeStruct<'mc> },
    Painting { inner: EntityTypeStruct<'mc> },
    Arrow { inner: EntityTypeStruct<'mc> },
    Snowball { inner: EntityTypeStruct<'mc> },
    Fireball { inner: EntityTypeStruct<'mc> },
    SmallFireball { inner: EntityTypeStruct<'mc> },
    EnderPearl { inner: EntityTypeStruct<'mc> },
    EnderSignal { inner: EntityTypeStruct<'mc> },
    SplashPotion { inner: EntityTypeStruct<'mc> },
    ThrownExpBottle { inner: EntityTypeStruct<'mc> },
    ItemFrame { inner: EntityTypeStruct<'mc> },
    WitherSkull { inner: EntityTypeStruct<'mc> },
    PrimedTnt { inner: EntityTypeStruct<'mc> },
    FallingBlock { inner: EntityTypeStruct<'mc> },
    Firework { inner: EntityTypeStruct<'mc> },
    Husk { inner: EntityTypeStruct<'mc> },
    SpectralArrow { inner: EntityTypeStruct<'mc> },
    ShulkerBullet { inner: EntityTypeStruct<'mc> },
    DragonFireball { inner: EntityTypeStruct<'mc> },
    ZombieVillager { inner: EntityTypeStruct<'mc> },
    SkeletonHorse { inner: EntityTypeStruct<'mc> },
    ZombieHorse { inner: EntityTypeStruct<'mc> },
    ArmorStand { inner: EntityTypeStruct<'mc> },
    Donkey { inner: EntityTypeStruct<'mc> },
    Mule { inner: EntityTypeStruct<'mc> },
    EvokerFangs { inner: EntityTypeStruct<'mc> },
    Evoker { inner: EntityTypeStruct<'mc> },
    Vex { inner: EntityTypeStruct<'mc> },
    Vindicator { inner: EntityTypeStruct<'mc> },
    Illusioner { inner: EntityTypeStruct<'mc> },
    MinecartCommand { inner: EntityTypeStruct<'mc> },
    Boat { inner: EntityTypeStruct<'mc> },
    Minecart { inner: EntityTypeStruct<'mc> },
    MinecartChest { inner: EntityTypeStruct<'mc> },
    MinecartFurnace { inner: EntityTypeStruct<'mc> },
    MinecartTnt { inner: EntityTypeStruct<'mc> },
    MinecartHopper { inner: EntityTypeStruct<'mc> },
    MinecartMobSpawner { inner: EntityTypeStruct<'mc> },
    Creeper { inner: EntityTypeStruct<'mc> },
    Skeleton { inner: EntityTypeStruct<'mc> },
    Spider { inner: EntityTypeStruct<'mc> },
    Giant { inner: EntityTypeStruct<'mc> },
    Zombie { inner: EntityTypeStruct<'mc> },
    Slime { inner: EntityTypeStruct<'mc> },
    Ghast { inner: EntityTypeStruct<'mc> },
    ZombifiedPiglin { inner: EntityTypeStruct<'mc> },
    Enderman { inner: EntityTypeStruct<'mc> },
    CaveSpider { inner: EntityTypeStruct<'mc> },
    Silverfish { inner: EntityTypeStruct<'mc> },
    Blaze { inner: EntityTypeStruct<'mc> },
    MagmaCube { inner: EntityTypeStruct<'mc> },
    EnderDragon { inner: EntityTypeStruct<'mc> },
    Wither { inner: EntityTypeStruct<'mc> },
    Bat { inner: EntityTypeStruct<'mc> },
    Witch { inner: EntityTypeStruct<'mc> },
    Endermite { inner: EntityTypeStruct<'mc> },
    Guardian { inner: EntityTypeStruct<'mc> },
    Shulker { inner: EntityTypeStruct<'mc> },
    Pig { inner: EntityTypeStruct<'mc> },
    Sheep { inner: EntityTypeStruct<'mc> },
    Cow { inner: EntityTypeStruct<'mc> },
    Chicken { inner: EntityTypeStruct<'mc> },
    Squid { inner: EntityTypeStruct<'mc> },
    Wolf { inner: EntityTypeStruct<'mc> },
    MushroomCow { inner: EntityTypeStruct<'mc> },
    Snowman { inner: EntityTypeStruct<'mc> },
    Ocelot { inner: EntityTypeStruct<'mc> },
    IronGolem { inner: EntityTypeStruct<'mc> },
    Horse { inner: EntityTypeStruct<'mc> },
    Rabbit { inner: EntityTypeStruct<'mc> },
    PolarBear { inner: EntityTypeStruct<'mc> },
    Llama { inner: EntityTypeStruct<'mc> },
    LlamaSpit { inner: EntityTypeStruct<'mc> },
    Parrot { inner: EntityTypeStruct<'mc> },
    Villager { inner: EntityTypeStruct<'mc> },
    EnderCrystal { inner: EntityTypeStruct<'mc> },
    Turtle { inner: EntityTypeStruct<'mc> },
    Phantom { inner: EntityTypeStruct<'mc> },
    Trident { inner: EntityTypeStruct<'mc> },
    Cod { inner: EntityTypeStruct<'mc> },
    Salmon { inner: EntityTypeStruct<'mc> },
    Pufferfish { inner: EntityTypeStruct<'mc> },
    TropicalFish { inner: EntityTypeStruct<'mc> },
    Drowned { inner: EntityTypeStruct<'mc> },
    Dolphin { inner: EntityTypeStruct<'mc> },
    Cat { inner: EntityTypeStruct<'mc> },
    Panda { inner: EntityTypeStruct<'mc> },
    Pillager { inner: EntityTypeStruct<'mc> },
    Ravager { inner: EntityTypeStruct<'mc> },
    TraderLlama { inner: EntityTypeStruct<'mc> },
    WanderingTrader { inner: EntityTypeStruct<'mc> },
    Fox { inner: EntityTypeStruct<'mc> },
    Bee { inner: EntityTypeStruct<'mc> },
    Hoglin { inner: EntityTypeStruct<'mc> },
    Piglin { inner: EntityTypeStruct<'mc> },
    Strider { inner: EntityTypeStruct<'mc> },
    Zoglin { inner: EntityTypeStruct<'mc> },
    PiglinBrute { inner: EntityTypeStruct<'mc> },
    Axolotl { inner: EntityTypeStruct<'mc> },
    GlowItemFrame { inner: EntityTypeStruct<'mc> },
    GlowSquid { inner: EntityTypeStruct<'mc> },
    Goat { inner: EntityTypeStruct<'mc> },
    Marker { inner: EntityTypeStruct<'mc> },
    Allay { inner: EntityTypeStruct<'mc> },
    ChestBoat { inner: EntityTypeStruct<'mc> },
    Frog { inner: EntityTypeStruct<'mc> },
    Tadpole { inner: EntityTypeStruct<'mc> },
    Warden { inner: EntityTypeStruct<'mc> },
    Camel { inner: EntityTypeStruct<'mc> },
    BlockDisplay { inner: EntityTypeStruct<'mc> },
    Interaction { inner: EntityTypeStruct<'mc> },
    ItemDisplay { inner: EntityTypeStruct<'mc> },
    Sniffer { inner: EntityTypeStruct<'mc> },
    TextDisplay { inner: EntityTypeStruct<'mc> },
    FishingHook { inner: EntityTypeStruct<'mc> },
    Lightning { inner: EntityTypeStruct<'mc> },
    Player { inner: EntityTypeStruct<'mc> },
    Unknown { inner: EntityTypeStruct<'mc> },
}
impl<'mc> std::fmt::Display for EntityType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EntityType::DroppedItem { .. } => f.write_str("DROPPED_ITEM"),
            EntityType::ExperienceOrb { .. } => f.write_str("EXPERIENCE_ORB"),
            EntityType::AreaEffectCloud { .. } => f.write_str("AREA_EFFECT_CLOUD"),
            EntityType::ElderGuardian { .. } => f.write_str("ELDER_GUARDIAN"),
            EntityType::WitherSkeleton { .. } => f.write_str("WITHER_SKELETON"),
            EntityType::Stray { .. } => f.write_str("STRAY"),
            EntityType::Egg { .. } => f.write_str("EGG"),
            EntityType::LeashHitch { .. } => f.write_str("LEASH_HITCH"),
            EntityType::Painting { .. } => f.write_str("PAINTING"),
            EntityType::Arrow { .. } => f.write_str("ARROW"),
            EntityType::Snowball { .. } => f.write_str("SNOWBALL"),
            EntityType::Fireball { .. } => f.write_str("FIREBALL"),
            EntityType::SmallFireball { .. } => f.write_str("SMALL_FIREBALL"),
            EntityType::EnderPearl { .. } => f.write_str("ENDER_PEARL"),
            EntityType::EnderSignal { .. } => f.write_str("ENDER_SIGNAL"),
            EntityType::SplashPotion { .. } => f.write_str("SPLASH_POTION"),
            EntityType::ThrownExpBottle { .. } => f.write_str("THROWN_EXP_BOTTLE"),
            EntityType::ItemFrame { .. } => f.write_str("ITEM_FRAME"),
            EntityType::WitherSkull { .. } => f.write_str("WITHER_SKULL"),
            EntityType::PrimedTnt { .. } => f.write_str("PRIMED_TNT"),
            EntityType::FallingBlock { .. } => f.write_str("FALLING_BLOCK"),
            EntityType::Firework { .. } => f.write_str("FIREWORK"),
            EntityType::Husk { .. } => f.write_str("HUSK"),
            EntityType::SpectralArrow { .. } => f.write_str("SPECTRAL_ARROW"),
            EntityType::ShulkerBullet { .. } => f.write_str("SHULKER_BULLET"),
            EntityType::DragonFireball { .. } => f.write_str("DRAGON_FIREBALL"),
            EntityType::ZombieVillager { .. } => f.write_str("ZOMBIE_VILLAGER"),
            EntityType::SkeletonHorse { .. } => f.write_str("SKELETON_HORSE"),
            EntityType::ZombieHorse { .. } => f.write_str("ZOMBIE_HORSE"),
            EntityType::ArmorStand { .. } => f.write_str("ARMOR_STAND"),
            EntityType::Donkey { .. } => f.write_str("DONKEY"),
            EntityType::Mule { .. } => f.write_str("MULE"),
            EntityType::EvokerFangs { .. } => f.write_str("EVOKER_FANGS"),
            EntityType::Evoker { .. } => f.write_str("EVOKER"),
            EntityType::Vex { .. } => f.write_str("VEX"),
            EntityType::Vindicator { .. } => f.write_str("VINDICATOR"),
            EntityType::Illusioner { .. } => f.write_str("ILLUSIONER"),
            EntityType::MinecartCommand { .. } => f.write_str("MINECART_COMMAND"),
            EntityType::Boat { .. } => f.write_str("BOAT"),
            EntityType::Minecart { .. } => f.write_str("MINECART"),
            EntityType::MinecartChest { .. } => f.write_str("MINECART_CHEST"),
            EntityType::MinecartFurnace { .. } => f.write_str("MINECART_FURNACE"),
            EntityType::MinecartTnt { .. } => f.write_str("MINECART_TNT"),
            EntityType::MinecartHopper { .. } => f.write_str("MINECART_HOPPER"),
            EntityType::MinecartMobSpawner { .. } => f.write_str("MINECART_MOB_SPAWNER"),
            EntityType::Creeper { .. } => f.write_str("CREEPER"),
            EntityType::Skeleton { .. } => f.write_str("SKELETON"),
            EntityType::Spider { .. } => f.write_str("SPIDER"),
            EntityType::Giant { .. } => f.write_str("GIANT"),
            EntityType::Zombie { .. } => f.write_str("ZOMBIE"),
            EntityType::Slime { .. } => f.write_str("SLIME"),
            EntityType::Ghast { .. } => f.write_str("GHAST"),
            EntityType::ZombifiedPiglin { .. } => f.write_str("ZOMBIFIED_PIGLIN"),
            EntityType::Enderman { .. } => f.write_str("ENDERMAN"),
            EntityType::CaveSpider { .. } => f.write_str("CAVE_SPIDER"),
            EntityType::Silverfish { .. } => f.write_str("SILVERFISH"),
            EntityType::Blaze { .. } => f.write_str("BLAZE"),
            EntityType::MagmaCube { .. } => f.write_str("MAGMA_CUBE"),
            EntityType::EnderDragon { .. } => f.write_str("ENDER_DRAGON"),
            EntityType::Wither { .. } => f.write_str("WITHER"),
            EntityType::Bat { .. } => f.write_str("BAT"),
            EntityType::Witch { .. } => f.write_str("WITCH"),
            EntityType::Endermite { .. } => f.write_str("ENDERMITE"),
            EntityType::Guardian { .. } => f.write_str("GUARDIAN"),
            EntityType::Shulker { .. } => f.write_str("SHULKER"),
            EntityType::Pig { .. } => f.write_str("PIG"),
            EntityType::Sheep { .. } => f.write_str("SHEEP"),
            EntityType::Cow { .. } => f.write_str("COW"),
            EntityType::Chicken { .. } => f.write_str("CHICKEN"),
            EntityType::Squid { .. } => f.write_str("SQUID"),
            EntityType::Wolf { .. } => f.write_str("WOLF"),
            EntityType::MushroomCow { .. } => f.write_str("MUSHROOM_COW"),
            EntityType::Snowman { .. } => f.write_str("SNOWMAN"),
            EntityType::Ocelot { .. } => f.write_str("OCELOT"),
            EntityType::IronGolem { .. } => f.write_str("IRON_GOLEM"),
            EntityType::Horse { .. } => f.write_str("HORSE"),
            EntityType::Rabbit { .. } => f.write_str("RABBIT"),
            EntityType::PolarBear { .. } => f.write_str("POLAR_BEAR"),
            EntityType::Llama { .. } => f.write_str("LLAMA"),
            EntityType::LlamaSpit { .. } => f.write_str("LLAMA_SPIT"),
            EntityType::Parrot { .. } => f.write_str("PARROT"),
            EntityType::Villager { .. } => f.write_str("VILLAGER"),
            EntityType::EnderCrystal { .. } => f.write_str("ENDER_CRYSTAL"),
            EntityType::Turtle { .. } => f.write_str("TURTLE"),
            EntityType::Phantom { .. } => f.write_str("PHANTOM"),
            EntityType::Trident { .. } => f.write_str("TRIDENT"),
            EntityType::Cod { .. } => f.write_str("COD"),
            EntityType::Salmon { .. } => f.write_str("SALMON"),
            EntityType::Pufferfish { .. } => f.write_str("PUFFERFISH"),
            EntityType::TropicalFish { .. } => f.write_str("TROPICAL_FISH"),
            EntityType::Drowned { .. } => f.write_str("DROWNED"),
            EntityType::Dolphin { .. } => f.write_str("DOLPHIN"),
            EntityType::Cat { .. } => f.write_str("CAT"),
            EntityType::Panda { .. } => f.write_str("PANDA"),
            EntityType::Pillager { .. } => f.write_str("PILLAGER"),
            EntityType::Ravager { .. } => f.write_str("RAVAGER"),
            EntityType::TraderLlama { .. } => f.write_str("TRADER_LLAMA"),
            EntityType::WanderingTrader { .. } => f.write_str("WANDERING_TRADER"),
            EntityType::Fox { .. } => f.write_str("FOX"),
            EntityType::Bee { .. } => f.write_str("BEE"),
            EntityType::Hoglin { .. } => f.write_str("HOGLIN"),
            EntityType::Piglin { .. } => f.write_str("PIGLIN"),
            EntityType::Strider { .. } => f.write_str("STRIDER"),
            EntityType::Zoglin { .. } => f.write_str("ZOGLIN"),
            EntityType::PiglinBrute { .. } => f.write_str("PIGLIN_BRUTE"),
            EntityType::Axolotl { .. } => f.write_str("AXOLOTL"),
            EntityType::GlowItemFrame { .. } => f.write_str("GLOW_ITEM_FRAME"),
            EntityType::GlowSquid { .. } => f.write_str("GLOW_SQUID"),
            EntityType::Goat { .. } => f.write_str("GOAT"),
            EntityType::Marker { .. } => f.write_str("MARKER"),
            EntityType::Allay { .. } => f.write_str("ALLAY"),
            EntityType::ChestBoat { .. } => f.write_str("CHEST_BOAT"),
            EntityType::Frog { .. } => f.write_str("FROG"),
            EntityType::Tadpole { .. } => f.write_str("TADPOLE"),
            EntityType::Warden { .. } => f.write_str("WARDEN"),
            EntityType::Camel { .. } => f.write_str("CAMEL"),
            EntityType::BlockDisplay { .. } => f.write_str("BLOCK_DISPLAY"),
            EntityType::Interaction { .. } => f.write_str("INTERACTION"),
            EntityType::ItemDisplay { .. } => f.write_str("ITEM_DISPLAY"),
            EntityType::Sniffer { .. } => f.write_str("SNIFFER"),
            EntityType::TextDisplay { .. } => f.write_str("TEXT_DISPLAY"),
            EntityType::FishingHook { .. } => f.write_str("FISHING_HOOK"),
            EntityType::Lightning { .. } => f.write_str("LIGHTNING"),
            EntityType::Player { .. } => f.write_str("PLAYER"),
            EntityType::Unknown { .. } => f.write_str("UNKNOWN"),
        }
    }
}

impl<'mc> EntityType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<EntityType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/EntityType");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/EntityType;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "DROPPED_ITEM" => Ok(EntityType::DroppedItem {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "EXPERIENCE_ORB" => Ok(EntityType::ExperienceOrb {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "AREA_EFFECT_CLOUD" => Ok(EntityType::AreaEffectCloud {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ELDER_GUARDIAN" => Ok(EntityType::ElderGuardian {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "WITHER_SKELETON" => Ok(EntityType::WitherSkeleton {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "STRAY" => Ok(EntityType::Stray {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "EGG" => Ok(EntityType::Egg {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "LEASH_HITCH" => Ok(EntityType::LeashHitch {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "PAINTING" => Ok(EntityType::Painting {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ARROW" => Ok(EntityType::Arrow {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SNOWBALL" => Ok(EntityType::Snowball {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "FIREBALL" => Ok(EntityType::Fireball {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SMALL_FIREBALL" => Ok(EntityType::SmallFireball {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ENDER_PEARL" => Ok(EntityType::EnderPearl {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ENDER_SIGNAL" => Ok(EntityType::EnderSignal {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SPLASH_POTION" => Ok(EntityType::SplashPotion {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "THROWN_EXP_BOTTLE" => Ok(EntityType::ThrownExpBottle {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ITEM_FRAME" => Ok(EntityType::ItemFrame {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "WITHER_SKULL" => Ok(EntityType::WitherSkull {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "PRIMED_TNT" => Ok(EntityType::PrimedTnt {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "FALLING_BLOCK" => Ok(EntityType::FallingBlock {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "FIREWORK" => Ok(EntityType::Firework {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "HUSK" => Ok(EntityType::Husk {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SPECTRAL_ARROW" => Ok(EntityType::SpectralArrow {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SHULKER_BULLET" => Ok(EntityType::ShulkerBullet {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "DRAGON_FIREBALL" => Ok(EntityType::DragonFireball {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ZOMBIE_VILLAGER" => Ok(EntityType::ZombieVillager {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SKELETON_HORSE" => Ok(EntityType::SkeletonHorse {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ZOMBIE_HORSE" => Ok(EntityType::ZombieHorse {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ARMOR_STAND" => Ok(EntityType::ArmorStand {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "DONKEY" => Ok(EntityType::Donkey {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "MULE" => Ok(EntityType::Mule {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "EVOKER_FANGS" => Ok(EntityType::EvokerFangs {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "EVOKER" => Ok(EntityType::Evoker {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "VEX" => Ok(EntityType::Vex {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "VINDICATOR" => Ok(EntityType::Vindicator {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ILLUSIONER" => Ok(EntityType::Illusioner {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART_COMMAND" => Ok(EntityType::MinecartCommand {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "BOAT" => Ok(EntityType::Boat {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART" => Ok(EntityType::Minecart {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART_CHEST" => Ok(EntityType::MinecartChest {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART_FURNACE" => Ok(EntityType::MinecartFurnace {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART_TNT" => Ok(EntityType::MinecartTnt {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART_HOPPER" => Ok(EntityType::MinecartHopper {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "MINECART_MOB_SPAWNER" => Ok(EntityType::MinecartMobSpawner {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "CREEPER" => Ok(EntityType::Creeper {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SKELETON" => Ok(EntityType::Skeleton {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SPIDER" => Ok(EntityType::Spider {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "GIANT" => Ok(EntityType::Giant {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ZOMBIE" => Ok(EntityType::Zombie {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SLIME" => Ok(EntityType::Slime {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "GHAST" => Ok(EntityType::Ghast {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ZOMBIFIED_PIGLIN" => Ok(EntityType::ZombifiedPiglin {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ENDERMAN" => Ok(EntityType::Enderman {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "CAVE_SPIDER" => Ok(EntityType::CaveSpider {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SILVERFISH" => Ok(EntityType::Silverfish {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "BLAZE" => Ok(EntityType::Blaze {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "MAGMA_CUBE" => Ok(EntityType::MagmaCube {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ENDER_DRAGON" => Ok(EntityType::EnderDragon {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "WITHER" => Ok(EntityType::Wither {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "BAT" => Ok(EntityType::Bat {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "WITCH" => Ok(EntityType::Witch {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ENDERMITE" => Ok(EntityType::Endermite {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "GUARDIAN" => Ok(EntityType::Guardian {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SHULKER" => Ok(EntityType::Shulker {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "PIG" => Ok(EntityType::Pig {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SHEEP" => Ok(EntityType::Sheep {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "COW" => Ok(EntityType::Cow {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "CHICKEN" => Ok(EntityType::Chicken {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SQUID" => Ok(EntityType::Squid {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "WOLF" => Ok(EntityType::Wolf {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "MUSHROOM_COW" => Ok(EntityType::MushroomCow {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SNOWMAN" => Ok(EntityType::Snowman {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "OCELOT" => Ok(EntityType::Ocelot {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "IRON_GOLEM" => Ok(EntityType::IronGolem {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "HORSE" => Ok(EntityType::Horse {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "RABBIT" => Ok(EntityType::Rabbit {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "POLAR_BEAR" => Ok(EntityType::PolarBear {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "LLAMA" => Ok(EntityType::Llama {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "LLAMA_SPIT" => Ok(EntityType::LlamaSpit {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "PARROT" => Ok(EntityType::Parrot {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "VILLAGER" => Ok(EntityType::Villager {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ENDER_CRYSTAL" => Ok(EntityType::EnderCrystal {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "TURTLE" => Ok(EntityType::Turtle {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "PHANTOM" => Ok(EntityType::Phantom {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "TRIDENT" => Ok(EntityType::Trident {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "COD" => Ok(EntityType::Cod {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SALMON" => Ok(EntityType::Salmon {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "PUFFERFISH" => Ok(EntityType::Pufferfish {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "TROPICAL_FISH" => Ok(EntityType::TropicalFish {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "DROWNED" => Ok(EntityType::Drowned {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "DOLPHIN" => Ok(EntityType::Dolphin {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "CAT" => Ok(EntityType::Cat {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "PANDA" => Ok(EntityType::Panda {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "PILLAGER" => Ok(EntityType::Pillager {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "RAVAGER" => Ok(EntityType::Ravager {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "TRADER_LLAMA" => Ok(EntityType::TraderLlama {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "WANDERING_TRADER" => Ok(EntityType::WanderingTrader {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "FOX" => Ok(EntityType::Fox {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "BEE" => Ok(EntityType::Bee {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "HOGLIN" => Ok(EntityType::Hoglin {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "PIGLIN" => Ok(EntityType::Piglin {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "STRIDER" => Ok(EntityType::Strider {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ZOGLIN" => Ok(EntityType::Zoglin {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "PIGLIN_BRUTE" => Ok(EntityType::PiglinBrute {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "AXOLOTL" => Ok(EntityType::Axolotl {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "GLOW_ITEM_FRAME" => Ok(EntityType::GlowItemFrame {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "GLOW_SQUID" => Ok(EntityType::GlowSquid {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "GOAT" => Ok(EntityType::Goat {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "MARKER" => Ok(EntityType::Marker {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ALLAY" => Ok(EntityType::Allay {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "CHEST_BOAT" => Ok(EntityType::ChestBoat {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "FROG" => Ok(EntityType::Frog {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "TADPOLE" => Ok(EntityType::Tadpole {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "WARDEN" => Ok(EntityType::Warden {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "CAMEL" => Ok(EntityType::Camel {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "BLOCK_DISPLAY" => Ok(EntityType::BlockDisplay {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "INTERACTION" => Ok(EntityType::Interaction {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "ITEM_DISPLAY" => Ok(EntityType::ItemDisplay {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "SNIFFER" => Ok(EntityType::Sniffer {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "TEXT_DISPLAY" => Ok(EntityType::TextDisplay {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "FISHING_HOOK" => Ok(EntityType::FishingHook {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "LIGHTNING" => Ok(EntityType::Lightning {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "PLAYER" => Ok(EntityType::Player {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),
            "UNKNOWN" => Ok(EntityType::Unknown {
                inner: EntityTypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct EntityTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EntityType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::DroppedItem { inner } => inner.0.clone(),
            Self::ExperienceOrb { inner } => inner.0.clone(),
            Self::AreaEffectCloud { inner } => inner.0.clone(),
            Self::ElderGuardian { inner } => inner.0.clone(),
            Self::WitherSkeleton { inner } => inner.0.clone(),
            Self::Stray { inner } => inner.0.clone(),
            Self::Egg { inner } => inner.0.clone(),
            Self::LeashHitch { inner } => inner.0.clone(),
            Self::Painting { inner } => inner.0.clone(),
            Self::Arrow { inner } => inner.0.clone(),
            Self::Snowball { inner } => inner.0.clone(),
            Self::Fireball { inner } => inner.0.clone(),
            Self::SmallFireball { inner } => inner.0.clone(),
            Self::EnderPearl { inner } => inner.0.clone(),
            Self::EnderSignal { inner } => inner.0.clone(),
            Self::SplashPotion { inner } => inner.0.clone(),
            Self::ThrownExpBottle { inner } => inner.0.clone(),
            Self::ItemFrame { inner } => inner.0.clone(),
            Self::WitherSkull { inner } => inner.0.clone(),
            Self::PrimedTnt { inner } => inner.0.clone(),
            Self::FallingBlock { inner } => inner.0.clone(),
            Self::Firework { inner } => inner.0.clone(),
            Self::Husk { inner } => inner.0.clone(),
            Self::SpectralArrow { inner } => inner.0.clone(),
            Self::ShulkerBullet { inner } => inner.0.clone(),
            Self::DragonFireball { inner } => inner.0.clone(),
            Self::ZombieVillager { inner } => inner.0.clone(),
            Self::SkeletonHorse { inner } => inner.0.clone(),
            Self::ZombieHorse { inner } => inner.0.clone(),
            Self::ArmorStand { inner } => inner.0.clone(),
            Self::Donkey { inner } => inner.0.clone(),
            Self::Mule { inner } => inner.0.clone(),
            Self::EvokerFangs { inner } => inner.0.clone(),
            Self::Evoker { inner } => inner.0.clone(),
            Self::Vex { inner } => inner.0.clone(),
            Self::Vindicator { inner } => inner.0.clone(),
            Self::Illusioner { inner } => inner.0.clone(),
            Self::MinecartCommand { inner } => inner.0.clone(),
            Self::Boat { inner } => inner.0.clone(),
            Self::Minecart { inner } => inner.0.clone(),
            Self::MinecartChest { inner } => inner.0.clone(),
            Self::MinecartFurnace { inner } => inner.0.clone(),
            Self::MinecartTnt { inner } => inner.0.clone(),
            Self::MinecartHopper { inner } => inner.0.clone(),
            Self::MinecartMobSpawner { inner } => inner.0.clone(),
            Self::Creeper { inner } => inner.0.clone(),
            Self::Skeleton { inner } => inner.0.clone(),
            Self::Spider { inner } => inner.0.clone(),
            Self::Giant { inner } => inner.0.clone(),
            Self::Zombie { inner } => inner.0.clone(),
            Self::Slime { inner } => inner.0.clone(),
            Self::Ghast { inner } => inner.0.clone(),
            Self::ZombifiedPiglin { inner } => inner.0.clone(),
            Self::Enderman { inner } => inner.0.clone(),
            Self::CaveSpider { inner } => inner.0.clone(),
            Self::Silverfish { inner } => inner.0.clone(),
            Self::Blaze { inner } => inner.0.clone(),
            Self::MagmaCube { inner } => inner.0.clone(),
            Self::EnderDragon { inner } => inner.0.clone(),
            Self::Wither { inner } => inner.0.clone(),
            Self::Bat { inner } => inner.0.clone(),
            Self::Witch { inner } => inner.0.clone(),
            Self::Endermite { inner } => inner.0.clone(),
            Self::Guardian { inner } => inner.0.clone(),
            Self::Shulker { inner } => inner.0.clone(),
            Self::Pig { inner } => inner.0.clone(),
            Self::Sheep { inner } => inner.0.clone(),
            Self::Cow { inner } => inner.0.clone(),
            Self::Chicken { inner } => inner.0.clone(),
            Self::Squid { inner } => inner.0.clone(),
            Self::Wolf { inner } => inner.0.clone(),
            Self::MushroomCow { inner } => inner.0.clone(),
            Self::Snowman { inner } => inner.0.clone(),
            Self::Ocelot { inner } => inner.0.clone(),
            Self::IronGolem { inner } => inner.0.clone(),
            Self::Horse { inner } => inner.0.clone(),
            Self::Rabbit { inner } => inner.0.clone(),
            Self::PolarBear { inner } => inner.0.clone(),
            Self::Llama { inner } => inner.0.clone(),
            Self::LlamaSpit { inner } => inner.0.clone(),
            Self::Parrot { inner } => inner.0.clone(),
            Self::Villager { inner } => inner.0.clone(),
            Self::EnderCrystal { inner } => inner.0.clone(),
            Self::Turtle { inner } => inner.0.clone(),
            Self::Phantom { inner } => inner.0.clone(),
            Self::Trident { inner } => inner.0.clone(),
            Self::Cod { inner } => inner.0.clone(),
            Self::Salmon { inner } => inner.0.clone(),
            Self::Pufferfish { inner } => inner.0.clone(),
            Self::TropicalFish { inner } => inner.0.clone(),
            Self::Drowned { inner } => inner.0.clone(),
            Self::Dolphin { inner } => inner.0.clone(),
            Self::Cat { inner } => inner.0.clone(),
            Self::Panda { inner } => inner.0.clone(),
            Self::Pillager { inner } => inner.0.clone(),
            Self::Ravager { inner } => inner.0.clone(),
            Self::TraderLlama { inner } => inner.0.clone(),
            Self::WanderingTrader { inner } => inner.0.clone(),
            Self::Fox { inner } => inner.0.clone(),
            Self::Bee { inner } => inner.0.clone(),
            Self::Hoglin { inner } => inner.0.clone(),
            Self::Piglin { inner } => inner.0.clone(),
            Self::Strider { inner } => inner.0.clone(),
            Self::Zoglin { inner } => inner.0.clone(),
            Self::PiglinBrute { inner } => inner.0.clone(),
            Self::Axolotl { inner } => inner.0.clone(),
            Self::GlowItemFrame { inner } => inner.0.clone(),
            Self::GlowSquid { inner } => inner.0.clone(),
            Self::Goat { inner } => inner.0.clone(),
            Self::Marker { inner } => inner.0.clone(),
            Self::Allay { inner } => inner.0.clone(),
            Self::ChestBoat { inner } => inner.0.clone(),
            Self::Frog { inner } => inner.0.clone(),
            Self::Tadpole { inner } => inner.0.clone(),
            Self::Warden { inner } => inner.0.clone(),
            Self::Camel { inner } => inner.0.clone(),
            Self::BlockDisplay { inner } => inner.0.clone(),
            Self::Interaction { inner } => inner.0.clone(),
            Self::ItemDisplay { inner } => inner.0.clone(),
            Self::Sniffer { inner } => inner.0.clone(),
            Self::TextDisplay { inner } => inner.0.clone(),
            Self::FishingHook { inner } => inner.0.clone(),
            Self::Lightning { inner } => inner.0.clone(),
            Self::Player { inner } => inner.0.clone(),
            Self::Unknown { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::DroppedItem { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ExperienceOrb { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::AreaEffectCloud { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ElderGuardian { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::WitherSkeleton { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Stray { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Egg { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::LeashHitch { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Painting { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Arrow { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Snowball { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Fireball { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::SmallFireball { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EnderPearl { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EnderSignal { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::SplashPotion { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ThrownExpBottle { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ItemFrame { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::WitherSkull { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::PrimedTnt { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::FallingBlock { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Firework { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Husk { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::SpectralArrow { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ShulkerBullet { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DragonFireball { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ZombieVillager { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::SkeletonHorse { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ZombieHorse { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ArmorStand { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Donkey { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Mule { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::EvokerFangs { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Evoker { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Vex { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Vindicator { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Illusioner { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MinecartCommand { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Boat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Minecart { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::MinecartChest { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MinecartFurnace { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MinecartTnt { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MinecartHopper { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MinecartMobSpawner { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Creeper { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Skeleton { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Spider { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Giant { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Zombie { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Slime { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Ghast { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::ZombifiedPiglin { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Enderman { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::CaveSpider { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Silverfish { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Blaze { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::MagmaCube { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EnderDragon { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Wither { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Bat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Witch { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Endermite { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Guardian { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Shulker { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Pig { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Sheep { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cow { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Chicken { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Squid { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Wolf { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::MushroomCow { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Snowman { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Ocelot { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::IronGolem { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Horse { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Rabbit { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::PolarBear { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Llama { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::LlamaSpit { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Parrot { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Villager { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::EnderCrystal { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Turtle { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Phantom { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Trident { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cod { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Salmon { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Pufferfish { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::TropicalFish { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Drowned { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Dolphin { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Panda { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Pillager { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Ravager { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::TraderLlama { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::WanderingTrader { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Fox { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Bee { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Hoglin { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Piglin { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Strider { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Zoglin { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::PiglinBrute { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Axolotl { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::GlowItemFrame { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::GlowSquid { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Goat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Marker { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Allay { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::ChestBoat { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Frog { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Tadpole { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Warden { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Camel { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::BlockDisplay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Interaction { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ItemDisplay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Sniffer { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::TextDisplay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::FishingHook { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Lightning { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Player { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Unknown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EntityType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate EntityType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EntityType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EntityType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "DROPPED_ITEM" => Ok(EntityType::DroppedItem {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "EXPERIENCE_ORB" => Ok(EntityType::ExperienceOrb {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "AREA_EFFECT_CLOUD" => Ok(EntityType::AreaEffectCloud {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ELDER_GUARDIAN" => Ok(EntityType::ElderGuardian {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "WITHER_SKELETON" => Ok(EntityType::WitherSkeleton {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "STRAY" => Ok(EntityType::Stray {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "EGG" => Ok(EntityType::Egg {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "LEASH_HITCH" => Ok(EntityType::LeashHitch {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "PAINTING" => Ok(EntityType::Painting {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ARROW" => Ok(EntityType::Arrow {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SNOWBALL" => Ok(EntityType::Snowball {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "FIREBALL" => Ok(EntityType::Fireball {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SMALL_FIREBALL" => Ok(EntityType::SmallFireball {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ENDER_PEARL" => Ok(EntityType::EnderPearl {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ENDER_SIGNAL" => Ok(EntityType::EnderSignal {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SPLASH_POTION" => Ok(EntityType::SplashPotion {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "THROWN_EXP_BOTTLE" => Ok(EntityType::ThrownExpBottle {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ITEM_FRAME" => Ok(EntityType::ItemFrame {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "WITHER_SKULL" => Ok(EntityType::WitherSkull {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "PRIMED_TNT" => Ok(EntityType::PrimedTnt {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "FALLING_BLOCK" => Ok(EntityType::FallingBlock {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "FIREWORK" => Ok(EntityType::Firework {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "HUSK" => Ok(EntityType::Husk {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SPECTRAL_ARROW" => Ok(EntityType::SpectralArrow {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SHULKER_BULLET" => Ok(EntityType::ShulkerBullet {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "DRAGON_FIREBALL" => Ok(EntityType::DragonFireball {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ZOMBIE_VILLAGER" => Ok(EntityType::ZombieVillager {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SKELETON_HORSE" => Ok(EntityType::SkeletonHorse {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ZOMBIE_HORSE" => Ok(EntityType::ZombieHorse {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ARMOR_STAND" => Ok(EntityType::ArmorStand {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "DONKEY" => Ok(EntityType::Donkey {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "MULE" => Ok(EntityType::Mule {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "EVOKER_FANGS" => Ok(EntityType::EvokerFangs {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "EVOKER" => Ok(EntityType::Evoker {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "VEX" => Ok(EntityType::Vex {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "VINDICATOR" => Ok(EntityType::Vindicator {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ILLUSIONER" => Ok(EntityType::Illusioner {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART_COMMAND" => Ok(EntityType::MinecartCommand {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "BOAT" => Ok(EntityType::Boat {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART" => Ok(EntityType::Minecart {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART_CHEST" => Ok(EntityType::MinecartChest {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART_FURNACE" => Ok(EntityType::MinecartFurnace {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART_TNT" => Ok(EntityType::MinecartTnt {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART_HOPPER" => Ok(EntityType::MinecartHopper {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "MINECART_MOB_SPAWNER" => Ok(EntityType::MinecartMobSpawner {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "CREEPER" => Ok(EntityType::Creeper {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SKELETON" => Ok(EntityType::Skeleton {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SPIDER" => Ok(EntityType::Spider {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "GIANT" => Ok(EntityType::Giant {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ZOMBIE" => Ok(EntityType::Zombie {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SLIME" => Ok(EntityType::Slime {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "GHAST" => Ok(EntityType::Ghast {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ZOMBIFIED_PIGLIN" => Ok(EntityType::ZombifiedPiglin {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ENDERMAN" => Ok(EntityType::Enderman {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "CAVE_SPIDER" => Ok(EntityType::CaveSpider {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SILVERFISH" => Ok(EntityType::Silverfish {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "BLAZE" => Ok(EntityType::Blaze {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "MAGMA_CUBE" => Ok(EntityType::MagmaCube {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ENDER_DRAGON" => Ok(EntityType::EnderDragon {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "WITHER" => Ok(EntityType::Wither {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "BAT" => Ok(EntityType::Bat {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "WITCH" => Ok(EntityType::Witch {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ENDERMITE" => Ok(EntityType::Endermite {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "GUARDIAN" => Ok(EntityType::Guardian {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SHULKER" => Ok(EntityType::Shulker {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "PIG" => Ok(EntityType::Pig {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SHEEP" => Ok(EntityType::Sheep {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "COW" => Ok(EntityType::Cow {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "CHICKEN" => Ok(EntityType::Chicken {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SQUID" => Ok(EntityType::Squid {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "WOLF" => Ok(EntityType::Wolf {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "MUSHROOM_COW" => Ok(EntityType::MushroomCow {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SNOWMAN" => Ok(EntityType::Snowman {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "OCELOT" => Ok(EntityType::Ocelot {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "IRON_GOLEM" => Ok(EntityType::IronGolem {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "HORSE" => Ok(EntityType::Horse {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "RABBIT" => Ok(EntityType::Rabbit {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "POLAR_BEAR" => Ok(EntityType::PolarBear {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "LLAMA" => Ok(EntityType::Llama {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "LLAMA_SPIT" => Ok(EntityType::LlamaSpit {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "PARROT" => Ok(EntityType::Parrot {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "VILLAGER" => Ok(EntityType::Villager {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ENDER_CRYSTAL" => Ok(EntityType::EnderCrystal {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "TURTLE" => Ok(EntityType::Turtle {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "PHANTOM" => Ok(EntityType::Phantom {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "TRIDENT" => Ok(EntityType::Trident {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "COD" => Ok(EntityType::Cod {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SALMON" => Ok(EntityType::Salmon {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "PUFFERFISH" => Ok(EntityType::Pufferfish {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "TROPICAL_FISH" => Ok(EntityType::TropicalFish {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "DROWNED" => Ok(EntityType::Drowned {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "DOLPHIN" => Ok(EntityType::Dolphin {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "CAT" => Ok(EntityType::Cat {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "PANDA" => Ok(EntityType::Panda {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "PILLAGER" => Ok(EntityType::Pillager {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "RAVAGER" => Ok(EntityType::Ravager {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "TRADER_LLAMA" => Ok(EntityType::TraderLlama {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "WANDERING_TRADER" => Ok(EntityType::WanderingTrader {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "FOX" => Ok(EntityType::Fox {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "BEE" => Ok(EntityType::Bee {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "HOGLIN" => Ok(EntityType::Hoglin {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "PIGLIN" => Ok(EntityType::Piglin {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "STRIDER" => Ok(EntityType::Strider {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ZOGLIN" => Ok(EntityType::Zoglin {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "PIGLIN_BRUTE" => Ok(EntityType::PiglinBrute {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "AXOLOTL" => Ok(EntityType::Axolotl {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "GLOW_ITEM_FRAME" => Ok(EntityType::GlowItemFrame {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "GLOW_SQUID" => Ok(EntityType::GlowSquid {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "GOAT" => Ok(EntityType::Goat {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "MARKER" => Ok(EntityType::Marker {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ALLAY" => Ok(EntityType::Allay {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "CHEST_BOAT" => Ok(EntityType::ChestBoat {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "FROG" => Ok(EntityType::Frog {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "TADPOLE" => Ok(EntityType::Tadpole {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "WARDEN" => Ok(EntityType::Warden {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "CAMEL" => Ok(EntityType::Camel {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "BLOCK_DISPLAY" => Ok(EntityType::BlockDisplay {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "INTERACTION" => Ok(EntityType::Interaction {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "ITEM_DISPLAY" => Ok(EntityType::ItemDisplay {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "SNIFFER" => Ok(EntityType::Sniffer {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "TEXT_DISPLAY" => Ok(EntityType::TextDisplay {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "FISHING_HOOK" => Ok(EntityType::FishingHook {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "LIGHTNING" => Ok(EntityType::Lightning {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "PLAYER" => Ok(EntityType::Player {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                "UNKNOWN" => Ok(EntityType::Unknown {
                    inner: EntityTypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for EntityTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EntityTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate EntityTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EntityType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EntityTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EntityTypeStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a ZombieHorse - variant of <a title="interface in org.bukkit.entity" href="AbstractHorse.html"><code>AbstractHorse</code></a>.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ZombieHorse<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ZombieHorse<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ZombieHorse<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ZombieHorse from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ZombieHorse")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ZombieHorse object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ZombieHorse<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::AbstractHorse<'mc>> for ZombieHorse<'mc> {
    fn into(self) -> crate::entity::AbstractHorse<'mc> {
        crate::entity::AbstractHorse::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ZombieHorse into crate::entity::AbstractHorse")
    }
}
pub enum Profession<'mc> {
    None { inner: ProfessionStruct<'mc> },
    Armorer { inner: ProfessionStruct<'mc> },
    Butcher { inner: ProfessionStruct<'mc> },
    Cartographer { inner: ProfessionStruct<'mc> },
    Cleric { inner: ProfessionStruct<'mc> },
    Farmer { inner: ProfessionStruct<'mc> },
    Fisherman { inner: ProfessionStruct<'mc> },
    Fletcher { inner: ProfessionStruct<'mc> },
    Leatherworker { inner: ProfessionStruct<'mc> },
    Librarian { inner: ProfessionStruct<'mc> },
    Mason { inner: ProfessionStruct<'mc> },
    Nitwit { inner: ProfessionStruct<'mc> },
    Shepherd { inner: ProfessionStruct<'mc> },
    Toolsmith { inner: ProfessionStruct<'mc> },
    Weaponsmith { inner: ProfessionStruct<'mc> },
}
impl<'mc> std::fmt::Display for Profession<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Profession::None { .. } => f.write_str("NONE"),
            Profession::Armorer { .. } => f.write_str("ARMORER"),
            Profession::Butcher { .. } => f.write_str("BUTCHER"),
            Profession::Cartographer { .. } => f.write_str("CARTOGRAPHER"),
            Profession::Cleric { .. } => f.write_str("CLERIC"),
            Profession::Farmer { .. } => f.write_str("FARMER"),
            Profession::Fisherman { .. } => f.write_str("FISHERMAN"),
            Profession::Fletcher { .. } => f.write_str("FLETCHER"),
            Profession::Leatherworker { .. } => f.write_str("LEATHERWORKER"),
            Profession::Librarian { .. } => f.write_str("LIBRARIAN"),
            Profession::Mason { .. } => f.write_str("MASON"),
            Profession::Nitwit { .. } => f.write_str("NITWIT"),
            Profession::Shepherd { .. } => f.write_str("SHEPHERD"),
            Profession::Toolsmith { .. } => f.write_str("TOOLSMITH"),
            Profession::Weaponsmith { .. } => f.write_str("WEAPONSMITH"),
        }
    }
}

impl<'mc> Profession<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Profession<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Profession");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Profession;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NONE" => Ok(Profession::None {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "ARMORER" => Ok(Profession::Armorer {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "BUTCHER" => Ok(Profession::Butcher {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "CARTOGRAPHER" => Ok(Profession::Cartographer {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "CLERIC" => Ok(Profession::Cleric {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "FARMER" => Ok(Profession::Farmer {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "FISHERMAN" => Ok(Profession::Fisherman {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "FLETCHER" => Ok(Profession::Fletcher {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "LEATHERWORKER" => Ok(Profession::Leatherworker {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "LIBRARIAN" => Ok(Profession::Librarian {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "MASON" => Ok(Profession::Mason {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "NITWIT" => Ok(Profession::Nitwit {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "SHEPHERD" => Ok(Profession::Shepherd {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "TOOLSMITH" => Ok(Profession::Toolsmith {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),
            "WEAPONSMITH" => Ok(Profession::Weaponsmith {
                inner: ProfessionStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct ProfessionStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Profession<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::None { inner } => inner.0.clone(),
            Self::Armorer { inner } => inner.0.clone(),
            Self::Butcher { inner } => inner.0.clone(),
            Self::Cartographer { inner } => inner.0.clone(),
            Self::Cleric { inner } => inner.0.clone(),
            Self::Farmer { inner } => inner.0.clone(),
            Self::Fisherman { inner } => inner.0.clone(),
            Self::Fletcher { inner } => inner.0.clone(),
            Self::Leatherworker { inner } => inner.0.clone(),
            Self::Librarian { inner } => inner.0.clone(),
            Self::Mason { inner } => inner.0.clone(),
            Self::Nitwit { inner } => inner.0.clone(),
            Self::Shepherd { inner } => inner.0.clone(),
            Self::Toolsmith { inner } => inner.0.clone(),
            Self::Weaponsmith { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Armorer { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Butcher { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Cartographer { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Cleric { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Farmer { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Fisherman { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Fletcher { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Leatherworker { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Librarian { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Mason { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Nitwit { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Shepherd { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Toolsmith { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Weaponsmith { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Profession<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Profession from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Profession")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Profession object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NONE" => Ok(Profession::None {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "ARMORER" => Ok(Profession::Armorer {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "BUTCHER" => Ok(Profession::Butcher {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "CARTOGRAPHER" => Ok(Profession::Cartographer {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "CLERIC" => Ok(Profession::Cleric {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "FARMER" => Ok(Profession::Farmer {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "FISHERMAN" => Ok(Profession::Fisherman {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "FLETCHER" => Ok(Profession::Fletcher {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "LEATHERWORKER" => Ok(Profession::Leatherworker {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "LIBRARIAN" => Ok(Profession::Librarian {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "MASON" => Ok(Profession::Mason {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "NITWIT" => Ok(Profession::Nitwit {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "SHEPHERD" => Ok(Profession::Shepherd {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "TOOLSMITH" => Ok(Profession::Toolsmith {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                "WEAPONSMITH" => Ok(Profession::Weaponsmith {
                    inner: ProfessionStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for ProfessionStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ProfessionStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ProfessionStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Profession")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ProfessionStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ProfessionStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents Horse-like creatures which can carry an inventory.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ChestedHorse<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ChestedHorse<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ChestedHorse<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ChestedHorse from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ChestedHorse")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ChestedHorse object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ChestedHorse<'mc> {
    pub fn is_carrying_chest(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isCarryingChest", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the horse has a chest equipped. Removing a chest will also clear the chest's inventory.
    pub fn set_carrying_chest(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCarryingChest",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn variant(&self) -> Result<crate::entity::HorseVariant<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ChestedHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.variant()
    }
    pub fn inventory(
        &self,
    ) -> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ChestedHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.inventory()
    }
    pub fn set_variant(
        &self,
        arg0: impl Into<crate::entity::HorseVariant<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ChestedHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_variant(arg0)
    }
    pub fn domestication(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ChestedHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.domestication()
    }
    pub fn set_domestication(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ChestedHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_domestication(arg0)
    }
    pub fn max_domestication(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ChestedHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.max_domestication()
    }
    pub fn set_max_domestication(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ChestedHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_max_domestication(arg0)
    }
    pub fn jump_strength(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = ChestedHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.jump_strength()
    }
    pub fn set_jump_strength(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ChestedHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_jump_strength(arg0)
    }
    pub fn is_eating_haystack(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ChestedHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.is_eating_haystack()
    }
    pub fn set_eating_haystack(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ChestedHorse::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::AbstractHorse = temp_clone.into();
        real.set_eating_haystack(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::AbstractHorse<'mc>> for ChestedHorse<'mc> {
    fn into(self) -> crate::entity::AbstractHorse<'mc> {
        crate::entity::AbstractHorse::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ChestedHorse into crate::entity::AbstractHorse")
    }
}
/// Meow.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Cat<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Cat<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Cat<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Cat from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Cat")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Cat object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Cat<'mc> {
    pub fn collar_color(&self) -> Result<crate::DyeColor<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/DyeColor;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getCollarColor", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::DyeColor::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_collar_color(
        &self,
        arg0: impl Into<crate::DyeColor<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/DyeColor;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCollarColor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn cat_type(&self) -> Result<crate::entity::CatType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Cat$Type;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getCatType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::CatType::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_cat_type(
        &self,
        arg0: impl Into<crate::entity::CatType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Cat$Type;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCatType",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn owner(
        &self,
    ) -> Result<Option<crate::entity::AnimalTamer<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Cat::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.owner()
    }
    pub fn set_owner(
        &self,
        arg0: impl Into<crate::entity::AnimalTamer<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Cat::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.set_owner(arg0)
    }
    pub fn is_tamed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Cat::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.is_tamed()
    }
    pub fn set_tamed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Cat::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Tameable = temp_clone.into();
        real.set_tamed(arg0)
    }
    pub fn is_sitting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Cat::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Sittable = temp_clone.into();
        real.is_sitting()
    }
    pub fn set_sitting(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Cat::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Sittable = temp_clone.into();
        real.set_sitting(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Tameable<'mc>> for Cat<'mc> {
    fn into(self) -> crate::entity::Tameable<'mc> {
        crate::entity::Tameable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Cat into crate::entity::Tameable")
    }
}
impl<'mc> Into<crate::entity::Sittable<'mc>> for Cat<'mc> {
    fn into(self) -> crate::entity::Sittable<'mc> {
        crate::entity::Sittable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Cat into crate::entity::Sittable")
    }
}
/// Represents Villager type, usually corresponding to what biome they spawn in.
pub enum VillagerType<'mc> {
    Desert { inner: VillagerTypeStruct<'mc> },
    Jungle { inner: VillagerTypeStruct<'mc> },
    Plains { inner: VillagerTypeStruct<'mc> },
    Savanna { inner: VillagerTypeStruct<'mc> },
    Snow { inner: VillagerTypeStruct<'mc> },
    Swamp { inner: VillagerTypeStruct<'mc> },
    Taiga { inner: VillagerTypeStruct<'mc> },
}
impl<'mc> std::fmt::Display for VillagerType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VillagerType::Desert { .. } => f.write_str("DESERT"),
            VillagerType::Jungle { .. } => f.write_str("JUNGLE"),
            VillagerType::Plains { .. } => f.write_str("PLAINS"),
            VillagerType::Savanna { .. } => f.write_str("SAVANNA"),
            VillagerType::Snow { .. } => f.write_str("SNOW"),
            VillagerType::Swamp { .. } => f.write_str("SWAMP"),
            VillagerType::Taiga { .. } => f.write_str("TAIGA"),
        }
    }
}

impl<'mc> VillagerType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<VillagerType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Villager$Type");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Villager$Type;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "DESERT" => Ok(VillagerType::Desert {
                inner: VillagerTypeStruct::from_raw(env, obj)?,
            }),
            "JUNGLE" => Ok(VillagerType::Jungle {
                inner: VillagerTypeStruct::from_raw(env, obj)?,
            }),
            "PLAINS" => Ok(VillagerType::Plains {
                inner: VillagerTypeStruct::from_raw(env, obj)?,
            }),
            "SAVANNA" => Ok(VillagerType::Savanna {
                inner: VillagerTypeStruct::from_raw(env, obj)?,
            }),
            "SNOW" => Ok(VillagerType::Snow {
                inner: VillagerTypeStruct::from_raw(env, obj)?,
            }),
            "SWAMP" => Ok(VillagerType::Swamp {
                inner: VillagerTypeStruct::from_raw(env, obj)?,
            }),
            "TAIGA" => Ok(VillagerType::Taiga {
                inner: VillagerTypeStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct VillagerTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for VillagerType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Desert { inner } => inner.0.clone(),
            Self::Jungle { inner } => inner.0.clone(),
            Self::Plains { inner } => inner.0.clone(),
            Self::Savanna { inner } => inner.0.clone(),
            Self::Snow { inner } => inner.0.clone(),
            Self::Swamp { inner } => inner.0.clone(),
            Self::Taiga { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Desert { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Jungle { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Plains { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Savanna { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Snow { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Swamp { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Taiga { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for VillagerType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate VillagerType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Villager$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a VillagerType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "DESERT" => Ok(VillagerType::Desert {
                    inner: VillagerTypeStruct::from_raw(env, obj)?,
                }),
                "JUNGLE" => Ok(VillagerType::Jungle {
                    inner: VillagerTypeStruct::from_raw(env, obj)?,
                }),
                "PLAINS" => Ok(VillagerType::Plains {
                    inner: VillagerTypeStruct::from_raw(env, obj)?,
                }),
                "SAVANNA" => Ok(VillagerType::Savanna {
                    inner: VillagerTypeStruct::from_raw(env, obj)?,
                }),
                "SNOW" => Ok(VillagerType::Snow {
                    inner: VillagerTypeStruct::from_raw(env, obj)?,
                }),
                "SWAMP" => Ok(VillagerType::Swamp {
                    inner: VillagerTypeStruct::from_raw(env, obj)?,
                }),
                "TAIGA" => Ok(VillagerType::Taiga {
                    inner: VillagerTypeStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for VillagerTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for VillagerTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate VillagerTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Villager$Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a VillagerTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> VillagerTypeStruct<'mc> {
    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// An Axolotl.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Axolotl<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Axolotl<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Axolotl<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Axolotl from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Axolotl")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Axolotl object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Axolotl<'mc> {
    pub fn variant(
        &self,
    ) -> Result<crate::entity::AxolotlVariant<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Axolotl$Variant;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getVariant", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::AxolotlVariant::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_variant(
        &self,
        arg0: impl Into<crate::entity::AxolotlVariant<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Axolotl$Variant;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVariant",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_playing_dead(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isPlayingDead", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if this axolotl is playing dead. An axolotl may play dead when it is damaged underwater.
    pub fn set_playing_dead(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPlayingDead",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Axolotl::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Axolotl::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Axolotl::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Axolotl<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Axolotl into crate::entity::Animals")
    }
}
/// Represents a Giant.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Giant<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Giant<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Giant<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Giant from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Giant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Giant object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Giant<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Giant<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Giant into crate::entity::Monster")
    }
}
/// Represents a Creeper
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Creeper<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Creeper<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Creeper<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Creeper from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Creeper")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Creeper object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Creeper<'mc> {
    pub fn is_powered(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isPowered", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets the Powered status of this Creeper
    pub fn set_powered(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPowered",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Set the fuse ticks for this Creeper, where the ticks is the amount of time in which a creeper has been in the primed state.
    pub fn set_fuse_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFuseTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn fuse_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFuseTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn ignite(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "ignite", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn explode(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "explode", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Set the maximum fuse ticks for this Creeper, where the maximum ticks is the amount of time in which a creeper is allowed to be in the primed state before exploding.
    pub fn set_max_fuse_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaxFuseTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn max_fuse_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxFuseTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the explosion radius in which this Creeper's explosion will affect.
    pub fn set_explosion_radius(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setExplosionRadius",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn explosion_radius(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getExplosionRadius",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Monster<'mc>> for Creeper<'mc> {
    fn into(self) -> crate::entity::Monster<'mc> {
        crate::entity::Monster::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Creeper into crate::entity::Monster")
    }
}
/// Represents a complex living entity - one that is made up of various smaller parts
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct ComplexLivingEntity<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ComplexLivingEntity<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ComplexLivingEntity<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ComplexLivingEntity from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/ComplexLivingEntity")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ComplexLivingEntity object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ComplexLivingEntity<'mc> {
    pub fn parts(&self) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getParts", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn maximum_no_damage_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaximumNoDamageTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_arrows_in_body(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_arrows_in_body(arg0)
    }
    pub fn get_eye_height(&self, arg0: bool) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_eye_height(arg0)
    }
    pub fn eye_location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.eye_location()
    }
    pub fn get_line_of_sight(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<Vec<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_line_of_sight(arg0, arg1)
    }
    pub fn get_target_block(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_target_block(arg0, arg1)
    }
    pub fn get_last_two_target_blocks(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<Vec<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/Set;I)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLastTwoTargetBlocks",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::block::Block::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn get_target_block_exact_with_int(
        &self,
        arg0: i32,
        arg1: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>,
    ) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/FluidCollisionMode;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/block/Block;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTargetBlockExact",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Block::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn ray_trace_blocks_with_double(
        &self,
        arg0: f64,
        arg1: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>,
    ) -> Result<crate::util::RayTraceResult<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "D";
        let val_1 = jni::objects::JValueGen::Double(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/FluidCollisionMode;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/util/RayTraceResult;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "rayTraceBlocks", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::RayTraceResult::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn remaining_air(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.remaining_air()
    }
    pub fn set_remaining_air(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_remaining_air(arg0)
    }
    pub fn maximum_air(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.maximum_air()
    }
    pub fn set_maximum_air(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_maximum_air(arg0)
    }
    pub fn arrow_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.arrow_cooldown()
    }
    pub fn set_arrow_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_arrow_cooldown(arg0)
    }
    pub fn arrows_in_body(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.arrows_in_body()
    }
    pub fn set_maximum_no_damage_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaximumNoDamageTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn last_damage(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.last_damage()
    }
    pub fn set_last_damage(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_last_damage(arg0)
    }
    pub fn no_damage_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNoDamageTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_no_damage_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setNoDamageTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn no_action_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNoActionTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_no_action_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setNoActionTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn killer(&self) -> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.killer()
    }
    pub fn add_potion_effect_with_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffect<'mc>>,
        arg1: std::option::Option<bool>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/potion/PotionEffect;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Z";
            let val_2 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_2);
        }
        sig += ")Z";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "addPotionEffect", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn has_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasPotionEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn get_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<crate::potion::PotionEffect<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_potion_effect(arg0)
    }
    pub fn remove_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.remove_potion_effect(arg0)
    }
    pub fn active_potion_effects(
        &self,
    ) -> Result<Vec<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getActivePotionEffects",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::potion::PotionEffect::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    pub fn has_line_of_sight(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.has_line_of_sight(arg0)
    }
    pub fn remove_when_far_away(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.remove_when_far_away()
    }
    pub fn set_remove_when_far_away(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_remove_when_far_away(arg0)
    }
    pub fn equipment(
        &self,
    ) -> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.equipment()
    }
    pub fn set_can_pickup_items(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCanPickupItems",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn can_pickup_items(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCanPickupItems",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn is_leashed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_leashed()
    }
    pub fn leash_holder(&self) -> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.leash_holder()
    }
    pub fn set_leash_holder(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_leash_holder(arg0)
    }
    pub fn is_gliding(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_gliding()
    }
    pub fn set_gliding(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_gliding(arg0)
    }
    pub fn is_swimming(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_swimming()
    }
    pub fn set_swimming(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_swimming(arg0)
    }
    pub fn is_riptiding(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_riptiding()
    }
    pub fn is_sleeping(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_sleeping()
    }
    pub fn is_climbing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_climbing()
    }
    pub fn set_ai(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_ai(arg0)
    }
    pub fn has_ai(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.has_ai()
    }
    pub fn attack(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.attack(arg0)
    }
    pub fn swing_main_hand(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.swing_main_hand()
    }
    pub fn swing_off_hand(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.swing_off_hand()
    }
    pub fn play_hurt_animation(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.play_hurt_animation(arg0)
    }
    pub fn set_collidable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_collidable(arg0)
    }
    pub fn is_collidable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_collidable()
    }
    pub fn collidable_exemptions(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCollidableExemptions",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn get_memory(
        &self,
        arg0: impl Into<crate::entity::memory::MemoryKey<'mc>>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_memory(arg0)
    }
    pub fn hurt_sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.hurt_sound()
    }
    pub fn death_sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.death_sound()
    }
    pub fn get_fall_damage_sound(
        &self,
        arg0: i32,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_fall_damage_sound(arg0)
    }
    pub fn fall_damage_sound_small(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.fall_damage_sound_small()
    }
    pub fn fall_damage_sound_big(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.fall_damage_sound_big()
    }
    pub fn get_drinking_sound(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_drinking_sound(arg0)
    }
    pub fn get_eating_sound(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.get_eating_sound(arg0)
    }
    pub fn can_breathe_underwater(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.can_breathe_underwater()
    }
    pub fn category(
        &self,
    ) -> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.category()
    }
    pub fn set_invisible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_invisible(arg0)
    }
    pub fn is_invisible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.is_invisible()
    }
    pub fn set_memory(
        &self,
        arg0: impl Into<crate::entity::memory::MemoryKey<'mc>>,
        arg1: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = ComplexLivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::LivingEntity = temp_clone.into();
        real.set_memory(arg0, arg1)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::LivingEntity<'mc>> for ComplexLivingEntity<'mc> {
    fn into(self) -> crate::entity::LivingEntity<'mc> {
        crate::entity::LivingEntity::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ComplexLivingEntity into crate::entity::LivingEntity")
    }
}
/// Represents the base color that the llama has.
pub enum LlamaColor<'mc> {
    Creamy { inner: LlamaColorStruct<'mc> },
    White { inner: LlamaColorStruct<'mc> },
    Brown { inner: LlamaColorStruct<'mc> },
    Gray { inner: LlamaColorStruct<'mc> },
}
impl<'mc> std::fmt::Display for LlamaColor<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LlamaColor::Creamy { .. } => f.write_str("CREAMY"),
            LlamaColor::White { .. } => f.write_str("WHITE"),
            LlamaColor::Brown { .. } => f.write_str("BROWN"),
            LlamaColor::Gray { .. } => f.write_str("GRAY"),
        }
    }
}

impl<'mc> LlamaColor<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<LlamaColor<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Llama$Color");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Llama$Color;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "CREAMY" => Ok(LlamaColor::Creamy {
                inner: LlamaColorStruct::from_raw(env, obj)?,
            }),
            "WHITE" => Ok(LlamaColor::White {
                inner: LlamaColorStruct::from_raw(env, obj)?,
            }),
            "BROWN" => Ok(LlamaColor::Brown {
                inner: LlamaColorStruct::from_raw(env, obj)?,
            }),
            "GRAY" => Ok(LlamaColor::Gray {
                inner: LlamaColorStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct LlamaColorStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for LlamaColor<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Creamy { inner } => inner.0.clone(),
            Self::White { inner } => inner.0.clone(),
            Self::Brown { inner } => inner.0.clone(),
            Self::Gray { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Creamy { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::White { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Brown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Gray { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for LlamaColor<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate LlamaColor from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Llama$Color")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a LlamaColor object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "CREAMY" => Ok(LlamaColor::Creamy {
                    inner: LlamaColorStruct::from_raw(env, obj)?,
                }),
                "WHITE" => Ok(LlamaColor::White {
                    inner: LlamaColorStruct::from_raw(env, obj)?,
                }),
                "BROWN" => Ok(LlamaColor::Brown {
                    inner: LlamaColorStruct::from_raw(env, obj)?,
                }),
                "GRAY" => Ok(LlamaColor::Gray {
                    inner: LlamaColorStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for LlamaColorStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for LlamaColorStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate LlamaColorStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Llama$Color")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a LlamaColorStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> LlamaColorStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}

pub enum HorseVariant<'mc> {
    Horse { inner: HorseVariantStruct<'mc> },
    Donkey { inner: HorseVariantStruct<'mc> },
    Mule { inner: HorseVariantStruct<'mc> },
    UndeadHorse { inner: HorseVariantStruct<'mc> },
    SkeletonHorse { inner: HorseVariantStruct<'mc> },
    Llama { inner: HorseVariantStruct<'mc> },
    Camel { inner: HorseVariantStruct<'mc> },
}
impl<'mc> std::fmt::Display for HorseVariant<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HorseVariant::Horse { .. } => f.write_str("HORSE"),
            HorseVariant::Donkey { .. } => f.write_str("DONKEY"),
            HorseVariant::Mule { .. } => f.write_str("MULE"),
            HorseVariant::UndeadHorse { .. } => f.write_str("UNDEAD_HORSE"),
            HorseVariant::SkeletonHorse { .. } => f.write_str("SKELETON_HORSE"),
            HorseVariant::Llama { .. } => f.write_str("LLAMA"),
            HorseVariant::Camel { .. } => f.write_str("CAMEL"),
        }
    }
}

impl<'mc> HorseVariant<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<HorseVariant<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Horse$Variant");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Horse$Variant;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "HORSE" => Ok(HorseVariant::Horse {
                inner: HorseVariantStruct::from_raw(env, obj)?,
            }),
            "DONKEY" => Ok(HorseVariant::Donkey {
                inner: HorseVariantStruct::from_raw(env, obj)?,
            }),
            "MULE" => Ok(HorseVariant::Mule {
                inner: HorseVariantStruct::from_raw(env, obj)?,
            }),
            "UNDEAD_HORSE" => Ok(HorseVariant::UndeadHorse {
                inner: HorseVariantStruct::from_raw(env, obj)?,
            }),
            "SKELETON_HORSE" => Ok(HorseVariant::SkeletonHorse {
                inner: HorseVariantStruct::from_raw(env, obj)?,
            }),
            "LLAMA" => Ok(HorseVariant::Llama {
                inner: HorseVariantStruct::from_raw(env, obj)?,
            }),
            "CAMEL" => Ok(HorseVariant::Camel {
                inner: HorseVariantStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct HorseVariantStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for HorseVariant<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Horse { inner } => inner.0.clone(),
            Self::Donkey { inner } => inner.0.clone(),
            Self::Mule { inner } => inner.0.clone(),
            Self::UndeadHorse { inner } => inner.0.clone(),
            Self::SkeletonHorse { inner } => inner.0.clone(),
            Self::Llama { inner } => inner.0.clone(),
            Self::Camel { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Horse { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Donkey { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Mule { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::UndeadHorse { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::SkeletonHorse { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Llama { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Camel { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for HorseVariant<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate HorseVariant from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse$Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a HorseVariant object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "HORSE" => Ok(HorseVariant::Horse {
                    inner: HorseVariantStruct::from_raw(env, obj)?,
                }),
                "DONKEY" => Ok(HorseVariant::Donkey {
                    inner: HorseVariantStruct::from_raw(env, obj)?,
                }),
                "MULE" => Ok(HorseVariant::Mule {
                    inner: HorseVariantStruct::from_raw(env, obj)?,
                }),
                "UNDEAD_HORSE" => Ok(HorseVariant::UndeadHorse {
                    inner: HorseVariantStruct::from_raw(env, obj)?,
                }),
                "SKELETON_HORSE" => Ok(HorseVariant::SkeletonHorse {
                    inner: HorseVariantStruct::from_raw(env, obj)?,
                }),
                "LLAMA" => Ok(HorseVariant::Llama {
                    inner: HorseVariantStruct::from_raw(env, obj)?,
                }),
                "CAMEL" => Ok(HorseVariant::Camel {
                    inner: HorseVariantStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for HorseVariantStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for HorseVariantStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate HorseVariantStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Horse$Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a HorseVariantStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> HorseVariantStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}

///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Shulker<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Shulker<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Shulker<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Shulker from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Shulker")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Shulker object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Shulker<'mc> {
    pub fn attached_face(
        &self,
    ) -> Result<crate::block::BlockFace<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/block/BlockFace;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getAttachedFace", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::BlockFace::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_attached_face(
        &self,
        arg0: impl Into<crate::block::BlockFace<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/block/BlockFace;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAttachedFace",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn peek(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getPeek", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the peek state of the shulker, should be in between 0.0 and 1.0.
    pub fn set_peek(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPeek",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn set_color(
        &self,
        arg0: impl Into<crate::DyeColor<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Shulker::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::material::Colorable = temp_clone.into();
        real.set_color(arg0)
    }
    pub fn color(&self) -> Result<Option<crate::DyeColor<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Shulker::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::material::Colorable = temp_clone.into();
        real.color()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Golem<'mc>> for Shulker<'mc> {
    fn into(self) -> crate::entity::Golem<'mc> {
        crate::entity::Golem::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Shulker into crate::entity::Golem")
    }
}
impl<'mc> Into<crate::material::Colorable<'mc>> for Shulker<'mc> {
    fn into(self) -> crate::material::Colorable<'mc> {
        crate::material::Colorable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Shulker into crate::material::Colorable")
    }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for Shulker<'mc> {
    fn into(self) -> crate::entity::Enemy<'mc> {
        crate::entity::Enemy::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Shulker into crate::entity::Enemy")
    }
}
pub enum Spell<'mc> {
    None { inner: SpellStruct<'mc> },
    SummonVex { inner: SpellStruct<'mc> },
    Fangs { inner: SpellStruct<'mc> },
    Wololo { inner: SpellStruct<'mc> },
    Disappear { inner: SpellStruct<'mc> },
    Blindness { inner: SpellStruct<'mc> },
}
impl<'mc> std::fmt::Display for Spell<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Spell::None { .. } => f.write_str("NONE"),
            Spell::SummonVex { .. } => f.write_str("SUMMON_VEX"),
            Spell::Fangs { .. } => f.write_str("FANGS"),
            Spell::Wololo { .. } => f.write_str("WOLOLO"),
            Spell::Disappear { .. } => f.write_str("DISAPPEAR"),
            Spell::Blindness { .. } => f.write_str("BLINDNESS"),
        }
    }
}

impl<'mc> Spell<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Spell<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Spell");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Spell;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NONE" => Ok(Spell::None {
                inner: SpellStruct::from_raw(env, obj)?,
            }),
            "SUMMON_VEX" => Ok(Spell::SummonVex {
                inner: SpellStruct::from_raw(env, obj)?,
            }),
            "FANGS" => Ok(Spell::Fangs {
                inner: SpellStruct::from_raw(env, obj)?,
            }),
            "WOLOLO" => Ok(Spell::Wololo {
                inner: SpellStruct::from_raw(env, obj)?,
            }),
            "DISAPPEAR" => Ok(Spell::Disappear {
                inner: SpellStruct::from_raw(env, obj)?,
            }),
            "BLINDNESS" => Ok(Spell::Blindness {
                inner: SpellStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct SpellStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Spell<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::None { inner } => inner.0.clone(),
            Self::SummonVex { inner } => inner.0.clone(),
            Self::Fangs { inner } => inner.0.clone(),
            Self::Wololo { inner } => inner.0.clone(),
            Self::Disappear { inner } => inner.0.clone(),
            Self::Blindness { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::SummonVex { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Fangs { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Wololo { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Disappear { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Blindness { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Spell<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Spell from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Spell")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Spell object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NONE" => Ok(Spell::None {
                    inner: SpellStruct::from_raw(env, obj)?,
                }),
                "SUMMON_VEX" => Ok(Spell::SummonVex {
                    inner: SpellStruct::from_raw(env, obj)?,
                }),
                "FANGS" => Ok(Spell::Fangs {
                    inner: SpellStruct::from_raw(env, obj)?,
                }),
                "WOLOLO" => Ok(Spell::Wololo {
                    inner: SpellStruct::from_raw(env, obj)?,
                }),
                "DISAPPEAR" => Ok(Spell::Disappear {
                    inner: SpellStruct::from_raw(env, obj)?,
                }),
                "BLINDNESS" => Ok(Spell::Blindness {
                    inner: SpellStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for SpellStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SpellStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SpellStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Spell")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SpellStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SpellStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a living entity, such as a monster or player
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct LivingEntity<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for LivingEntity<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for LivingEntity<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate LivingEntity from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LivingEntity")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a LivingEntity object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> LivingEntity<'mc> {
    pub fn maximum_no_damage_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaximumNoDamageTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the amount of arrows in the entity's body.
    pub fn set_arrows_in_body(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setArrowsInBody",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the height of the living entity's eyes above its Location.
    pub fn get_eye_height(&self, arg0: bool) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("(Z)D");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getEyeHeight",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }

    pub fn eye_location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getEyeLocation", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn get_line_of_sight(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<Vec<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/Set;I)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLineOfSight",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::block::Block::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }

    pub fn get_target_block(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/Set;I)Lorg/bukkit/block/Block;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTargetBlock",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Block::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn get_last_two_target_blocks(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaSet<'mc>>,
        arg1: i32,
    ) -> Result<Vec<crate::block::Block<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/Set;I)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLastTwoTargetBlocks",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::block::Block::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }

    pub fn get_target_block_exact_with_int(
        &self,
        arg0: i32,
        arg1: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>,
    ) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/FluidCollisionMode;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/block/Block;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTargetBlockExact",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Block::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn ray_trace_blocks_with_double(
        &self,
        arg0: f64,
        arg1: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>,
    ) -> Result<crate::util::RayTraceResult<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "D";
        let val_1 = jni::objects::JValueGen::Double(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/FluidCollisionMode;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/util/RayTraceResult;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "rayTraceBlocks", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::RayTraceResult::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn remaining_air(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getRemainingAir", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the amount of air that the living entity has remaining, in ticks.
    pub fn set_remaining_air(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRemainingAir",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn maximum_air(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaximumAir", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the maximum amount of air the living entity can have, in ticks.
    pub fn set_maximum_air(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaximumAir",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn arrow_cooldown(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getArrowCooldown",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the time in ticks until the next arrow leaves the entity's body.
    pub fn set_arrow_cooldown(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setArrowCooldown",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn arrows_in_body(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getArrowsInBody", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the living entity's current maximum no damage ticks.
    pub fn set_maximum_no_damage_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaximumNoDamageTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn last_damage(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLastDamage", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Sets the damage dealt within the current no damage ticks time period.
    pub fn set_last_damage(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLastDamage",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn no_damage_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNoDamageTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the living entity's current no damage ticks.
    pub fn set_no_damage_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setNoDamageTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn no_action_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNoActionTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the ticks that this entity has performed no action.
    /// <p>The details of what "no action ticks" entails varies from entity to entity and cannot be specifically defined. Some examples include squid using this value to determine when to swim, raiders for when they are to be expelled from raids, or creatures (such as withers) as a requirement to be despawned.</p>
    pub fn set_no_action_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setNoActionTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn killer(&self) -> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Player;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKiller", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Player::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn add_potion_effect_with_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffect<'mc>>,
        arg1: std::option::Option<bool>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/potion/PotionEffect;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Z";
            let val_2 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_2);
        }
        sig += ")Z";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "addPotionEffect", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn has_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasPotionEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn get_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<crate::potion::PotionEffect<'mc>, Box<dyn std::error::Error>> {
        let sig =
            String::from("(Lorg/bukkit/potion/PotionEffectType;)Lorg/bukkit/potion/PotionEffect;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPotionEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::potion::PotionEffect::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn remove_potion_effect(
        &self,
        arg0: impl Into<crate::potion::PotionEffectType<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/potion/PotionEffectType;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removePotionEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn active_potion_effects(
        &self,
    ) -> Result<Vec<crate::potion::PotionEffect<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getActivePotionEffects",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::potion::PotionEffect::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }

    pub fn has_line_of_sight(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "hasLineOfSight",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn remove_when_far_away(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getRemoveWhenFarAway",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether or not the living entity despawns when away from players or not.
    pub fn set_remove_when_far_away(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRemoveWhenFarAway",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn equipment(
        &self,
    ) -> Result<Option<crate::inventory::EntityEquipment<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/EntityEquipment;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getEquipment", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::inventory::EntityEquipment::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Sets whether or not the living entity can pick up items.
    pub fn set_can_pickup_items(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCanPickupItems",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn can_pickup_items(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCanPickupItems",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn is_leashed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isLeashed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn leash_holder(&self) -> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Entity;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLeashHolder", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::Entity::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_leash_holder(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLeashHolder",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn is_gliding(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isGliding", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Makes entity start or stop gliding. This will work even if an Elytra is not equipped, but will be reverted by the server immediately after unless an event-cancelling mechanism is put in place.
    pub fn set_gliding(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setGliding",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_swimming(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isSwimming", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Makes entity start or stop swimming. This may have unexpected results if the entity is not in water.
    pub fn set_swimming(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSwimming",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_riptiding(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isRiptiding", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn is_sleeping(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isSleeping", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn is_climbing(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isClimbing", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether an entity will have AI. The entity will be completely unable to move if it has no AI.
    pub fn set_ai(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAI",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn has_ai(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hasAI", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn attack(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "attack",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn swing_main_hand(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "swingMainHand", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn swing_off_hand(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "swingOffHand", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Makes this entity flash red as if they were damaged.
    pub fn play_hurt_animation(&self, arg0: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "playHurtAnimation",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Set if this entity will be subject to collisions with other entities.
    /// <p>Exemptions to this rule can be managed with <a href="#getCollidableExemptions()"><code>getCollidableExemptions()</code></a></p>
    pub fn set_collidable(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCollidable",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_collidable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isCollidable", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn collidable_exemptions(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCollidableExemptions",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn get_memory(
        &self,
        arg0: impl Into<crate::entity::memory::MemoryKey<'mc>>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/memory/MemoryKey;)Ljava/lang/Object;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMemory",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }

    pub fn hurt_sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getHurtSound", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn death_sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDeathSound", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Get the <a href="../Sound.html" title="enum in org.bukkit"><code>Sound</code></a> this entity will make when falling from the given height (in blocks). The sound will often differ between either a small or a big fall damage sound if the height exceeds 4 blocks.
    pub fn get_fall_damage_sound(
        &self,
        arg0: i32,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Lorg/bukkit/Sound;");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getFallDamageSound",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn fall_damage_sound_small(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getFallDamageSoundSmall",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn fall_damage_sound_big(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getFallDamageSoundBig",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn get_drinking_sound(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lorg/bukkit/Sound;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDrinkingSound",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn get_eating_sound(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Lorg/bukkit/Sound;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getEatingSound",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn can_breathe_underwater(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "canBreatheUnderwater",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn category(
        &self,
    ) -> Result<crate::entity::EntityCategory<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/EntityCategory;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getCategory", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::EntityCategory::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets whether the entity is invisible or not.
    pub fn set_invisible(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setInvisible",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_invisible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isInvisible", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn set_memory(
        &self,
        arg0: impl Into<crate::entity::memory::MemoryKey<'mc>>,
        arg1: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/memory/MemoryKey;Ljava/lang/Object;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(arg1);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMemory",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn get_attribute(
        &self,
        arg0: impl Into<crate::attribute::Attribute<'mc>>,
    ) -> Result<crate::attribute::AttributeInstance<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = LivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::attribute::Attributable = temp_clone.into();
        real.get_attribute(arg0)
    }
    pub fn damage_with_double(
        &self,
        arg0: f64,
        arg1: std::option::Option<impl Into<crate::entity::Entity<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "D";
        let val_1 = jni::objects::JValueGen::Double(arg0);
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/entity/Entity;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "damage", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn health(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = LivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.health()
    }
    pub fn set_health(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.set_health(arg0)
    }
    pub fn absorption_amount(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = LivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.absorption_amount()
    }
    pub fn set_absorption_amount(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.set_absorption_amount(arg0)
    }

    pub fn max_health(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let temp_clone = LivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.max_health()
    }

    pub fn set_max_health(&self, arg0: f64) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.set_max_health(arg0)
    }

    pub fn reset_max_health(&self) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = LivingEntity::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Damageable = temp_clone.into();
        real.reset_max_health()
    }
    pub fn launch_projectile_with_class(
        &self,
        arg0: jni::objects::JClass<'mc>,
        arg1: std::option::Option<impl Into<crate::util::Vector<'mc>>>,
    ) -> Result<crate::entity::Projectile<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/Class;";
        let val_1 = jni::objects::JValueGen::Object(arg0.into());
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Lorg/bukkit/util/Vector;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/entity/Projectile;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "launchProjectile", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::Projectile::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::attribute::Attributable<'mc>> for LivingEntity<'mc> {
    fn into(self) -> crate::attribute::Attributable<'mc> {
        crate::attribute::Attributable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting LivingEntity into crate::attribute::Attributable")
    }
}
impl<'mc> Into<crate::entity::Damageable<'mc>> for LivingEntity<'mc> {
    fn into(self) -> crate::entity::Damageable<'mc> {
        crate::entity::Damageable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting LivingEntity into crate::entity::Damageable")
    }
}
impl<'mc> Into<crate::projectiles::ProjectileSource<'mc>> for LivingEntity<'mc> {
    fn into(self) -> crate::projectiles::ProjectileSource<'mc> {
        crate::projectiles::ProjectileSource::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting LivingEntity into crate::projectiles::ProjectileSource")
    }
}
/// Represents the pickup status of this arrow.
pub enum AbstractArrowPickupStatus<'mc> {
    Disallowed {
        inner: AbstractArrowPickupStatusStruct<'mc>,
    },
    Allowed {
        inner: AbstractArrowPickupStatusStruct<'mc>,
    },
    CreativeOnly {
        inner: AbstractArrowPickupStatusStruct<'mc>,
    },
}
impl<'mc> std::fmt::Display for AbstractArrowPickupStatus<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AbstractArrowPickupStatus::Disallowed { .. } => f.write_str("DISALLOWED"),
            AbstractArrowPickupStatus::Allowed { .. } => f.write_str("ALLOWED"),
            AbstractArrowPickupStatus::CreativeOnly { .. } => f.write_str("CREATIVE_ONLY"),
        }
    }
}

impl<'mc> AbstractArrowPickupStatus<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<AbstractArrowPickupStatus<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/AbstractArrow$PickupStatus");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/AbstractArrow$PickupStatus;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "DISALLOWED" => Ok(AbstractArrowPickupStatus::Disallowed {
                inner: AbstractArrowPickupStatusStruct::from_raw(env, obj)?,
            }),
            "ALLOWED" => Ok(AbstractArrowPickupStatus::Allowed {
                inner: AbstractArrowPickupStatusStruct::from_raw(env, obj)?,
            }),
            "CREATIVE_ONLY" => Ok(AbstractArrowPickupStatus::CreativeOnly {
                inner: AbstractArrowPickupStatusStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct AbstractArrowPickupStatusStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for AbstractArrowPickupStatus<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Disallowed { inner } => inner.0.clone(),
            Self::Allowed { inner } => inner.0.clone(),
            Self::CreativeOnly { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Disallowed { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Allowed { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::CreativeOnly { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for AbstractArrowPickupStatus<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate AbstractArrowPickupStatus from null object."
            )
            .into());
        }
        let (valid, name) =
            env.validate_name(&obj, "org/bukkit/entity/AbstractArrow$PickupStatus")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a AbstractArrowPickupStatus object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "DISALLOWED" => Ok(AbstractArrowPickupStatus::Disallowed {
                    inner: AbstractArrowPickupStatusStruct::from_raw(env, obj)?,
                }),
                "ALLOWED" => Ok(AbstractArrowPickupStatus::Allowed {
                    inner: AbstractArrowPickupStatusStruct::from_raw(env, obj)?,
                }),
                "CREATIVE_ONLY" => Ok(AbstractArrowPickupStatus::CreativeOnly {
                    inner: AbstractArrowPickupStatusStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for AbstractArrowPickupStatusStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for AbstractArrowPickupStatusStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate AbstractArrowPickupStatusStruct from null object."
            )
            .into());
        }
        let (valid, name) =
            env.validate_name(&obj, "org/bukkit/entity/AbstractArrow$PickupStatus")?;
        if !valid {
            Err(eyre::eyre!(
                    "Invalid argument passed. Expected a AbstractArrowPickupStatusStruct object, got {}",
                    name
                )
                .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> AbstractArrowPickupStatusStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a Squid.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Squid<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Squid<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Squid<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Squid from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Squid")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Squid object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Squid<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::WaterMob<'mc>> for Squid<'mc> {
    fn into(self) -> crate::entity::WaterMob<'mc> {
        crate::entity::WaterMob::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Squid into crate::entity::WaterMob")
    }
}

#[repr(C)]
pub struct LightningStrikeSpigot<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for LightningStrikeSpigot<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for LightningStrikeSpigot<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate LightningStrikeSpigot from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LightningStrike$Spigot")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a LightningStrikeSpigot object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> LightningStrikeSpigot<'mc> {
    pub fn new(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::entity::LightningStrikeSpigot<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let cls = jni.find_class("org/bukkit/entity/LightningStrike$Spigot");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.new_object(cls, sig.as_str(), vec![]);
        let res = jni.translate_error_no_gen(res)?;
        crate::entity::LightningStrikeSpigot::from_raw(&jni, res)
    }

    pub fn is_silent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isSilent", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::EntitySpigot<'mc>> for LightningStrikeSpigot<'mc> {
    fn into(self) -> crate::entity::EntitySpigot<'mc> {
        crate::entity::EntitySpigot::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting LightningStrikeSpigot into crate::entity::EntitySpigot")
    }
}
/// Represents a MagmaCube.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct MagmaCube<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for MagmaCube<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for MagmaCube<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate MagmaCube from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/MagmaCube")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a MagmaCube object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> MagmaCube<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Slime<'mc>> for MagmaCube<'mc> {
    fn into(self) -> crate::entity::Slime<'mc> {
        crate::entity::Slime::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting MagmaCube into crate::entity::Slime")
    }
}
/// Represents a thrown egg.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Egg<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Egg<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Egg<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Egg from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Egg")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Egg object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Egg<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::ThrowableProjectile<'mc>> for Egg<'mc> {
    fn into(self) -> crate::entity::ThrowableProjectile<'mc> {
        crate::entity::ThrowableProjectile::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Egg into crate::entity::ThrowableProjectile")
    }
}
/// A Frog.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Frog<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Frog<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Frog<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Frog from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Frog")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Frog object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Frog<'mc> {
    pub fn variant(&self) -> Result<crate::entity::FrogVariant<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Frog$Variant;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getVariant", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::FrogVariant::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn tongue_target(
        &self,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Entity;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getTongueTarget", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Entity::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_tongue_target(
        &self,
        arg0: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTongueTarget",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn set_variant(
        &self,
        arg0: impl Into<crate::entity::FrogVariant<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Frog$Variant;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setVariant",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Frog::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Frog::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Frog::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Frog<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Frog into crate::entity::Animals")
    }
}
/// Represents the variant of a cow - ie its color.
pub enum MushroomCowVariant<'mc> {
    Red {
        inner: MushroomCowVariantStruct<'mc>,
    },
    Brown {
        inner: MushroomCowVariantStruct<'mc>,
    },
}
impl<'mc> std::fmt::Display for MushroomCowVariant<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MushroomCowVariant::Red { .. } => f.write_str("RED"),
            MushroomCowVariant::Brown { .. } => f.write_str("BROWN"),
        }
    }
}

impl<'mc> MushroomCowVariant<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<MushroomCowVariant<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/MushroomCow$Variant");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/MushroomCow$Variant;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "RED" => Ok(MushroomCowVariant::Red {
                inner: MushroomCowVariantStruct::from_raw(env, obj)?,
            }),
            "BROWN" => Ok(MushroomCowVariant::Brown {
                inner: MushroomCowVariantStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct MushroomCowVariantStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for MushroomCowVariant<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Red { inner } => inner.0.clone(),
            Self::Brown { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Red { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Brown { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for MushroomCowVariant<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate MushroomCowVariant from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/MushroomCow$Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a MushroomCowVariant object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "RED" => Ok(MushroomCowVariant::Red {
                    inner: MushroomCowVariantStruct::from_raw(env, obj)?,
                }),
                "BROWN" => Ok(MushroomCowVariant::Brown {
                    inner: MushroomCowVariantStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for MushroomCowVariantStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for MushroomCowVariantStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate MushroomCowVariantStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/MushroomCow$Variant")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a MushroomCowVariantStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> MushroomCowVariantStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents a sized fireball.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct SizedFireball<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SizedFireball<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SizedFireball<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SizedFireball from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/SizedFireball")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SizedFireball object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SizedFireball<'mc> {
    pub fn display_item(
        &self,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemStack;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDisplayItem", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_display_item(
        &self,
        arg0: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDisplayItem",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn direction(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = SizedFireball::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Fireball = temp_clone.into();
        real.direction()
    }
    pub fn set_direction(
        &self,
        arg0: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = SizedFireball::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Fireball = temp_clone.into();
        real.set_direction(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Fireball<'mc>> for SizedFireball<'mc> {
    fn into(self) -> crate::entity::Fireball<'mc> {
        crate::entity::Fireball::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting SizedFireball into crate::entity::Fireball")
    }
}
/// Represents a Sniffer.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Sniffer<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Sniffer<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Sniffer<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Sniffer from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Sniffer")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Sniffer object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Sniffer<'mc> {
    pub fn set_state(
        &self,
        arg0: impl Into<crate::entity::SnifferState<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Sniffer$State;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setState",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn find_possible_dig_location(
        &self,
    ) -> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "findPossibleDigLocation",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }

    pub fn explored_locations(
        &self,
    ) -> Result<Vec<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getExploredLocations",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::Location::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }

    pub fn remove_explored_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removeExploredLocation",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn add_explored_location(
        &self,
        arg0: impl Into<crate::Location<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "addExploredLocation",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn can_dig(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "canDig", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn state(&self) -> Result<crate::entity::SnifferState<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Sniffer$State;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getState", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::SnifferState::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Sniffer::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Sniffer::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Sniffer::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Sniffer<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Sniffer into crate::entity::Animals")
    }
}
/// A Glow Item Frame.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct GlowItemFrame<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for GlowItemFrame<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for GlowItemFrame<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate GlowItemFrame from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/GlowItemFrame")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a GlowItemFrame object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> GlowItemFrame<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::ItemFrame<'mc>> for GlowItemFrame<'mc> {
    fn into(self) -> crate::entity::ItemFrame<'mc> {
        crate::entity::ItemFrame::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting GlowItemFrame into crate::entity::ItemFrame")
    }
}
/// Represents a Painting.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Painting<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Painting<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Painting<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Painting from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Painting")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Painting object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Painting<'mc> {
    pub fn art(&self) -> Result<crate::Art<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Art;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getArt", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Art::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn set_art_with_art(
        &self,
        arg0: impl Into<crate::Art<'mc>>,
        arg1: std::option::Option<bool>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Art;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = arg1 {
            sig += "Z";
            let val_2 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_2);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "setArt", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn set_facing_direction(
        &self,
        arg0: impl Into<crate::block::BlockFace<'mc>>,
        arg1: bool,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Painting::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Hanging = temp_clone.into();
        real.set_facing_direction(arg0, arg1)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Hanging<'mc>> for Painting<'mc> {
    fn into(self) -> crate::entity::Hanging<'mc> {
        crate::entity::Hanging::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Painting into crate::entity::Hanging")
    }
}
/// Represents the current state of the Sniffer.
pub enum SnifferState<'mc> {
    Idling { inner: SnifferStateStruct<'mc> },
    FeelingHappy { inner: SnifferStateStruct<'mc> },
    Scenting { inner: SnifferStateStruct<'mc> },
    Sniffing { inner: SnifferStateStruct<'mc> },
    Searching { inner: SnifferStateStruct<'mc> },
    Digging { inner: SnifferStateStruct<'mc> },
    Rising { inner: SnifferStateStruct<'mc> },
}
impl<'mc> std::fmt::Display for SnifferState<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SnifferState::Idling { .. } => f.write_str("IDLING"),
            SnifferState::FeelingHappy { .. } => f.write_str("FEELING_HAPPY"),
            SnifferState::Scenting { .. } => f.write_str("SCENTING"),
            SnifferState::Sniffing { .. } => f.write_str("SNIFFING"),
            SnifferState::Searching { .. } => f.write_str("SEARCHING"),
            SnifferState::Digging { .. } => f.write_str("DIGGING"),
            SnifferState::Rising { .. } => f.write_str("RISING"),
        }
    }
}

impl<'mc> SnifferState<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<SnifferState<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/Sniffer$State");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/Sniffer$State;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "IDLING" => Ok(SnifferState::Idling {
                inner: SnifferStateStruct::from_raw(env, obj)?,
            }),
            "FEELING_HAPPY" => Ok(SnifferState::FeelingHappy {
                inner: SnifferStateStruct::from_raw(env, obj)?,
            }),
            "SCENTING" => Ok(SnifferState::Scenting {
                inner: SnifferStateStruct::from_raw(env, obj)?,
            }),
            "SNIFFING" => Ok(SnifferState::Sniffing {
                inner: SnifferStateStruct::from_raw(env, obj)?,
            }),
            "SEARCHING" => Ok(SnifferState::Searching {
                inner: SnifferStateStruct::from_raw(env, obj)?,
            }),
            "DIGGING" => Ok(SnifferState::Digging {
                inner: SnifferStateStruct::from_raw(env, obj)?,
            }),
            "RISING" => Ok(SnifferState::Rising {
                inner: SnifferStateStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct SnifferStateStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SnifferState<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Idling { inner } => inner.0.clone(),
            Self::FeelingHappy { inner } => inner.0.clone(),
            Self::Scenting { inner } => inner.0.clone(),
            Self::Sniffing { inner } => inner.0.clone(),
            Self::Searching { inner } => inner.0.clone(),
            Self::Digging { inner } => inner.0.clone(),
            Self::Rising { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Idling { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::FeelingHappy { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Scenting { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Sniffing { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Searching { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Digging { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Rising { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SnifferState<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SnifferState from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Sniffer$State")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SnifferState object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "IDLING" => Ok(SnifferState::Idling {
                    inner: SnifferStateStruct::from_raw(env, obj)?,
                }),
                "FEELING_HAPPY" => Ok(SnifferState::FeelingHappy {
                    inner: SnifferStateStruct::from_raw(env, obj)?,
                }),
                "SCENTING" => Ok(SnifferState::Scenting {
                    inner: SnifferStateStruct::from_raw(env, obj)?,
                }),
                "SNIFFING" => Ok(SnifferState::Sniffing {
                    inner: SnifferStateStruct::from_raw(env, obj)?,
                }),
                "SEARCHING" => Ok(SnifferState::Searching {
                    inner: SnifferStateStruct::from_raw(env, obj)?,
                }),
                "DIGGING" => Ok(SnifferState::Digging {
                    inner: SnifferStateStruct::from_raw(env, obj)?,
                }),
                "RISING" => Ok(SnifferState::Rising {
                    inner: SnifferStateStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for SnifferStateStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SnifferStateStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate SnifferStateStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Sniffer$State")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SnifferStateStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SnifferStateStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
/// Represents an Animal.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Animals<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Animals<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Animals<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Animals from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Animals")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Animals object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Animals<'mc> {
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/UUID;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBreedCause", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(blackboxmc_java::util::JavaUUID::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/UUID;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBreedCause",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isLoveMode", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the amount of ticks for which this entity should be in love mode. Setting the love mode ticks to 600 is the equivalent of a player feeding the entity their breeding item of choice.
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn set_age_lock(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Animals::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Breedable = temp_clone.into();
        real.set_age_lock(arg0)
    }

    pub fn age_lock(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Animals::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Breedable = temp_clone.into();
        real.age_lock()
    }

    pub fn can_breed(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Animals::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Breedable = temp_clone.into();
        real.can_breed()
    }

    pub fn set_breed(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Animals::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Breedable = temp_clone.into();
        real.set_breed(arg0)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Breedable<'mc>> for Animals<'mc> {
    fn into(self) -> crate::entity::Breedable<'mc> {
        crate::entity::Breedable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Animals into crate::entity::Breedable")
    }
}
/// Represents a Bat
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Bat<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Bat<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Bat<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Bat from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Bat")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Bat object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Bat<'mc> {
    pub fn is_awake(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isAwake", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// This method modifies the current waking state of this bat.
    /// <p>This does not prevent a bat from spontaneously awaking itself, or from reattaching itself to a block.</p>
    pub fn set_awake(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAwake",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Ambient<'mc>> for Bat<'mc> {
    fn into(self) -> crate::entity::Ambient<'mc> {
        crate::entity::Ambient::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Bat into crate::entity::Ambient")
    }
}
/// Represents Llama spit.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct LlamaSpit<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for LlamaSpit<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for LlamaSpit<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate LlamaSpit from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/LlamaSpit")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a LlamaSpit object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> LlamaSpit<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Projectile<'mc>> for LlamaSpit<'mc> {
    fn into(self) -> crate::entity::Projectile<'mc> {
        crate::entity::Projectile::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting LlamaSpit into crate::entity::Projectile")
    }
}
/// Represents a Ghast.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Ghast<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Ghast<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Ghast<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Ghast from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Ghast")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Ghast object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Ghast<'mc> {
    pub fn is_charging(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isCharging", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the Ghast is charging
    pub fn set_charging(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCharging",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Flying<'mc>> for Ghast<'mc> {
    fn into(self) -> crate::entity::Flying<'mc> {
        crate::entity::Flying::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Ghast into crate::entity::Flying")
    }
}
impl<'mc> Into<crate::entity::Enemy<'mc>> for Ghast<'mc> {
    fn into(self) -> crate::entity::Enemy<'mc> {
        crate::entity::Enemy::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Ghast into crate::entity::Enemy")
    }
}
/// Represents a Sheep.
///
/// This is a representation of an abstract class.
#[repr(C)]
pub struct Sheep<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Sheep<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Sheep<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Sheep from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/Sheep")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Sheep object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Sheep<'mc> {
    pub fn is_sheared(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isSheared", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn set_sheared(&self, arg0: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(arg0.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSheared",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn breed_cause(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaUUID<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Sheep::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.breed_cause()
    }
    pub fn set_breed_cause(
        &self,
        arg0: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Sheep::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.set_breed_cause(arg0)
    }
    pub fn is_love_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let temp_clone = Sheep::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::entity::Animals = temp_clone.into();
        real.is_love_mode()
    }
    pub fn love_mode_ticks(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLoveModeTicks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    pub fn set_love_mode_ticks(&self, arg0: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(arg0);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setLoveModeTicks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    pub fn is_breed_item_with_material(
        &self,
        arg0: impl Into<crate::Material<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(arg0.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBreedItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    pub fn set_color(
        &self,
        arg0: impl Into<crate::DyeColor<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let temp_clone = Sheep::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::material::Colorable = temp_clone.into();
        real.set_color(arg0)
    }
    pub fn color(&self) -> Result<Option<crate::DyeColor<'mc>>, Box<dyn std::error::Error>> {
        let temp_clone = Sheep::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::material::Colorable = temp_clone.into();
        real.color()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::entity::Animals<'mc>> for Sheep<'mc> {
    fn into(self) -> crate::entity::Animals<'mc> {
        crate::entity::Animals::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Sheep into crate::entity::Animals")
    }
}
impl<'mc> Into<crate::material::Colorable<'mc>> for Sheep<'mc> {
    fn into(self) -> crate::material::Colorable<'mc> {
        crate::material::Colorable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Sheep into crate::material::Colorable")
    }
}
/// Enumeration of all different fish patterns. Refer to the <a href="https://minecraft.gamepedia.com/Fish_(mob)">Minecraft Wiki</a> for pictures.
pub enum TropicalFishPattern<'mc> {
    Kob {
        inner: TropicalFishPatternStruct<'mc>,
    },
    Sunstreak {
        inner: TropicalFishPatternStruct<'mc>,
    },
    Snooper {
        inner: TropicalFishPatternStruct<'mc>,
    },
    Dasher {
        inner: TropicalFishPatternStruct<'mc>,
    },
    Brinely {
        inner: TropicalFishPatternStruct<'mc>,
    },
    Spotty {
        inner: TropicalFishPatternStruct<'mc>,
    },
    Flopper {
        inner: TropicalFishPatternStruct<'mc>,
    },
    Stripey {
        inner: TropicalFishPatternStruct<'mc>,
    },
    Glitter {
        inner: TropicalFishPatternStruct<'mc>,
    },
    Blockfish {
        inner: TropicalFishPatternStruct<'mc>,
    },
    Betty {
        inner: TropicalFishPatternStruct<'mc>,
    },
    Clayfish {
        inner: TropicalFishPatternStruct<'mc>,
    },
}
impl<'mc> std::fmt::Display for TropicalFishPattern<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TropicalFishPattern::Kob { .. } => f.write_str("KOB"),
            TropicalFishPattern::Sunstreak { .. } => f.write_str("SUNSTREAK"),
            TropicalFishPattern::Snooper { .. } => f.write_str("SNOOPER"),
            TropicalFishPattern::Dasher { .. } => f.write_str("DASHER"),
            TropicalFishPattern::Brinely { .. } => f.write_str("BRINELY"),
            TropicalFishPattern::Spotty { .. } => f.write_str("SPOTTY"),
            TropicalFishPattern::Flopper { .. } => f.write_str("FLOPPER"),
            TropicalFishPattern::Stripey { .. } => f.write_str("STRIPEY"),
            TropicalFishPattern::Glitter { .. } => f.write_str("GLITTER"),
            TropicalFishPattern::Blockfish { .. } => f.write_str("BLOCKFISH"),
            TropicalFishPattern::Betty { .. } => f.write_str("BETTY"),
            TropicalFishPattern::Clayfish { .. } => f.write_str("CLAYFISH"),
        }
    }
}

impl<'mc> TropicalFishPattern<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<TropicalFishPattern<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/TropicalFish$Pattern");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/TropicalFish$Pattern;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "KOB" => Ok(TropicalFishPattern::Kob {
                inner: TropicalFishPatternStruct::from_raw(env, obj)?,
            }),
            "SUNSTREAK" => Ok(TropicalFishPattern::Sunstreak {
                inner: TropicalFishPatternStruct::from_raw(env, obj)?,
            }),
            "SNOOPER" => Ok(TropicalFishPattern::Snooper {
                inner: TropicalFishPatternStruct::from_raw(env, obj)?,
            }),
            "DASHER" => Ok(TropicalFishPattern::Dasher {
                inner: TropicalFishPatternStruct::from_raw(env, obj)?,
            }),
            "BRINELY" => Ok(TropicalFishPattern::Brinely {
                inner: TropicalFishPatternStruct::from_raw(env, obj)?,
            }),
            "SPOTTY" => Ok(TropicalFishPattern::Spotty {
                inner: TropicalFishPatternStruct::from_raw(env, obj)?,
            }),
            "FLOPPER" => Ok(TropicalFishPattern::Flopper {
                inner: TropicalFishPatternStruct::from_raw(env, obj)?,
            }),
            "STRIPEY" => Ok(TropicalFishPattern::Stripey {
                inner: TropicalFishPatternStruct::from_raw(env, obj)?,
            }),
            "GLITTER" => Ok(TropicalFishPattern::Glitter {
                inner: TropicalFishPatternStruct::from_raw(env, obj)?,
            }),
            "BLOCKFISH" => Ok(TropicalFishPattern::Blockfish {
                inner: TropicalFishPatternStruct::from_raw(env, obj)?,
            }),
            "BETTY" => Ok(TropicalFishPattern::Betty {
                inner: TropicalFishPatternStruct::from_raw(env, obj)?,
            }),
            "CLAYFISH" => Ok(TropicalFishPattern::Clayfish {
                inner: TropicalFishPatternStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct TropicalFishPatternStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for TropicalFishPattern<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::Kob { inner } => inner.0.clone(),
            Self::Sunstreak { inner } => inner.0.clone(),
            Self::Snooper { inner } => inner.0.clone(),
            Self::Dasher { inner } => inner.0.clone(),
            Self::Brinely { inner } => inner.0.clone(),
            Self::Spotty { inner } => inner.0.clone(),
            Self::Flopper { inner } => inner.0.clone(),
            Self::Stripey { inner } => inner.0.clone(),
            Self::Glitter { inner } => inner.0.clone(),
            Self::Blockfish { inner } => inner.0.clone(),
            Self::Betty { inner } => inner.0.clone(),
            Self::Clayfish { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::Kob { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Sunstreak { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Snooper { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Dasher { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Brinely { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Spotty { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Flopper { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Stripey { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Glitter { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Blockfish { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Betty { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Clayfish { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TropicalFishPattern<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate TropicalFishPattern from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TropicalFish$Pattern")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TropicalFishPattern object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "KOB" => Ok(TropicalFishPattern::Kob {
                    inner: TropicalFishPatternStruct::from_raw(env, obj)?,
                }),
                "SUNSTREAK" => Ok(TropicalFishPattern::Sunstreak {
                    inner: TropicalFishPatternStruct::from_raw(env, obj)?,
                }),
                "SNOOPER" => Ok(TropicalFishPattern::Snooper {
                    inner: TropicalFishPatternStruct::from_raw(env, obj)?,
                }),
                "DASHER" => Ok(TropicalFishPattern::Dasher {
                    inner: TropicalFishPatternStruct::from_raw(env, obj)?,
                }),
                "BRINELY" => Ok(TropicalFishPattern::Brinely {
                    inner: TropicalFishPatternStruct::from_raw(env, obj)?,
                }),
                "SPOTTY" => Ok(TropicalFishPattern::Spotty {
                    inner: TropicalFishPatternStruct::from_raw(env, obj)?,
                }),
                "FLOPPER" => Ok(TropicalFishPattern::Flopper {
                    inner: TropicalFishPatternStruct::from_raw(env, obj)?,
                }),
                "STRIPEY" => Ok(TropicalFishPattern::Stripey {
                    inner: TropicalFishPatternStruct::from_raw(env, obj)?,
                }),
                "GLITTER" => Ok(TropicalFishPattern::Glitter {
                    inner: TropicalFishPatternStruct::from_raw(env, obj)?,
                }),
                "BLOCKFISH" => Ok(TropicalFishPattern::Blockfish {
                    inner: TropicalFishPatternStruct::from_raw(env, obj)?,
                }),
                "BETTY" => Ok(TropicalFishPattern::Betty {
                    inner: TropicalFishPatternStruct::from_raw(env, obj)?,
                }),
                "CLAYFISH" => Ok(TropicalFishPattern::Clayfish {
                    inner: TropicalFishPatternStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for TropicalFishPatternStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TropicalFishPatternStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate TropicalFishPatternStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/TropicalFish$Pattern")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TropicalFishPatternStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> TropicalFishPatternStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum EntityCategory<'mc> {
    None { inner: EntityCategoryStruct<'mc> },
    Undead { inner: EntityCategoryStruct<'mc> },
    Arthropod { inner: EntityCategoryStruct<'mc> },
    Illager { inner: EntityCategoryStruct<'mc> },
    Water { inner: EntityCategoryStruct<'mc> },
}
impl<'mc> std::fmt::Display for EntityCategory<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EntityCategory::None { .. } => f.write_str("NONE"),
            EntityCategory::Undead { .. } => f.write_str("UNDEAD"),
            EntityCategory::Arthropod { .. } => f.write_str("ARTHROPOD"),
            EntityCategory::Illager { .. } => f.write_str("ILLAGER"),
            EntityCategory::Water { .. } => f.write_str("WATER"),
        }
    }
}

impl<'mc> EntityCategory<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<EntityCategory<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/entity/EntityCategory");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/entity/EntityCategory;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "NONE" => Ok(EntityCategory::None {
                inner: EntityCategoryStruct::from_raw(env, obj)?,
            }),
            "UNDEAD" => Ok(EntityCategory::Undead {
                inner: EntityCategoryStruct::from_raw(env, obj)?,
            }),
            "ARTHROPOD" => Ok(EntityCategory::Arthropod {
                inner: EntityCategoryStruct::from_raw(env, obj)?,
            }),
            "ILLAGER" => Ok(EntityCategory::Illager {
                inner: EntityCategoryStruct::from_raw(env, obj)?,
            }),
            "WATER" => Ok(EntityCategory::Water {
                inner: EntityCategoryStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct EntityCategoryStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EntityCategory<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::None { inner } => inner.0.clone(),
            Self::Undead { inner } => inner.0.clone(),
            Self::Arthropod { inner } => inner.0.clone(),
            Self::Illager { inner } => inner.0.clone(),
            Self::Water { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::None { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Undead { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Arthropod { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Illager { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Water { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EntityCategory<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate EntityCategory from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EntityCategory")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EntityCategory object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "NONE" => Ok(EntityCategory::None {
                    inner: EntityCategoryStruct::from_raw(env, obj)?,
                }),
                "UNDEAD" => Ok(EntityCategory::Undead {
                    inner: EntityCategoryStruct::from_raw(env, obj)?,
                }),
                "ARTHROPOD" => Ok(EntityCategory::Arthropod {
                    inner: EntityCategoryStruct::from_raw(env, obj)?,
                }),
                "ILLAGER" => Ok(EntityCategory::Illager {
                    inner: EntityCategoryStruct::from_raw(env, obj)?,
                }),
                "WATER" => Ok(EntityCategory::Water {
                    inner: EntityCategoryStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for EntityCategoryStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EntityCategoryStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate EntityCategoryStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/entity/EntityCategory")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EntityCategoryStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EntityCategoryStruct<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub mod memory;
pub mod minecart;
