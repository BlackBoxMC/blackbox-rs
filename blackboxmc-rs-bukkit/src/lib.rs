#![allow(deprecated)]
use blackboxmc_general::JNIInstantiatable;
use blackboxmc_general::JNIRaw;
use color_eyre::eyre::Result;
pub enum Art<'mc> {}
impl<'mc> std::fmt::Display for Art<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> Art<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Art<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Art");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Art;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct ArtStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Art<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for Art<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Art from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Art")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Art object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for ArtStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ArtStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ArtStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Art")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ArtStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ArtStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::Art<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Art;");
        let cls = jni.find_class("org/bukkit/Art");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Art::from_raw(&jni, obj)
    }
    /// Gets the width of the painting, in blocks
    pub fn block_width(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBlockWidth", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the height of the painting, in blocks
    pub fn block_height(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBlockHeight", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Get the ID of this painting.
    pub fn id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getId", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    #[deprecated]
    /// Get a painting by its numeric ID
    pub fn get_by_id(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        id: i32,
    ) -> Result<Option<crate::Art<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Lorg/bukkit/Art;");
        let val_1 = jni::objects::JValueGen::Int(id);
        let cls = jni.find_class("org/bukkit/Art");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getById",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::Art::from_raw(&jni, obj)?))
    }
    /// Get a painting by its unique name
    ///
    /// This ignores underscores and capitalization
    pub fn get_by_name(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        name: impl Into<String>,
    ) -> Result<Option<crate::Art<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/Art;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(name.into())?,
        ));
        let cls = jni.find_class("org/bukkit/Art");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByName",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::Art::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct MinecraftExperimental<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for MinecraftExperimental<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for MinecraftExperimental<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate MinecraftExperimental from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/MinecraftExperimental")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a MinecraftExperimental object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> MinecraftExperimental<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum MinecraftExperimentalRequires<'mc> {}
impl<'mc> std::fmt::Display for MinecraftExperimentalRequires<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> MinecraftExperimentalRequires<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<MinecraftExperimentalRequires<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/MinecraftExperimental/Requires");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/MinecraftExperimental/Requires;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct MinecraftExperimentalRequiresStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for MinecraftExperimentalRequires<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for MinecraftExperimentalRequires<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate MinecraftExperimentalRequires from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/MinecraftExperimental/Requires")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a MinecraftExperimentalRequires object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for MinecraftExperimentalRequiresStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for MinecraftExperimentalRequiresStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate MinecraftExperimentalRequiresStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/MinecraftExperimental/Requires")?;
        if !valid {
            Err(eyre::eyre!(
                    "Invalid argument passed. Expected a MinecraftExperimentalRequiresStruct object, got {}",
                    name
                )
                .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> MinecraftExperimentalRequiresStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::MinecraftExperimentalRequires<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/MinecraftExperimental/Requires;");
        let cls = jni.find_class("org/bukkit/MinecraftExperimental/Requires");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::MinecraftExperimentalRequires::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum Material<'mc> {
    LegacyPrefix { inner: MaterialStruct<'mc> },
    Data { inner: MaterialStruct<'mc> },
}
impl<'mc> std::fmt::Display for Material<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Material::LegacyPrefix { .. } => f.write_str("LEGACY_PREFIX"),
            Material::Data { .. } => f.write_str("data"),
        }
    }
}

impl<'mc> Material<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Material<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Material");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Material;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "LEGACY_PREFIX" => Ok(Material::LegacyPrefix {
                inner: MaterialStruct::from_raw(env, obj)?,
            }),
            "data" => Ok(Material::Data {
                inner: MaterialStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct MaterialStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Material<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::LegacyPrefix { inner } => inner.0.clone(),
            Self::Data { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::LegacyPrefix { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Data { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Material<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Material from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Material")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Material object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "LEGACY_PREFIX" => Ok(Material::LegacyPrefix {
                    inner: MaterialStruct::from_raw(env, obj)?,
                }),
                "data" => Ok(Material::Data {
                    inner: MaterialStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for MaterialStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for MaterialStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate MaterialStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Material")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a MaterialStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> MaterialStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::Material<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Material;");
        let cls = jni.find_class("org/bukkit/Material");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Material::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Do not use for any reason.
    pub fn id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getId", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Do not use for any reason.
    pub fn is_legacy(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isLegacy", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the maximum amount of this material that can be held in a stack.
    ///
    /// Note that this is the <strong>default</strong> maximum size for this Material.
    /// {@link ItemStack ItemStacks} are able to change their maximum stack size per
    /// stack with {@link ItemMeta#setMaxStackSize(Integer)}. If an ItemStack instance
    /// is available, {@link ItemStack#getMaxStackSize()} may be preferred.
    pub fn max_stack_size(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxStackSize", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the maximum durability of this material
    pub fn max_durability(&self) -> Result<i16, Box<dyn std::error::Error>> {
        let sig = String::from("()S");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxDurability",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.s()?)
    }
    /// Creates a new {@link BlockData} instance for this Material, with all
    /// properties initialized to unspecified defaults, except for those provided
    /// in data.
    pub fn create_block_data(
        &self,
        data: std::option::Option<impl Into<String>>,
    ) -> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = data {
            sig += "Ljava/lang/String;";
            let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                self.jni_ref().new_string(a.into())?,
            ));
            args.push(val_1);
        }
        sig += ")Lorg/bukkit/block/data/BlockData;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "createBlockData", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::data::BlockData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the MaterialData class associated with this Material
    pub fn data(&self) -> Result<jni::objects::JClass<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/Class;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getData", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(unsafe { jni::objects::JClass::from_raw(res.as_jni().l) })
    }
    #[deprecated]
    /// Constructs a new MaterialData relevant for this Material, with the given initial data
    pub fn get_new_data(
        &self,
        raw: i8,
    ) -> Result<crate::material::MaterialData<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(B)Lorg/bukkit/material/MaterialData;");
        let val_1 = jni::objects::JValueGen::Byte(raw);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getNewData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::material::MaterialData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Checks if this Material is a placable block
    pub fn is_block(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBlock", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks if this Material is edible.
    pub fn is_edible(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isEdible", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Attempts to get the Material with the given name.
    ///
    /// This is a normal lookup, names must be the precise name they are given in
    /// the enum (but optionally including the LEGACY_PREFIX if legacyName is
    /// true).
    ///
    /// If legacyName is true, then the lookup will be against legacy materials,
    /// but the returned Material will be a modern material (ie this method is
    /// useful for updating stored data).
    pub fn get_material(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        name: impl Into<String>,
        legacy_name: std::option::Option<bool>,
    ) -> Result<Option<crate::Material<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(name.into())?,
        ));
        args.push(val_1);
        if let Some(a) = legacy_name {
            sig += "Z";
            let val_2 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/Material;";
        let cls = jni.find_class("org/bukkit/Material");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getMaterial", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::Material::from_raw(&jni, obj)?))
    }
    /// Attempts to match the Material with the given name.
    ///
    /// This is a match lookup; names will be stripped of the "minecraft:"
    /// namespace, converted to uppercase, then stripped of special characters in
    /// an attempt to format it like the enum.
    pub fn match_material(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        name: impl Into<String>,
        legacy_name: std::option::Option<bool>,
    ) -> Result<Option<crate::Material<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(name.into())?,
        ));
        args.push(val_1);
        if let Some(a) = legacy_name {
            sig += "Z";
            let val_2 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/Material;";
        let cls = jni.find_class("org/bukkit/Material");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "matchMaterial", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::Material::from_raw(&jni, obj)?))
    }

    pub fn is_record(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isRecord", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Check if the material is a block and solid (can be built upon)
    pub fn is_solid(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isSolid", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Check if the material is an air block.
    pub fn is_air(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isAir", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]
    /// Check if the material is a block and does not block any light
    pub fn is_transparent(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isTransparent", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Check if the material is a block and can catch fire
    pub fn is_flammable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isFlammable", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Check if the material is a block and can burn away
    pub fn is_burnable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isBurnable", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks if this Material can be used as fuel in a Furnace
    pub fn is_fuel(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isFuel", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Check if the material is a block and occludes light in the lighting engine.
    ///
    /// Generally speaking, most full blocks will occlude light. Non-full blocks are
    /// not occluding (e.g. anvils, chests, tall grass, stairs, etc.), nor are specific
    /// full blocks such as barriers or spawners which block light despite their texture.
    ///
    /// An occluding block will have the following effects:
    /// <ul>
    /// <li>Chests cannot be opened if an occluding block is above it.
    /// <li>Mobs cannot spawn inside of occluding blocks.
    /// <li>Only occluding blocks can be "powered" ({@link Block#isBlockPowered()}).
    /// </ul>
    /// This list may be inconclusive. For a full list of the side effects of an occluding
    /// block, see the <a href="https://minecraft.wiki/w/Opacity">Minecraft Wiki</a>.
    pub fn is_occluding(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isOccluding", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn has_gravity(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "hasGravity", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks if this Material is an obtainable item.
    pub fn is_item(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isItem", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks if this Material can be interacted with.
    /// Interactable materials include those with functionality when they are
    /// interacted with by a player such as chests, furnaces, etc.
    /// Some blocks such as piston heads and stairs are considered interactable
    /// though may not perform any additional functionality.
    /// Note that the interactability of some materials may be dependant on their
    /// state as well. This method will return true if there is at least one
    /// state in which additional interact handling is performed for the
    /// material.
    pub fn is_interactable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isInteractable", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Obtains the block's hardness level (also known as "strength").
    ///
    /// This number is used to calculate the time required to break each block.
    ///
    /// Only available when {@link #isBlock()} is true.
    pub fn hardness(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getHardness", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Obtains the blast resistance value (also known as block "durability").
    ///
    /// This value is used in explosions to calculate whether a block should be
    /// broken or not.
    ///
    /// Only available when {@link #isBlock()} is true.
    pub fn blast_resistance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBlastResistance",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Returns a value that represents how 'slippery' the block is.
    /// Blocks with higher slipperiness, like {@link Material#ICE} can be slid on
    /// further by the player and other entities.
    /// Most blocks have a default slipperiness of {@code 0.6f}.
    /// Only available when {@link #isBlock()} is true.
    pub fn slipperiness(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getSlipperiness", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Determines the remaining item in a crafting grid after crafting with this
    /// ingredient.
    ///
    /// Only available when {@link #isItem()} is true.
    pub fn crafting_remaining_item(
        &self,
    ) -> Result<Option<crate::Material<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Material;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCraftingRemainingItem",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Material::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Get the best suitable slot for this Material.
    /// For most items this will be {@link EquipmentSlot#HAND}.
    pub fn equipment_slot(
        &self,
    ) -> Result<crate::inventory::EquipmentSlot<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/EquipmentSlot;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getEquipmentSlot",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::EquipmentSlot::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Return an immutable copy of all default {@link Attribute}s and their
    /// {@link AttributeModifier}s for a given {@link EquipmentSlot}.
    /// Default attributes are those that are always preset on some items, such
    /// as the attack damage on weapons or the armor value on armor.
    /// Only available when {@link #isItem()} is true.
    pub fn get_default_attribute_modifiers(
        &self,
        slot: impl Into<crate::inventory::EquipmentSlot<'mc>>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from(
            "(Lorg/bukkit/inventory/EquipmentSlot;)Lcom/google/common/collect/Multimap;",
        );
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(slot.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDefaultAttributeModifiers",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }
    /// Get the {@link CreativeCategory} to which this material belongs.
    pub fn creative_category(
        &self,
    ) -> Result<Option<crate::inventory::CreativeCategory<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/CreativeCategory;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCreativeCategory",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::inventory::CreativeCategory::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Get the translation key of the item or block associated with this
    /// material.
    /// If this material has both an item and a block form, the item form is
    /// used.
    pub fn translation_key(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTranslationKey",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Get the translation key of the block associated with this material, or
    /// null if this material does not have an associated block.
    pub fn block_translation_key(&self) -> Result<Option<String>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBlockTranslationKey",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(
            self.jni_ref()
                .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
                .to_string_lossy()
                .to_string(),
        ))
    }
    /// Get the translation key of the item associated with this material, or
    /// null if this material does not have an associated item.
    pub fn item_translation_key(&self) -> Result<Option<String>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getItemTranslationKey",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(
            self.jni_ref()
                .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
                .to_string_lossy()
                .to_string(),
        ))
    }
    /// Gets if the Material is enabled by the features in a world.
    pub fn is_enabled_by_feature(
        &self,
        world: impl Into<crate::World<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/World;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isEnabledByFeature",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks whether this material is compostable (can be inserted into a
    /// composter).
    pub fn is_compostable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isCompostable", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Get the chance that this material will successfully compost. The returned
    /// value is between 0 and 1 (inclusive).
    /// Materials with a compost chance of 1 will always raise the composter's
    /// level, while materials with a compost chance of 0 will never raise it.
    /// Plugins should check that {@link #isCompostable} returns true before
    /// calling this method.
    pub fn compost_chance(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCompostChance",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Tries to convert this Material to an item type
    pub fn as_item_type(
        &self,
    ) -> Result<Option<crate::inventory::ItemType<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemType;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "asItemType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::inventory::ItemType::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Tries to convert this Material to a block type
    pub fn as_block_type(
        &self,
    ) -> Result<Option<crate::block::BlockType<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/block/BlockType;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "asBlockType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::block::BlockType::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct FeatureFlag<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for FeatureFlag<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FeatureFlag<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate FeatureFlag from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/FeatureFlag")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FeatureFlag object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> FeatureFlag<'mc> {
    /// Return the namespaced identifier for this object.
    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::Keyed<'mc>> for FeatureFlag<'mc> {
    fn into(self) -> crate::Keyed<'mc> {
        crate::Keyed::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting FeatureFlag into crate::Keyed")
    }
}
#[repr(C)]
pub struct Registry<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Registry<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Registry<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Registry from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Registry")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Registry object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Registry<'mc> {
    /// Get the object by its key.
    pub fn get(
        &self,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)LT;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "get",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(res.l()?))
    }
    /// Attempts to match the registered object with the given key.
    ///
    /// This will attempt to find a reasonable match based on the provided input
    /// and may do so through unspecified means.
    pub fn get_match(
        &self,
        input: impl Into<String>,
    ) -> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)LT;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(input.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "match",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(res.l()?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct RegistrySimpleRegistry<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for RegistrySimpleRegistry<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for RegistrySimpleRegistry<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate RegistrySimpleRegistry from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Registry/SimpleRegistry")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a RegistrySimpleRegistry object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> RegistrySimpleRegistry<'mc> {
    pub fn get(
        &self,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)LT;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "get",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(res.l()?))
    }

    pub fn iterator(
        &self,
    ) -> Result<blackboxmc_java::util::JavaIterator<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Iterator;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "iterator", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaIterator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    #[deprecated]

    pub fn get_type(&self) -> Result<jni::objects::JClass<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/Class;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(unsafe { jni::objects::JClass::from_raw(res.as_jni().l) })
    }
    /// Attempts to match the registered object with the given key.
    ///
    /// This will attempt to find a reasonable match based on the provided input
    /// and may do so through unspecified means.
    pub fn get_match(
        &self,
        input: impl Into<String>,
    ) -> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)LT;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(input.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "match",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(res.l()?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::Registry<'mc>> for RegistrySimpleRegistry<'mc> {
    fn into(self) -> crate::Registry<'mc> {
        crate::Registry::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting RegistrySimpleRegistry into crate::Registry")
    }
}
#[repr(C)]
pub struct ServerTickManager<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ServerTickManager<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ServerTickManager<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ServerTickManager from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/ServerTickManager")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ServerTickManager object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ServerTickManager<'mc> {
    /// Checks if the server is running normally.
    ///
    /// When the server is running normally it indicates that the server is not
    /// currently frozen.
    pub fn is_running_normally(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isRunningNormally",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks if the server is currently stepping.
    pub fn is_stepping(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isStepping", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks if the server is currently sprinting.
    pub fn is_sprinting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isSprinting", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks if a given entity is frozen.
    pub fn is_frozen(
        &self,
        entity: std::option::Option<impl Into<crate::entity::Entity<'mc>>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = entity {
            sig += "Lorg/bukkit/entity/Entity;";
            let val_1 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_1);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isFrozen", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the current tick rate of the server.
    pub fn tick_rate(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getTickRate", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the tick rate of the server.
    ///
    /// The normal tick rate of the server is 20. No tick rate below 1.0F or
    /// above 10,000 can be applied to the server.
    pub fn set_tick_rate(&self, tick: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(tick);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTickRate",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets the server to a frozen state that does not tick most things.
    pub fn set_frozen(&self, frozen: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(frozen.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFrozen",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Steps the game a certain amount of ticks if the server is currently
    /// frozen.
    ///
    /// Steps occur when the server is in a frozen state which can be started by
    /// either using the in game /tick freeze command or the
    /// {@link #setFrozen(boolean)} method.
    pub fn step_game_if_frozen(&self, ticks: i32) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Z");
        let val_1 = jni::objects::JValueGen::Int(ticks);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "stepGameIfFrozen",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Stops the current stepping if stepping is occurring.
    pub fn stop_stepping(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "stopStepping", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Attempts to initiate a sprint, which executes all server ticks at a
    /// faster rate then normal.
    pub fn request_game_to_sprint(&self, ticks: i32) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Z");
        let val_1 = jni::objects::JValueGen::Int(ticks);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "requestGameToSprint",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Stops the current sprint if one is currently happening.
    pub fn stop_sprinting(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "stopSprinting", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the amount of frozen ticks left to run.
    pub fn frozen_ticks_to_run(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getFrozenTicksToRun",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum Particle<'mc> {}
impl<'mc> std::fmt::Display for Particle<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> Particle<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Particle<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Particle");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Particle;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct ParticleStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Particle<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for Particle<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Particle from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Particle")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Particle object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for ParticleStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ParticleStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ParticleStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Particle")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ParticleStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ParticleStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::Particle<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Particle;");
        let cls = jni.find_class("org/bukkit/Particle");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Particle::from_raw(&jni, obj)
    }

    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct ParticleDustOptions<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ParticleDustOptions<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ParticleDustOptions<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ParticleDustOptions from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Particle/DustOptions")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ParticleDustOptions object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ParticleDustOptions<'mc> {
    pub fn new(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        color: impl Into<crate::Color<'mc>>,
        size: f32,
    ) -> Result<crate::ParticleDustOptions<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Color;F)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(color.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Float(size);
        let cls = jni.find_class("org/bukkit/Particle/DustOptions");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.new_object(
            cls,
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = jni.translate_error_no_gen(res)?;
        crate::ParticleDustOptions::from_raw(&jni, res)
    }
    /// The color of the particles to be displayed.
    pub fn color(&self) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Color;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getColor", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Relative size of the particle.
    pub fn size(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getSize", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct ParticleDustTransition<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ParticleDustTransition<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ParticleDustTransition<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate ParticleDustTransition from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Particle/DustTransition")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ParticleDustTransition object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ParticleDustTransition<'mc> {
    pub fn new(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        from_color: impl Into<crate::Color<'mc>>,
        to_color: impl Into<crate::Color<'mc>>,
        size: f32,
    ) -> Result<crate::ParticleDustTransition<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Color;Lorg/bukkit/Color;F)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(from_color.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(to_color.into().jni_object().clone())
        });
        let val_3 = jni::objects::JValueGen::Float(size);
        let cls = jni.find_class("org/bukkit/Particle/DustTransition");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.new_object(
            cls,
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = jni.translate_error_no_gen(res)?;
        crate::ParticleDustTransition::from_raw(&jni, res)
    }
    /// The final of the particles to be displayed.
    pub fn to_color(&self) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Color;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getToColor", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    // SUPER CLASS: org.bukkit.Particle.DustOptions ( ['getToColor'])
    /// The color of the particles to be displayed.
    pub fn color(&self) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let temp_clone = crate::ParticleDustOptions::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::ParticleDustOptions = temp_clone.into();
        real.color()
    }
    /// Relative size of the particle.
    pub fn size(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let temp_clone = crate::ParticleDustOptions::from_raw(&self.0, unsafe {
            jni::objects::JObject::from_raw(self.1.clone())
        })?;
        let real: crate::ParticleDustOptions = temp_clone.into();
        real.size()
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::ParticleDustOptions<'mc>> for ParticleDustTransition<'mc> {
    fn into(self) -> crate::ParticleDustOptions<'mc> {
        crate::ParticleDustOptions::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting ParticleDustTransition into crate::ParticleDustOptions")
    }
}
#[repr(C)]
pub struct Server<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Server<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Server<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Server from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Server")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Server object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Server<'mc> {
    /// Gets the name of this server implementation.
    pub fn name(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getName", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets the version string of this server implementation.
    pub fn version(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getVersion", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets the Bukkit version that this server is running.
    pub fn bukkit_version(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBukkitVersion",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets a view of all currently logged in players. This {@linkplain
    /// Collections#unmodifiableCollection(Collection) view} is a reused
    /// object, making some operations like {@link Collection#size()}
    /// zero-allocation.
    ///
    /// The collection is a view backed by the internal representation, such
    /// that, changes to the internal state of the server will be reflected
    /// immediately. However, the reuse of the returned collection (identity)
    /// is not strictly guaranteed for future or all implementations. Casting
    /// the collection, or relying on interface implementations (like {@link
    /// Serializable} or {@link List}), is deprecated.
    ///
    /// Iteration behavior is undefined outside of self-contained main-thread
    /// uses. Normal and immediate iterator use without consequences that
    /// affect the collection are fully supported. The effects following
    /// (non-exhaustive) {@link Entity#teleport(Location) teleportation},
    /// {@link Player#setHealth(double) death}, and {@link Player#kickPlayer(
    /// String) kicking} are undefined. Any use of this collection from
    /// asynchronous threads is unsafe.
    ///
    /// For safe consequential iteration or mimicking the old array behavior,
    /// using {@link Collection#toArray(Object[])} is recommended. For making
    /// snapshots, {@link ImmutableList#copyOf(Collection)} is recommended.
    pub fn online_players(
        &self,
    ) -> Result<Vec<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getOnlinePlayers",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Player::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Get the maximum amount of players which can login to this server.
    pub fn max_players(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxPlayers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the maximum amount of players allowed to be logged in at once.
    pub fn set_max_players(&self, max_players: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(max_players);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMaxPlayers",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Get the game port that the server runs on.
    pub fn port(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getPort", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Get the view distance from this server.
    pub fn view_distance(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getViewDistance", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Get the simulation distance from this server.
    pub fn simulation_distance(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getSimulationDistance",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Get the IP that this server is bound to, or empty string if not
    /// specified.
    pub fn ip(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getIp", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Get world type (level-type setting) for default world.
    pub fn world_type(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getWorldType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Get generate-structures setting.
    pub fn generate_structures(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getGenerateStructures",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Get max world size.
    pub fn max_world_size(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxWorldSize", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets whether this server allows the End or not.
    pub fn allow_end(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getAllowEnd", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether this server allows the Nether or not.
    pub fn allow_nether(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getAllowNether", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether the server is logging the IP addresses of players.
    pub fn is_logging_ips(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isLoggingIPs", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets a list of packs to be enabled.
    pub fn initial_enabled_packs(&self) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getInitialEnabledPacks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(
                self.jni_ref()
                    .get_string(unsafe { &jni::objects::JString::from_raw(*obj) })?
                    .to_string_lossy()
                    .to_string(),
            );
        }
        Ok(new_vec)
    }
    /// Gets a list of packs that will not be enabled automatically.
    pub fn initial_disabled_packs(&self) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getInitialDisabledPacks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(
                self.jni_ref()
                    .get_string(unsafe { &jni::objects::JString::from_raw(*obj) })?
                    .to_string_lossy()
                    .to_string(),
            );
        }
        Ok(new_vec)
    }
    /// Get the DataPack Manager.
    pub fn data_pack_manager(
        &self,
    ) -> Result<crate::packs::DataPackManager<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/packs/DataPackManager;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDataPackManager",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::packs::DataPackManager::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Get the ServerTick Manager.
    pub fn server_tick_manager(
        &self,
    ) -> Result<crate::ServerTickManager<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/ServerTickManager;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getServerTickManager",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::ServerTickManager::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the resource pack configured to be sent to clients by the server.
    pub fn server_resource_pack(
        &self,
    ) -> Result<Option<crate::packs::ResourcePack<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/packs/ResourcePack;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getServerResourcePack",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::packs::ResourcePack::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Gets the server resource pack uri, or empty string if not specified.
    pub fn resource_pack(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getResourcePack", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets the SHA-1 digest of the server resource pack, or empty string if
    /// not specified.
    pub fn resource_pack_hash(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getResourcePackHash",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets the custom prompt message to be shown when the server resource
    /// pack is required, or empty string if not specified.
    pub fn resource_pack_prompt(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getResourcePackPrompt",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets whether the server resource pack is enforced.
    pub fn is_resource_pack_required(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isResourcePackRequired",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether this server has a whitelist or not.
    pub fn has_whitelist(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "hasWhitelist", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if the server is whitelisted.
    pub fn set_whitelist(&self, value: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(value.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWhitelist",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets whether the server whitelist is enforced.
    /// If the whitelist is enforced, non-whitelisted players will be
    /// disconnected when the server whitelist is reloaded.
    pub fn is_whitelist_enforced(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isWhitelistEnforced",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if the server whitelist is enforced.
    /// If the whitelist is enforced, non-whitelisted players will be
    /// disconnected when the server whitelist is reloaded.
    pub fn set_whitelist_enforced(&self, value: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(value.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWhitelistEnforced",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets a list of whitelisted players.
    pub fn whitelisted_players(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getWhitelistedPlayers",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Reloads the whitelist from disk.
    pub fn reload_whitelist(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "reloadWhitelist", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Broadcast a message to all players.
    ///
    /// This is the same as calling {@link #broadcast(java.lang.String,
    /// java.lang.String)} to {@link #BROADCAST_CHANNEL_USERS}
    pub fn broadcast_message(
        &self,
        message: impl Into<String>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)I");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(message.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "broadcastMessage",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the name of the update folder. The update folder is used to safely
    /// update plugins at the right moment on a plugin load.
    ///
    /// The update folder name is relative to the plugins folder.
    pub fn update_folder(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getUpdateFolder", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets the value of the connection throttle setting.
    pub fn connection_throttle(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getConnectionThrottle",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    #[deprecated]
    /// Gets default ticks per animal spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn monsters every tick. <li>A value of 400 will mean the server will attempt to spawn monsters every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, animal spawning will be disabled. We recommend using spawn-animals to control this instead.Minecraft default: 400.
    pub fn ticks_per_animal_spawns(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerAnimalSpawns",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets the default ticks per monster spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn monsters every tick. <li>A value of 400 will mean the server will attempt to spawn monsters every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, monsters spawning will be disabled. We recommend using spawn-monsters to control this instead.Minecraft default: 1.
    pub fn ticks_per_monster_spawns(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerMonsterSpawns",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets the default ticks per water mob spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn water mobs every tick. <li>A value of 400 will mean the server will attempt to spawn water mobs every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, water mobs spawning will be disabled.Minecraft default: 1.
    pub fn ticks_per_water_spawns(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerWaterSpawns",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets the default ticks per water ambient mob spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn water ambient mobs every tick. <li>A value of 400 will mean the server will attempt to spawn water ambient mobs every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, ambient mobs spawning will be disabled.Minecraft default: 1.
    pub fn ticks_per_water_ambient_spawns(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerWaterAmbientSpawns",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets the default ticks per water underground creature spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn water underground creature every tick. <li>A value of 400 will mean the server will attempt to spawn water underground creature every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, water underground creature spawning will be disabled.Minecraft default: 1.
    pub fn ticks_per_water_underground_creature_spawns(
        &self,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerWaterUndergroundCreatureSpawns",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets the default ticks per ambient mob spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn ambient mobs every tick. <li>A value of 400 will mean the server will attempt to spawn ambient mobs every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, ambient mobs spawning will be disabled.Minecraft default: 1.
    pub fn ticks_per_ambient_spawns(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerAmbientSpawns",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the default ticks per {@link SpawnCategory} spawns value.
    ///
    /// <b>Example Usage:</b>
    /// <ul>
    /// <li>A value of 1 will mean the server will attempt to spawn {@link SpawnCategory} mobs
    /// every tick.
    /// <li>A value of 400 will mean the server will attempt to spawn {@link SpawnCategory} mobs
    /// every 400th tick.
    /// <li>A value below 0 will be reset back to Minecraft's default.
    /// </ul>
    ///
    /// <b>Note:</b> If set to 0, {@link SpawnCategory} mobs spawning will be disabled.
    ///
    /// Minecraft default: 1.
    ///
    /// <b>Note: </b> the {@link SpawnCategory#MISC} are not consider.
    pub fn get_ticks_per_spawns(
        &self,
        spawn_category: impl Into<crate::entity::SpawnCategory<'mc>>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/SpawnCategory;)I");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(spawn_category.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerSpawns",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the player with the given UUID.
    pub fn get_player(
        &self,
        id: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/util/UUID;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(id.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Lorg/bukkit/entity/Player;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getPlayer", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Player::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Gets the player with the exact given name, case insensitive.
    pub fn get_player_exact(
        &self,
        name: impl Into<String>,
    ) -> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/entity/Player;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(name.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPlayerExact",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Player::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Attempts to match any players with the given name, and returns a list
    /// of all possibly matches.
    ///
    /// This list is not sorted in any particular order. If an exact match is
    /// found, the returned list will only contain a single result.
    pub fn match_player(
        &self,
        name: impl Into<String>,
    ) -> Result<Vec<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(name.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "matchPlayer",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Player::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Gets the plugin manager for interfacing with plugins.
    pub fn plugin_manager(
        &self,
    ) -> Result<crate::plugin::PluginManager<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/plugin/PluginManager;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPluginManager",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::plugin::PluginManager::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the scheduler for managing scheduled events.
    pub fn scheduler(
        &self,
    ) -> Result<crate::scheduler::BukkitScheduler<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/scheduler/BukkitScheduler;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getScheduler", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::scheduler::BukkitScheduler::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets a services manager.
    pub fn services_manager(
        &self,
    ) -> Result<crate::plugin::ServicesManager<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/plugin/ServicesManager;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getServicesManager",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::plugin::ServicesManager::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets a list of all worlds on this server.
    pub fn worlds(&self) -> Result<Vec<crate::World<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getWorlds", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::World::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Creates or loads a world with the given name using the specified
    /// options.
    ///
    /// If the world is already loaded, it will just return the equivalent of
    /// getWorld(creator.name()).
    pub fn create_world(
        &self,
        creator: impl Into<crate::WorldCreator<'mc>>,
    ) -> Result<Option<crate::World<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/WorldCreator;)Lorg/bukkit/World;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(creator.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "createWorld",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::World::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Unloads the given world.
    pub fn unload_world(
        &self,
        world: impl Into<crate::World<'mc>>,
        save: bool,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/World;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Z";
        let val_2 = jni::objects::JValueGen::Bool(save.into());
        args.push(val_2);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "unloadWorld", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the world from the given Unique ID.
    pub fn get_world(
        &self,
        uid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<Option<crate::World<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/util/UUID;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(uid.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Lorg/bukkit/World;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getWorld", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::World::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Create a new virtual {@link WorldBorder}.
    ///
    /// Note that world borders created by the server will not respect any world
    /// scaling effects (i.e. coordinates are not divided by 8 in the nether).
    pub fn create_world_border(
        &self,
    ) -> Result<crate::WorldBorder<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/WorldBorder;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "createWorldBorder",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::WorldBorder::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    #[deprecated]
    /// Gets the map from the given item ID.
    pub fn get_map(
        &self,
        id: i32,
    ) -> Result<Option<crate::map::MapView<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Lorg/bukkit/map/MapView;");
        let val_1 = jni::objects::JValueGen::Int(id);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMap",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::map::MapView::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Create a new map with an automatically assigned ID.
    pub fn create_map(
        &self,
        world: impl Into<crate::World<'mc>>,
    ) -> Result<crate::map::MapView<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/World;)Lorg/bukkit/map/MapView;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "createMap",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::map::MapView::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Create a new explorer map targeting the closest nearby structure of a
    /// given {@link StructureType}.
    ///
    /// This method uses implementation default values for radius and
    /// findUnexplored (usually 100, true).
    pub fn create_explorer_map(
        &self,
        world: impl Into<crate::World<'mc>>,
        location: impl Into<crate::Location<'mc>>,
        structure_type: impl Into<crate::StructureType<'mc>>,
        radius: std::option::Option<i32>,
        find_unexplored: std::option::Option<bool>,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/World;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/Location;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_2);
        sig += "Lorg/bukkit/StructureType;";
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(structure_type.into().jni_object().clone())
        });
        args.push(val_3);
        if let Some(a) = radius {
            sig += "I";
            let val_4 = jni::objects::JValueGen::Int(a);
            args.push(val_4);
        }
        if let Some(a) = find_unexplored {
            sig += "Z";
            let val_5 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_5);
        }
        sig += ")Lorg/bukkit/inventory/ItemStack;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "createExplorerMap", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Reloads the server, refreshing settings and plugin information.
    pub fn reload(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "reload", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Reload only the Minecraft data for the server. This includes custom
    /// advancements and loot tables.
    pub fn reload_data(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "reloadData", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Returns the primary logger associated with this server instance.
    pub fn logger(
        &self,
    ) -> Result<blackboxmc_java::util::logging::JavaLogger<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/logging/Logger;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getLogger", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::logging::JavaLogger::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets a {@link PluginCommand} with the given name or alias.
    pub fn get_plugin_command(
        &self,
        name: impl Into<String>,
    ) -> Result<Option<crate::command::PluginCommand<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/command/PluginCommand;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(name.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPluginCommand",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::command::PluginCommand::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Writes loaded players to disk.
    pub fn save_players(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "savePlayers", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Dispatches a command on this server, and executes it if found.
    pub fn dispatch_command(
        &self,
        sender: impl Into<crate::command::CommandSender<'mc>>,
        command_line: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/command/CommandSender;Ljava/lang/String;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(sender.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(command_line.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "dispatchCommand",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Adds a recipe to the crafting manager.
    pub fn add_recipe(
        &self,
        recipe: impl Into<crate::inventory::Recipe<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/Recipe;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(recipe.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "addRecipe",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Get a list of all recipes for a given item. The stack size is ignored
    /// in comparisons. If the durability is -1, it will match any data value.
    pub fn get_recipes_for(
        &self,
        result: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<Vec<crate::inventory::Recipe<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(result.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getRecipesFor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::inventory::Recipe::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Get the {@link Recipe} for the given key.
    pub fn get_recipe(
        &self,
        recipe_key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<Option<crate::inventory::Recipe<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lorg/bukkit/inventory/Recipe;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(recipe_key.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getRecipe",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::inventory::Recipe::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Get the {@link Recipe} for the list of ItemStacks provided.
    /// The list is formatted as a crafting matrix where the index follow
    /// the pattern below:
    /// <pre>
    /// [ 0 1 2 ]
    /// [ 3 4 5 ]
    /// [ 6 7 8 ]
    /// </pre>
    /// NOTE: This method will not modify the provided ItemStack array, for that, use
    /// {@link #craftItem(ItemStack[], World, Player)}.
    pub fn get_crafting_recipe(
        &self,
        crafting_matrix: impl Into<crate::inventory::ItemStack<'mc>>,
        world: impl Into<crate::World<'mc>>,
    ) -> Result<Option<crate::inventory::Recipe<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from(
            "(Lorg/bukkit/inventory/ItemStack;Lorg/bukkit/World;)Lorg/bukkit/inventory/Recipe;",
        );
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(crafting_matrix.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCraftingRecipe",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::inventory::Recipe::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Get the crafted item using the list of {@link ItemStack} provided.
    /// The list is formatted as a crafting matrix where the index follow
    /// the pattern below:
    /// <pre>
    /// [ 0 1 2 ]
    /// [ 3 4 5 ]
    /// [ 6 7 8 ]
    /// </pre>
    /// The {@link World} and {@link Player} arguments are required to fulfill the Bukkit Crafting
    /// events.
    /// Calls {@link org.bukkit.event.inventory.PrepareItemCraftEvent} to imitate the {@link Player}
    /// initiating the crafting event.
    pub fn craft_item(
        &self,
        crafting_matrix: impl Into<crate::inventory::ItemStack<'mc>>,
        world: impl Into<crate::World<'mc>>,
        player: std::option::Option<impl Into<crate::entity::Player<'mc>>>,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/inventory/ItemStack;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(crafting_matrix.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/World;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = player {
            sig += "Lorg/bukkit/entity/Player;";
            let val_3 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/inventory/ItemStack;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "craftItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Get the crafted item using the list of {@link ItemStack} provided.
    /// The list is formatted as a crafting matrix where the index follow
    /// the pattern below:
    /// <pre>
    /// [ 0 1 2 ]
    /// [ 3 4 5 ]
    /// [ 6 7 8 ]
    /// </pre>
    /// The {@link World} and {@link Player} arguments are required to fulfill the Bukkit Crafting
    /// events.
    /// Calls {@link org.bukkit.event.inventory.PrepareItemCraftEvent} to imitate the {@link Player}
    /// initiating the crafting event.
    pub fn craft_item_result(
        &self,
        crafting_matrix: impl Into<crate::inventory::ItemStack<'mc>>,
        world: impl Into<crate::World<'mc>>,
        player: std::option::Option<impl Into<crate::entity::Player<'mc>>>,
    ) -> Result<crate::inventory::ItemCraftResult<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/inventory/ItemStack;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(crafting_matrix.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/World;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = player {
            sig += "Lorg/bukkit/entity/Player;";
            let val_3 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/inventory/ItemCraftResult;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "craftItemResult", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemCraftResult::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Get an iterator through the list of crafting recipes.
    pub fn recipe_iterator(
        &self,
    ) -> Result<blackboxmc_java::util::JavaIterator<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Iterator;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "recipeIterator", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaIterator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Clears the list of crafting recipes.
    pub fn clear_recipes(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "clearRecipes", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Resets the list of crafting recipes to the default.
    pub fn reset_recipes(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "resetRecipes", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Remove a recipe from the server.
    /// <b>Note that removing a recipe may cause permanent loss of data
    /// associated with that recipe (eg whether it has been discovered by
    /// players).</b>
    pub fn remove_recipe(
        &self,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removeRecipe",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets a list of command aliases defined in the server properties.
    pub fn command_aliases(
        &self,
    ) -> Result<blackboxmc_java::util::JavaMap<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Map;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCommandAliases",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaMap::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the radius, in blocks, around each worlds spawn point to protect.
    pub fn spawn_radius(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getSpawnRadius", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the radius, in blocks, around each worlds spawn point to protect.
    pub fn set_spawn_radius(&self, value: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(value);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSpawnRadius",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets whether the server should send a preview of the player's chat message to the client when the player types a message
    pub fn should_send_chat_previews(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "shouldSendChatPreviews",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether the server only allow players with Mojang-signed public key
    /// to join
    pub fn is_enforcing_secure_profiles(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isEnforcingSecureProfiles",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether this server is allowing connections transferred from other
    /// servers.
    pub fn is_accepting_transfers(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isAcceptingTransfers",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether the Server hide online players in server status.
    pub fn hide_online_players(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getHideOnlinePlayers",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether the Server is in online mode or not.
    pub fn online_mode(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getOnlineMode", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether this server allows flying or not.
    pub fn allow_flight(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getAllowFlight", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether the server is in hardcore mode or not.
    pub fn is_hardcore(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isHardcore", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Shutdowns the server, stopping everything.
    pub fn shutdown(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "shutdown", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Broadcasts the specified message to every user with the given
    /// permission name.
    pub fn broadcast(
        &self,
        message: impl Into<String>,
        permission: impl Into<String>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;Ljava/lang/String;)I");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(message.into())?,
        ));
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(permission.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "broadcast",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the player by the given UUID, regardless if they are offline or
    /// online.
    ///
    /// This will return an object even if the player does not exist. To this
    /// method, all players will exist.
    pub fn get_offline_player(
        &self,
        id: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<crate::OfflinePlayer<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/util/UUID;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(id.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Lorg/bukkit/OfflinePlayer;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getOfflinePlayer", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::OfflinePlayer::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Creates a new {@link PlayerProfile}.
    pub fn create_player_profile(
        &self,
        unique_id: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
        name: std::option::Option<impl Into<String>>,
    ) -> Result<crate::profile::PlayerProfile<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/util/UUID;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(unique_id.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = name {
            sig += "Ljava/lang/String;";
            let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                self.jni_ref().new_string(a.into())?,
            ));
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/profile/PlayerProfile;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "createPlayerProfile",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::profile::PlayerProfile::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets a set containing all current IPs that are banned.
    pub fn ipbans(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getIPBans", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Bans the specified address from the server.
    pub fn ban_ip(
        &self,
        address: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/net/InetAddress;";
        let val_1 = jni::objects::JValueGen::Object(address);
        args.push(val_1);
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "banIP", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Unbans the specified address from the server.
    pub fn unban_ip(
        &self,
        address: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/net/InetAddress;";
        let val_1 = jni::objects::JValueGen::Object(address);
        args.push(val_1);
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "unbanIP", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets a set containing all banned players.
    pub fn banned_players(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBannedPlayers",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets a ban list for the supplied type.
    pub fn get_ban_list(
        &self,
        val_type: impl Into<crate::BanListType<'mc>>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/BanList/Type;)LT;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(val_type.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBanList",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }
    /// Gets a set containing all player operators.
    pub fn operators(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getOperators", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the default {@link GameMode} for new players.
    pub fn default_game_mode(&self) -> Result<crate::GameMode<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/GameMode;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDefaultGameMode",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::GameMode::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the default {@link GameMode} for new players.
    pub fn set_default_game_mode(
        &self,
        mode: impl Into<crate::GameMode<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/GameMode;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(mode.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDefaultGameMode",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets a {@link ConsoleCommandSender} that may be used as an input source
    /// for this server.
    pub fn console_sender(
        &self,
    ) -> Result<crate::command::ConsoleCommandSender<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/command/ConsoleCommandSender;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getConsoleSender",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::command::ConsoleCommandSender::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets every player that has ever played on this server.
    pub fn offline_players(&self) -> Result<crate::OfflinePlayer<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/OfflinePlayer;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getOfflinePlayers",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::OfflinePlayer::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the {@link Messenger} responsible for this server.
    pub fn messenger(
        &self,
    ) -> Result<crate::plugin::messaging::Messenger<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/plugin/messaging/Messenger;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMessenger", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::plugin::messaging::Messenger::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the {@link HelpMap} providing help topics for this server.
    pub fn help_map(&self) -> Result<crate::help::HelpMap<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/help/HelpMap;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getHelpMap", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::help::HelpMap::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Creates an empty inventory of type {@link InventoryType#CHEST} with the
    /// specified size and title.
    pub fn create_inventory(
        &self,
        owner: impl Into<crate::inventory::InventoryHolder<'mc>>,
        size: i32,
        title: std::option::Option<impl Into<String>>,
    ) -> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/inventory/InventoryHolder;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(owner.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(size);
        args.push(val_2);
        if let Some(a) = title {
            sig += "Ljava/lang/String;";
            let val_3 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                self.jni_ref().new_string(a.into())?,
            ));
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/inventory/Inventory;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "createInventory", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::Inventory::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Creates an empty merchant.
    pub fn create_merchant(
        &self,
        title: impl Into<String>,
    ) -> Result<crate::inventory::Merchant<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/inventory/Merchant;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(title.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "createMerchant",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::Merchant::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the amount of consecutive neighbor updates before skipping
    /// additional ones.
    pub fn max_chained_neighbor_updates(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxChainedNeighborUpdates",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets user-specified limit for number of monsters that can spawn in a chunk.
    pub fn monster_spawn_limit(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMonsterSpawnLimit",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets user-specified limit for number of animals that can spawn in a chunk.
    pub fn animal_spawn_limit(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getAnimalSpawnLimit",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets user-specified limit for number of water animals that can spawn in a chunk.
    pub fn water_animal_spawn_limit(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getWaterAnimalSpawnLimit",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets user-specified limit for number of water ambient mobs that can spawn in a chunk.
    pub fn water_ambient_spawn_limit(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getWaterAmbientSpawnLimit",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Get user-specified limit for number of water creature underground that can spawn in a chunk.
    pub fn water_underground_creature_spawn_limit(
        &self,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getWaterUndergroundCreatureSpawnLimit",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets user-specified limit for number of ambient mobs that can spawn in a chunk.
    pub fn ambient_spawn_limit(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getAmbientSpawnLimit",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets user-specified limit for number of {@link SpawnCategory} mobs that can spawn in
    /// a chunk.
    /// <b>Note: the {@link SpawnCategory#MISC} are not consider.</b>
    pub fn get_spawn_limit(
        &self,
        spawn_category: impl Into<crate::entity::SpawnCategory<'mc>>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/SpawnCategory;)I");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(spawn_category.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getSpawnLimit",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Checks the current thread against the expected primary thread for the
    /// server.
    ///
    /// <b>Note:</b> this method should not be used to indicate the current
    /// synchronized state of the runtime. A current thread matching the main
    /// thread indicates that it is synchronized, but a mismatch <b>does not
    /// preclude</b> the same assumption.
    pub fn is_primary_thread(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isPrimaryThread", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the message that is displayed on the server list.
    pub fn motd(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getMotd", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Set the message that is displayed on the server list.
    pub fn set_motd(&self, motd: impl Into<String>) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(motd.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMotd",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the default message that is displayed when the server is stopped.
    pub fn shutdown_message(&self) -> Result<Option<String>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getShutdownMessage",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(
            self.jni_ref()
                .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
                .to_string_lossy()
                .to_string(),
        ))
    }
    /// Gets the current warning state for the server.
    pub fn warning_state(
        &self,
    ) -> Result<crate::WarningWarningState<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Warning/WarningState;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getWarningState", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::WarningWarningState::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the instance of the item factory (for {@link ItemMeta}).
    pub fn item_factory(
        &self,
    ) -> Result<crate::inventory::ItemFactory<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemFactory;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getItemFactory", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemFactory::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the instance of the entity factory (for {@link EntitySnapshot}).
    pub fn entity_factory(
        &self,
    ) -> Result<crate::entity::EntityFactory<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/EntityFactory;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getEntityFactory",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::EntityFactory::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the instance of the scoreboard manager.
    ///
    /// This will only exist after the first world has loaded.
    pub fn scoreboard_manager(
        &self,
    ) -> Result<Option<crate::scoreboard::ScoreboardManager<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/scoreboard/ScoreboardManager;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardManager",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::scoreboard::ScoreboardManager::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Get (or create) a new {@link Criteria} by its name.
    pub fn get_scoreboard_criteria(
        &self,
        name: impl Into<String>,
    ) -> Result<crate::scoreboard::Criteria<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/scoreboard/Criteria;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(name.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getScoreboardCriteria",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::scoreboard::Criteria::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets an instance of the server's default server-icon.
    pub fn server_icon(
        &self,
    ) -> Result<Option<crate::util::CachedServerIcon<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/CachedServerIcon;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getServerIcon", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::util::CachedServerIcon::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Creates a cached server-icon for the specific image.
    ///
    /// Size and type are implementation defined. An incompatible file is
    /// guaranteed to throw an implementation-defined {@link Exception}.
    pub fn load_server_icon(
        &self,
        image: jni::objects::JObject<'mc>,
    ) -> Result<crate::util::CachedServerIcon<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/awt/image/BufferedImage;";
        let val_1 = jni::objects::JValueGen::Object(image);
        args.push(val_1);
        sig += ")Lorg/bukkit/util/CachedServerIcon;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "loadServerIcon", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::CachedServerIcon::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Set the idle kick timeout. Any players idle for the specified amount of
    /// time will be automatically kicked.
    ///
    /// A value of 0 will disable the idle kick timeout.
    pub fn set_idle_timeout(&self, threshold: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(threshold);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setIdleTimeout",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the idle kick timeout.
    pub fn idle_timeout(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getIdleTimeout", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Create a ChunkData for use in a generator.
    /// See {@link ChunkGenerator#generateChunkData(org.bukkit.World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)}
    pub fn create_chunk_data(
        &self,
        world: impl Into<crate::World<'mc>>,
    ) -> Result<crate::generator::ChunkGeneratorChunkData<'mc>, Box<dyn std::error::Error>> {
        let sig =
            String::from("(Lorg/bukkit/World;)Lorg/bukkit/generator/ChunkGenerator/ChunkData;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "createChunkData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::generator::ChunkGeneratorChunkData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Creates a boss bar instance to display to players. The progress defaults
    /// to 1.0.
    ///
    /// This instance is added to the persistent storage of the server and will
    /// be editable by commands and restored after restart.
    pub fn create_boss_bar(
        &self,
        key: impl Into<crate::NamespacedKey<'mc>>,
        title: impl Into<String>,
        color: impl Into<crate::boss::BarColor<'mc>>,
        style: impl Into<crate::boss::BarStyle<'mc>>,
        flags: std::option::Option<impl Into<crate::boss::BarFlag<'mc>>>,
    ) -> Result<crate::boss::KeyedBossBar<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/NamespacedKey;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Ljava/lang/String;";
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(title.into())?,
        ));
        args.push(val_2);
        sig += "Lorg/bukkit/boss/BarColor;";
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(color.into().jni_object().clone())
        });
        args.push(val_3);
        sig += "Lorg/bukkit/boss/BarStyle;";
        let val_4 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(style.into().jni_object().clone())
        });
        args.push(val_4);
        if let Some(a) = flags {
            sig += "Lorg/bukkit/boss/BarFlag;";
            let val_5 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_5);
        }
        sig += ")Lorg/bukkit/boss/KeyedBossBar;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "createBossBar", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::boss::KeyedBossBar::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets an unmodifiable iterator through all persistent bossbars.
    /// <ul>
    /// <li><b>not</b> bound to a {@link org.bukkit.entity.Boss}</li>
    /// <li>
    /// <b>not</b> created using
    /// {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
    /// </li>
    /// </ul>
    /// e.g. bossbars created using the bossbar command
    pub fn boss_bars(
        &self,
    ) -> Result<blackboxmc_java::util::JavaIterator<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Iterator;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBossBars", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaIterator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the {@link KeyedBossBar} specified by this key.
    /// <ul>
    /// <li><b>not</b> bound to a {@link org.bukkit.entity.Boss}</li>
    /// <li>
    /// <b>not</b> created using
    /// {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
    /// </li>
    /// </ul>
    /// e.g. bossbars created using the bossbar command
    pub fn get_boss_bar(
        &self,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<Option<crate::boss::KeyedBossBar<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lorg/bukkit/boss/KeyedBossBar;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBossBar",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::boss::KeyedBossBar::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Removes a {@link KeyedBossBar} specified by this key.
    /// <ul>
    /// <li><b>not</b> bound to a {@link org.bukkit.entity.Boss}</li>
    /// <li>
    /// <b>not</b> created using
    /// {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
    /// </li>
    /// </ul>
    /// e.g. bossbars created using the bossbar command
    pub fn remove_boss_bar(
        &self,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removeBossBar",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets an entity on the server by its UUID
    pub fn get_entity(
        &self,
        uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/UUID;)Lorg/bukkit/entity/Entity;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(uuid.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getEntity",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Entity::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Get the advancement specified by this key.
    pub fn get_advancement(
        &self,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<Option<crate::advancement::Advancement<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lorg/bukkit/advancement/Advancement;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getAdvancement",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::advancement::Advancement::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Get an iterator through all advancements. Advancements cannot be removed
    /// from this iterator,
    pub fn advancement_iterator(
        &self,
    ) -> Result<blackboxmc_java::util::JavaIterator<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Iterator;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "advancementIterator",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaIterator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Creates a new {@link BlockData} instance for the specified Material, with
    /// all properties initialized to unspecified defaults, except for those
    /// provided in data.
    ///
    /// If <code>material</code> is specified, then the data string must not also
    /// contain the material.
    pub fn create_block_data(
        &self,
        material: impl Into<crate::Material<'mc>>,
        data: std::option::Option<impl Into<String>>,
    ) -> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(material.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = data {
            sig += "Ljava/lang/String;";
            let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                self.jni_ref().new_string(a.into())?,
            ));
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/block/data/BlockData;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "createBlockData", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::data::BlockData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets a tag which has already been defined within the server. Plugins are
    /// suggested to use the concrete tags in {@link Tag} rather than this method
    /// which makes no guarantees about which tags are available, and may also be
    /// less performant due to lack of caching.
    ///
    /// Tags will be searched for in an implementation specific manner, but a
    /// path consisting of namespace/tags/registry/key is expected.
    ///
    /// Server implementations are allowed to handle only the registries
    /// indicated in {@link Tag}.
    pub fn get_tag(
        &self,
        registry: impl Into<String>,
        tag: impl Into<crate::NamespacedKey<'mc>>,
        clazz: jni::objects::JClass<'mc>,
    ) -> Result<Option<crate::Tag<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from(
            "(Ljava/lang/String;Lorg/bukkit/NamespacedKey;Ljava/lang/Class;)Lorg/bukkit/Tag;",
        );
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(registry.into())?,
        ));
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(tag.into().jni_object().clone())
        });
        let val_3 = jni::objects::JValueGen::Object(clazz.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTag",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Tag::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Gets the specified {@link LootTable}.
    pub fn get_loot_table(
        &self,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<Option<crate::loot::LootTable<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lorg/bukkit/loot/LootTable;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLootTable",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::loot::LootTable::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Selects entities using the given Vanilla selector.
    ///
    /// No guarantees are made about the selector format, other than they match
    /// the Vanilla format for the active Minecraft version.
    ///
    /// Usually a selector will start with '@', unless selecting a Player in
    /// which case it may simply be the Player's name or UUID.
    ///
    /// Note that in Vanilla, elevated permissions are usually required to use
    /// '@' selectors, but this method should not check such permissions from the
    /// sender.
    pub fn select_entities(
        &self,
        sender: impl Into<crate::command::CommandSender<'mc>>,
        selector: impl Into<String>,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig =
            String::from("(Lorg/bukkit/command/CommandSender;Ljava/lang/String;)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(sender.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(selector.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "selectEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Gets the structure manager for loading and saving structures.
    pub fn structure_manager(
        &self,
    ) -> Result<crate::structure::StructureManager<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/structure/StructureManager;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getStructureManager",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::structure::StructureManager::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Returns the registry for the given class.
    ///
    /// If no registry is present for the given class null will be returned.
    ///
    /// Depending on the implementation not every registry present in
    /// {@link Registry} will be returned by this method.
    pub fn get_registry(
        &self,
        t_class: jni::objects::JClass<'mc>,
    ) -> Result<Option<crate::Registry<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/Class;)Lorg/bukkit/Registry;");
        let val_1 = jni::objects::JValueGen::Object(t_class.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getRegistry",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Registry::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    #[deprecated]

    pub fn get_unsafe(&self) -> Result<crate::UnsafeValues<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/UnsafeValues;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getUnsafe", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::UnsafeValues::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sends this recipient a Plugin Message on the specified outgoing
    /// channel.
    ///
    /// The message may not be larger than {@link Messenger#MAX_MESSAGE_SIZE}
    /// bytes, and the plugin must be registered to send messages on the
    /// specified channel.
    pub fn send_plugin_message(
        &self,
        source: impl Into<crate::plugin::Plugin<'mc>>,
        channel: impl Into<String>,
        message: i8,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/plugin/Plugin;Ljava/lang/String;B)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(source.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(channel.into())?,
        ));
        let val_3 = jni::objects::JValueGen::Byte(message);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "sendPluginMessage",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets a set containing all the Plugin Channels that this client is
    /// listening on.
    pub fn listening_plugin_channels(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getListeningPluginChannels",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::plugin::messaging::PluginMessageRecipient<'mc>> for Server<'mc> {
    fn into(self) -> crate::plugin::messaging::PluginMessageRecipient<'mc> {
        crate::plugin::messaging::PluginMessageRecipient::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Server into crate::plugin::messaging::PluginMessageRecipient")
    }
}
#[repr(C)]
pub struct Tag<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Tag<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Tag<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Tag from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Tag")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Tag object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Tag<'mc> {
    /// Returns whether or not this tag has an entry for the specified item.
    pub fn is_tagged(
        &self,
        item: jni::objects::JObject<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(LT;)Z");
        let val_1 = jni::objects::JValueGen::Object(item);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isTagged",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets an immutable set of all tagged items.
    pub fn values(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getValues", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Return the namespaced identifier for this object.
    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::Keyed<'mc>> for Tag<'mc> {
    fn into(self) -> crate::Keyed<'mc> {
        crate::Keyed::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Tag into crate::Keyed")
    }
}
#[repr(C)]
pub struct Bukkit<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Bukkit<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Bukkit<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Bukkit from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Bukkit")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Bukkit object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Bukkit<'mc> {
    /// Gets the current {@link Server} singleton
    pub fn server(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::Server<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Server;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getServer", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Server::from_raw(&jni, obj)
    }
    /// Attempts to set the {@link Server} singleton.
    ///
    /// This cannot be done if the Server is already set.
    pub fn set_server(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        server: impl Into<crate::Server<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Server;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(server.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "setServer",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        jni.translate_error(res)?;
        Ok(())
    }
    /// Gets the name of this server implementation.
    pub fn name(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getName", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(jni
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets the version string of this server implementation.
    pub fn version(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getVersion", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(jni
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets the Bukkit version that this server is running.
    pub fn bukkit_version(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getBukkitVersion", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(jni
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets a view of all currently logged in players. This {@linkplain
    /// Collections#unmodifiableCollection(Collection) view} is a reused
    /// object, making some operations like {@link Collection#size()}
    /// zero-allocation.
    ///
    /// The collection is a view backed by the internal representation, such
    /// that, changes to the internal state of the server will be reflected
    /// immediately. However, the reuse of the returned collection (identity)
    /// is not strictly guaranteed for future or all implementations. Casting
    /// the collection, or relying on interface implementations (like {@link
    /// Serializable} or {@link List}), is deprecated.
    ///
    /// Iteration behavior is undefined outside of self-contained main-thread
    /// uses. Normal and immediate iterator use without consequences that
    /// affect the collection are fully supported. The effects following
    /// (non-exhaustive) {@link Entity#teleport(Location) teleportation},
    /// {@link Player#setHealth(double) death}, and {@link Player#kickPlayer(
    /// String) kicking} are undefined. Any use of this collection from
    /// asynchronous threads is unsafe.
    ///
    /// For safe consequential iteration or mimicking the old array behavior,
    /// using {@link Collection#toArray(Object[])} is recommended. For making
    /// snapshots, {@link ImmutableList#copyOf(Collection)} is recommended.
    pub fn online_players(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<Vec<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getOnlinePlayers", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&jni, res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Player::from_raw(&jni, obj)?);
        }
        Ok(new_vec)
    }
    /// Get the maximum amount of players which can login to this server.
    pub fn max_players(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getMaxPlayers", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the maximum amount of players allowed to be logged in at once.
    pub fn set_max_players(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        max_players: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(max_players);
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "setMaxPlayers",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        jni.translate_error(res)?;
        Ok(())
    }
    /// Get the game port that the server runs on.
    pub fn port(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getPort", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    /// Get the view distance from this server.
    pub fn view_distance(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getViewDistance", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    /// Get the simulation distance from this server.
    pub fn simulation_distance(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getSimulationDistance", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    /// Get the IP that this server is bound to, or empty string if not
    /// specified.
    pub fn ip(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getIp", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(jni
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Get world type (level-type setting) for default world.
    pub fn world_type(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getWorldType", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(jni
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Get generate-structures setting.
    pub fn generate_structures(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getGenerateStructures", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Get max world size.
    pub fn max_world_size(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getMaxWorldSize", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets whether this server allows the End or not.
    pub fn allow_end(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getAllowEnd", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether this server allows the Nether or not.
    pub fn allow_nether(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getAllowNether", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether the server is logging the IP addresses of players.
    pub fn is_logging_ips(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "isLoggingIPs", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn initial_enabled_packs(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getInitialEnabledPacks", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&jni, res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(
                jni.get_string(unsafe { &jni::objects::JString::from_raw(*obj) })?
                    .to_string_lossy()
                    .to_string(),
            );
        }
        Ok(new_vec)
    }

    pub fn initial_disabled_packs(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getInitialDisabledPacks", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&jni, res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(
                jni.get_string(unsafe { &jni::objects::JString::from_raw(*obj) })?
                    .to_string_lossy()
                    .to_string(),
            );
        }
        Ok(new_vec)
    }
    /// Get the DataPack Manager.
    pub fn data_pack_manager(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::packs::DataPackManager<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/packs/DataPackManager;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getDataPackManager", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::packs::DataPackManager::from_raw(&jni, obj)
    }
    /// Gets the resource pack configured to be sent to clients by the server.
    pub fn server_resource_pack(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<Option<crate::packs::ResourcePack<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/packs/ResourcePack;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getServerResourcePack", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::packs::ResourcePack::from_raw(&jni, obj)?))
    }
    /// Get the ServerTick Manager.
    pub fn server_tick_manager(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::ServerTickManager<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/ServerTickManager;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getServerTickManager", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::ServerTickManager::from_raw(&jni, obj)
    }
    /// Gets the server resource pack uri, or empty string if not specified.
    pub fn resource_pack(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getResourcePack", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(jni
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets the SHA-1 digest of the server resource pack, or empty string if
    /// not specified.
    pub fn resource_pack_hash(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getResourcePackHash", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(jni
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets the custom prompt message to be shown when the server resource
    /// pack is required, or empty string if not specified.
    pub fn resource_pack_prompt(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getResourcePackPrompt", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(jni
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets whether the server resource pack is enforced.
    pub fn is_resource_pack_required(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "isResourcePackRequired", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether this server has a whitelist or not.
    pub fn has_whitelist(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "hasWhitelist", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if the server is whitelisted.
    pub fn set_whitelist(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        value: bool,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(value.into());
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "setWhitelist",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        jni.translate_error(res)?;
        Ok(())
    }
    /// Gets whether the server whitelist is enforced.
    /// If the whitelist is enforced, non-whitelisted players will be
    /// disconnected when the server whitelist is reloaded.
    pub fn is_whitelist_enforced(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "isWhitelistEnforced", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if the server whitelist is enforced.
    /// If the whitelist is enforced, non-whitelisted players will be
    /// disconnected when the server whitelist is reloaded.
    pub fn set_whitelist_enforced(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        value: bool,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(value.into());
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "setWhitelistEnforced",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        jni.translate_error(res)?;
        Ok(())
    }
    /// Gets a list of whitelisted players.
    pub fn whitelisted_players(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getWhitelistedPlayers", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        blackboxmc_java::util::JavaSet::from_raw(&jni, obj)
    }
    /// Reloads the whitelist from disk.
    pub fn reload_whitelist(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "reloadWhitelist", sig.as_str(), vec![]);
        jni.translate_error(res)?;
        Ok(())
    }
    /// Broadcast a message to all players.
    ///
    /// This is the same as calling {@link #broadcast(java.lang.String,
    /// java.lang.String)} to {@link Server#BROADCAST_CHANNEL_USERS}
    pub fn broadcast_message(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        message: impl Into<String>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)I");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(message.into())?,
        ));
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "broadcastMessage",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the name of the update folder. The update folder is used to safely
    /// update plugins at the right moment on a plugin load.
    ///
    /// The update folder name is relative to the plugins folder.
    pub fn update_folder(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getUpdateFolder", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(jni
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets the value of the connection throttle setting.
    pub fn connection_throttle(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getConnectionThrottle", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.j()?)
    }
    #[deprecated]
    /// Gets default ticks per animal spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn monsters every tick. <li>A value of 400 will mean the server will attempt to spawn monsters every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, animal spawning will be disabled. We recommend using spawn-animals to control this instead.Minecraft default: 400.
    pub fn ticks_per_animal_spawns(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getTicksPerAnimalSpawns", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets the default ticks per monster spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn monsters every tick. <li>A value of 400 will mean the server will attempt to spawn monsters every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, monsters spawning will be disabled. We recommend using spawn-monsters to control this instead.Minecraft default: 1.
    pub fn ticks_per_monster_spawns(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getTicksPerMonsterSpawns", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets the default ticks per water mob spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn water mobs every tick. <li>A value of 400 will mean the server will attempt to spawn water mobs every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, water mobs spawning will be disabled.Minecraft default: 1.
    pub fn ticks_per_water_spawns(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getTicksPerWaterSpawns", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets the default ticks per ambient mob spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn ambient mobs every tick. <li>A value of 400 will mean the server will attempt to spawn ambient mobs every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, ambient mobs spawning will be disabled.Minecraft default: 1.
    pub fn ticks_per_ambient_spawns(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getTicksPerAmbientSpawns", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets the default ticks per water ambient mob spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn water ambient mobs every tick. <li>A value of 400 will mean the server will attempt to spawn water ambient mobs every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, ambient mobs spawning will be disabled.Minecraft default: 1.
    pub fn ticks_per_water_ambient_spawns(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res =
            jni.call_static_method(cls, "getTicksPerWaterAmbientSpawns", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets the default ticks per water underground creature spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn water underground creature every tick. <li>A value of 400 will mean the server will attempt to spawn water underground creature every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, water underground creature spawning will be disabled.Minecraft default: 1.
    pub fn ticks_per_water_underground_creature_spawns(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getTicksPerWaterUndergroundCreatureSpawns",
            sig.as_str(),
            vec![],
        );
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the default ticks per {@link SpawnCategory} spawns value.
    ///
    /// <b>Example Usage:</b>
    /// <ul>
    /// <li>A value of 1 will mean the server will attempt to spawn {@link SpawnCategory} mobs
    /// every tick.
    /// <li>A value of 400 will mean the server will attempt to spawn {@link SpawnCategory} mobs
    /// every 400th tick.
    /// <li>A value below 0 will be reset back to Minecraft's default.
    /// </ul>
    ///
    /// <b>Note:</b> If set to 0, {@link SpawnCategory} mobs spawning will be disabled.
    ///
    /// Minecraft default: 1.
    ///
    /// <b>Note: </b> the {@link SpawnCategory#MISC} are not consider.
    pub fn get_ticks_per_spawns(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        spawn_category: impl Into<crate::entity::SpawnCategory<'mc>>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/SpawnCategory;)I");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(spawn_category.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getTicksPerSpawns",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the player with the given UUID.
    pub fn get_player(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        id: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/util/UUID;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(id.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Lorg/bukkit/entity/Player;";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getPlayer", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::entity::Player::from_raw(&jni, obj)?))
    }
    /// Gets the player with the exact given name, case insensitive.
    pub fn get_player_exact(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        name: impl Into<String>,
    ) -> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/entity/Player;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(name.into())?,
        ));
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getPlayerExact",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::entity::Player::from_raw(&jni, obj)?))
    }
    /// Attempts to match any players with the given name, and returns a list
    /// of all possibly matches.
    ///
    /// This list is not sorted in any particular order. If an exact match is
    /// found, the returned list will only contain a single result.
    pub fn match_player(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        name: impl Into<String>,
    ) -> Result<Vec<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(name.into())?,
        ));
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "matchPlayer",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&jni, res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Player::from_raw(&jni, obj)?);
        }
        Ok(new_vec)
    }
    /// Gets the plugin manager for interfacing with plugins.
    pub fn plugin_manager(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::plugin::PluginManager<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/plugin/PluginManager;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getPluginManager", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::plugin::PluginManager::from_raw(&jni, obj)
    }
    /// Gets the scheduler for managing scheduled events.
    pub fn scheduler(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::scheduler::BukkitScheduler<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/scheduler/BukkitScheduler;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getScheduler", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::scheduler::BukkitScheduler::from_raw(&jni, obj)
    }
    /// Gets a services manager.
    pub fn services_manager(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::plugin::ServicesManager<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/plugin/ServicesManager;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getServicesManager", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::plugin::ServicesManager::from_raw(&jni, obj)
    }
    /// Gets a list of all worlds on this server.
    pub fn worlds(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<Vec<crate::World<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getWorlds", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&jni, res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::World::from_raw(&jni, obj)?);
        }
        Ok(new_vec)
    }
    /// Creates or loads a world with the given name using the specified
    /// options.
    ///
    /// If the world is already loaded, it will just return the equivalent of
    /// getWorld(creator.name()).
    pub fn create_world(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        creator: impl Into<crate::WorldCreator<'mc>>,
    ) -> Result<Option<crate::World<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/WorldCreator;)Lorg/bukkit/World;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(creator.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "createWorld",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::World::from_raw(&jni, obj)?))
    }
    /// Unloads the given world.
    pub fn unload_world(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        world: impl Into<crate::World<'mc>>,
        save: bool,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/World;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Z";
        let val_2 = jni::objects::JValueGen::Bool(save.into());
        args.push(val_2);
        sig += ")Z";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "unloadWorld", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the world from the given Unique ID.
    pub fn get_world(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        uid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<Option<crate::World<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/util/UUID;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(uid.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Lorg/bukkit/World;";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getWorld", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::World::from_raw(&jni, obj)?))
    }
    /// Create a new virtual {@link WorldBorder}.
    pub fn create_world_border(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::WorldBorder<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/WorldBorder;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "createWorldBorder", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::WorldBorder::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Gets the map from the given item ID.
    pub fn get_map(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        id: i32,
    ) -> Result<Option<crate::map::MapView<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Lorg/bukkit/map/MapView;");
        let val_1 = jni::objects::JValueGen::Int(id);
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getMap",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::map::MapView::from_raw(&jni, obj)?))
    }
    /// Create a new map with an automatically assigned ID.
    pub fn create_map(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        world: impl Into<crate::World<'mc>>,
    ) -> Result<crate::map::MapView<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/World;)Lorg/bukkit/map/MapView;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "createMap",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::map::MapView::from_raw(&jni, obj)
    }
    /// Create a new explorer map targeting the closest nearby structure of a
    /// given {@link StructureType}.
    ///
    /// This method uses implementation default values for radius and
    /// findUnexplored (usually 100, true).
    pub fn create_explorer_map(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        world: impl Into<crate::World<'mc>>,
        location: impl Into<crate::Location<'mc>>,
        structure_type: impl Into<crate::StructureType<'mc>>,
        radius: std::option::Option<i32>,
        find_unexplored: std::option::Option<bool>,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/World;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/Location;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_2);
        sig += "Lorg/bukkit/StructureType;";
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(structure_type.into().jni_object().clone())
        });
        args.push(val_3);
        if let Some(a) = radius {
            sig += "I";
            let val_4 = jni::objects::JValueGen::Int(a);
            args.push(val_4);
        }
        if let Some(a) = find_unexplored {
            sig += "Z";
            let val_5 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_5);
        }
        sig += ")Lorg/bukkit/inventory/ItemStack;";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "createExplorerMap", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::inventory::ItemStack::from_raw(&jni, obj)
    }
    /// Reloads the server, refreshing settings and plugin information.
    pub fn reload(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "reload", sig.as_str(), vec![]);
        jni.translate_error(res)?;
        Ok(())
    }
    /// Reload only the Minecraft data for the server. This includes custom
    /// advancements and loot tables.
    pub fn reload_data(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "reloadData", sig.as_str(), vec![]);
        jni.translate_error(res)?;
        Ok(())
    }
    /// Returns the primary logger associated with this server instance.
    pub fn logger(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<blackboxmc_java::util::logging::JavaLogger<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/logging/Logger;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getLogger", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        blackboxmc_java::util::logging::JavaLogger::from_raw(&jni, obj)
    }
    /// Gets a {@link PluginCommand} with the given name or alias.
    pub fn get_plugin_command(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        name: impl Into<String>,
    ) -> Result<Option<crate::command::PluginCommand<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/command/PluginCommand;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(name.into())?,
        ));
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getPluginCommand",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::command::PluginCommand::from_raw(&jni, obj)?))
    }
    /// Writes loaded players to disk.
    pub fn save_players(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "savePlayers", sig.as_str(), vec![]);
        jni.translate_error(res)?;
        Ok(())
    }
    /// Dispatches a command on this server, and executes it if found.
    pub fn dispatch_command(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        sender: impl Into<crate::command::CommandSender<'mc>>,
        command_line: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/command/CommandSender;Ljava/lang/String;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(sender.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(command_line.into())?,
        ));
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "dispatchCommand",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Adds a recipe to the crafting manager.
    pub fn add_recipe(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        recipe: impl Into<crate::inventory::Recipe<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/Recipe;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(recipe.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "addRecipe",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Get a list of all recipes for a given item. The stack size is ignored
    /// in comparisons. If the durability is -1, it will match any data value.
    pub fn get_recipes_for(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        result: impl Into<crate::inventory::ItemStack<'mc>>,
    ) -> Result<Vec<crate::inventory::Recipe<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/inventory/ItemStack;)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(result.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getRecipesFor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&jni, res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::inventory::Recipe::from_raw(&jni, obj)?);
        }
        Ok(new_vec)
    }
    /// Get the {@link Recipe} for the given key.
    pub fn get_recipe(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        recipe_key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<Option<crate::inventory::Recipe<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lorg/bukkit/inventory/Recipe;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(recipe_key.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getRecipe",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::inventory::Recipe::from_raw(&jni, obj)?))
    }
    /// Get the {@link Recipe} for the list of ItemStacks provided.
    /// The list is formatted as a crafting matrix where the index follow
    /// the pattern below:
    /// <pre>
    /// [ 0 1 2 ]
    /// [ 3 4 5 ]
    /// [ 6 7 8 ]
    /// </pre>
    /// NOTE: This method will not modify the provided ItemStack array, for that, use
    /// {@link #craftItem(ItemStack[], World, Player)}.
    pub fn get_crafting_recipe(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        crafting_matrix: impl Into<crate::inventory::ItemStack<'mc>>,
        world: impl Into<crate::World<'mc>>,
    ) -> Result<Option<crate::inventory::Recipe<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from(
            "(Lorg/bukkit/inventory/ItemStack;Lorg/bukkit/World;)Lorg/bukkit/inventory/Recipe;",
        );
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(crafting_matrix.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getCraftingRecipe",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::inventory::Recipe::from_raw(&jni, obj)?))
    }
    /// Get the crafted item using the list of {@link ItemStack} provided.
    /// The list is formatted as a crafting matrix where the index follow
    /// the pattern below:
    /// <pre>
    /// [ 0 1 2 ]
    /// [ 3 4 5 ]
    /// [ 6 7 8 ]
    /// </pre>
    /// The {@link World} and {@link Player} arguments are required to fulfill the Bukkit Crafting
    /// events.
    /// Calls {@link org.bukkit.event.inventory.PrepareItemCraftEvent} to imitate the {@link Player}
    /// initiating the crafting event.
    pub fn craft_item_result(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        crafting_matrix: impl Into<crate::inventory::ItemStack<'mc>>,
        world: impl Into<crate::World<'mc>>,
        player: std::option::Option<impl Into<crate::entity::Player<'mc>>>,
    ) -> Result<crate::inventory::ItemCraftResult<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/inventory/ItemStack;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(crafting_matrix.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/World;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = player {
            sig += "Lorg/bukkit/entity/Player;";
            let val_3 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/inventory/ItemCraftResult;";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "craftItemResult", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::inventory::ItemCraftResult::from_raw(&jni, obj)
    }
    /// Get the crafted item using the list of {@link ItemStack} provided.
    /// The list is formatted as a crafting matrix where the index follow
    /// the pattern below:
    /// <pre>
    /// [ 0 1 2 ]
    /// [ 3 4 5 ]
    /// [ 6 7 8 ]
    /// </pre>
    /// The {@link World} and {@link Player} arguments are required to fulfill the Bukkit Crafting
    /// events.
    /// Calls {@link org.bukkit.event.inventory.PrepareItemCraftEvent} to imitate the {@link Player}
    /// initiating the crafting event.
    pub fn craft_item(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        crafting_matrix: impl Into<crate::inventory::ItemStack<'mc>>,
        world: impl Into<crate::World<'mc>>,
        player: std::option::Option<impl Into<crate::entity::Player<'mc>>>,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/inventory/ItemStack;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(crafting_matrix.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/World;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = player {
            sig += "Lorg/bukkit/entity/Player;";
            let val_3 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/inventory/ItemStack;";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "craftItem", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::inventory::ItemStack::from_raw(&jni, obj)
    }
    /// Get an iterator through the list of crafting recipes.
    pub fn recipe_iterator(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<blackboxmc_java::util::JavaIterator<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Iterator;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "recipeIterator", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        blackboxmc_java::util::JavaIterator::from_raw(&jni, obj)
    }
    /// Clears the list of crafting recipes.
    pub fn clear_recipes(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "clearRecipes", sig.as_str(), vec![]);
        jni.translate_error(res)?;
        Ok(())
    }
    /// Resets the list of crafting recipes to the default.
    pub fn reset_recipes(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "resetRecipes", sig.as_str(), vec![]);
        jni.translate_error(res)?;
        Ok(())
    }
    /// Remove a recipe from the server.
    /// <b>Note that removing a recipe may cause permanent loss of data
    /// associated with that recipe (eg whether it has been discovered by
    /// players).</b>
    pub fn remove_recipe(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "removeRecipe",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets a list of command aliases defined in the server properties.
    pub fn command_aliases(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<blackboxmc_java::util::JavaMap<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Map;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getCommandAliases", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        blackboxmc_java::util::JavaMap::from_raw(&jni, obj)
    }
    /// Gets the radius, in blocks, around each worlds spawn point to protect.
    pub fn spawn_radius(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getSpawnRadius", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the radius, in blocks, around each worlds spawn point to protect.
    pub fn set_spawn_radius(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        value: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(value);
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "setSpawnRadius",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        jni.translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets whether the server should send a preview of the player's chat message to the client when the player sends a message
    pub fn should_send_chat_previews(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "shouldSendChatPreviews", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether the server only allow players with Mojang-signed public key
    /// to join
    pub fn is_enforcing_secure_profiles(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "isEnforcingSecureProfiles", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether this server is allowing connections transferred from other
    /// servers.
    pub fn is_accepting_transfers(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "isAcceptingTransfers", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether the Server hide online players in server status.
    pub fn hide_online_players(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getHideOnlinePlayers", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether the Server is in online mode or not.
    pub fn online_mode(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getOnlineMode", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether this server allows flying or not.
    pub fn allow_flight(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getAllowFlight", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether the server is in hardcore mode or not.
    pub fn is_hardcore(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "isHardcore", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Shutdowns the server, stopping everything.
    pub fn shutdown(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "shutdown", sig.as_str(), vec![]);
        jni.translate_error(res)?;
        Ok(())
    }
    /// Broadcasts the specified message to every user with the given
    /// permission name.
    pub fn broadcast(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        message: impl Into<String>,
        permission: impl Into<String>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;Ljava/lang/String;)I");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(message.into())?,
        ));
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(permission.into())?,
        ));
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "broadcast",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the player by the given UUID, regardless if they are offline or
    /// online.
    ///
    /// This will return an object even if the player does not exist. To this
    /// method, all players will exist.
    pub fn get_offline_player(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        id: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<crate::OfflinePlayer<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/util/UUID;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(id.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Lorg/bukkit/OfflinePlayer;";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getOfflinePlayer", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::OfflinePlayer::from_raw(&jni, obj)
    }
    /// Creates a new {@link PlayerProfile}.
    pub fn create_player_profile(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        unique_id: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
        name: std::option::Option<impl Into<String>>,
    ) -> Result<crate::profile::PlayerProfile<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/util/UUID;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(unique_id.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = name {
            sig += "Ljava/lang/String;";
            let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                jni.new_string(a.into())?,
            ));
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/profile/PlayerProfile;";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "createPlayerProfile", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::profile::PlayerProfile::from_raw(&jni, obj)
    }
    /// Gets a set containing all current IPs that are banned.
    pub fn ipbans(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getIPBans", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        blackboxmc_java::util::JavaSet::from_raw(&jni, obj)
    }
    /// Bans the specified address from the server.
    pub fn ban_ip(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        address: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/net/InetAddress;";
        let val_1 = jni::objects::JValueGen::Object(address);
        args.push(val_1);
        sig += ")V";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "banIP", sig.as_str(), args);
        jni.translate_error(res)?;
        Ok(())
    }
    /// Unbans the specified address from the server.
    pub fn unban_ip(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        address: jni::objects::JObject<'mc>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/net/InetAddress;";
        let val_1 = jni::objects::JValueGen::Object(address);
        args.push(val_1);
        sig += ")V";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "unbanIP", sig.as_str(), args);
        jni.translate_error(res)?;
        Ok(())
    }
    /// Gets a set containing all banned players.
    pub fn banned_players(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getBannedPlayers", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        blackboxmc_java::util::JavaSet::from_raw(&jni, obj)
    }
    /// Gets a ban list for the supplied type.
    pub fn get_ban_list(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        val_type: impl Into<crate::BanListType<'mc>>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/BanList/Type;)LT;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(val_type.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getBanList",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        Ok(res.l()?)
    }
    /// Gets a set containing all player operators.
    pub fn operators(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getOperators", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        blackboxmc_java::util::JavaSet::from_raw(&jni, obj)
    }
    /// Gets the default {@link GameMode} for new players.
    pub fn default_game_mode(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::GameMode<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/GameMode;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getDefaultGameMode", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::GameMode::from_raw(&jni, obj)
    }
    /// Sets the default {@link GameMode} for new players.
    pub fn set_default_game_mode(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        mode: impl Into<crate::GameMode<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/GameMode;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(mode.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "setDefaultGameMode",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        jni.translate_error(res)?;
        Ok(())
    }
    /// Gets a {@link ConsoleCommandSender} that may be used as an input source
    /// for this server.
    pub fn console_sender(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::command::ConsoleCommandSender<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/command/ConsoleCommandSender;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getConsoleSender", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::command::ConsoleCommandSender::from_raw(&jni, obj)
    }
    /// Gets every player that has ever played on this server.
    pub fn offline_players(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::OfflinePlayer<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/OfflinePlayer;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getOfflinePlayers", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::OfflinePlayer::from_raw(&jni, obj)
    }
    /// Gets the {@link Messenger} responsible for this server.
    pub fn messenger(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::plugin::messaging::Messenger<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/plugin/messaging/Messenger;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getMessenger", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::plugin::messaging::Messenger::from_raw(&jni, obj)
    }
    /// Gets the {@link HelpMap} providing help topics for this server.
    pub fn help_map(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::help::HelpMap<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/help/HelpMap;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getHelpMap", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::help::HelpMap::from_raw(&jni, obj)
    }
    /// Creates an empty inventory of type {@link InventoryType#CHEST} with the
    /// specified size and title.
    pub fn create_inventory(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        owner: impl Into<crate::inventory::InventoryHolder<'mc>>,
        size: i32,
        title: std::option::Option<impl Into<String>>,
    ) -> Result<crate::inventory::Inventory<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/inventory/InventoryHolder;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(owner.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(size);
        args.push(val_2);
        if let Some(a) = title {
            sig += "Ljava/lang/String;";
            let val_3 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                jni.new_string(a.into())?,
            ));
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/inventory/Inventory;";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "createInventory", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::inventory::Inventory::from_raw(&jni, obj)
    }
    /// Creates an empty merchant.
    pub fn create_merchant(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        title: impl Into<String>,
    ) -> Result<crate::inventory::Merchant<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/inventory/Merchant;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(title.into())?,
        ));
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "createMerchant",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::inventory::Merchant::from_raw(&jni, obj)
    }
    /// Gets the amount of consecutive neighbor updates before skipping
    /// additional ones.
    pub fn max_chained_neighbor_updates(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getMaxChainedNeighborUpdates", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets user-specified limit for number of monsters that can spawn in a chunk.
    pub fn monster_spawn_limit(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getMonsterSpawnLimit", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets user-specified limit for number of animals that can spawn in a chunk.
    pub fn animal_spawn_limit(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getAnimalSpawnLimit", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets user-specified limit for number of water animals that can spawn in a chunk.
    pub fn water_animal_spawn_limit(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getWaterAnimalSpawnLimit", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets user-specified limit for number of water ambient mobs that can spawn in a chunk.
    pub fn water_ambient_spawn_limit(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getWaterAmbientSpawnLimit", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Get user-specified limit for number of water creature underground that can spawn in a chunk.
    pub fn water_underground_creature_spawn_limit(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getWaterUndergroundCreatureSpawnLimit",
            sig.as_str(),
            vec![],
        );
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets user-specified limit for number of ambient mobs that can spawn in a chunk.
    pub fn ambient_spawn_limit(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getAmbientSpawnLimit", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets user-specified limit for number of {@link SpawnCategory} mobs that can spawn in
    /// a chunk.
    /// <b>Note: the {@link SpawnCategory#MISC} are not consider.</b>
    pub fn get_spawn_limit(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        spawn_category: impl Into<crate::entity::SpawnCategory<'mc>>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/SpawnCategory;)I");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(spawn_category.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getSpawnLimit",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    /// Checks the current thread against the expected primary thread for the
    /// server.
    ///
    /// <b>Note:</b> this method should not be used to indicate the current
    /// synchronized state of the runtime. A current thread matching the main
    /// thread indicates that it is synchronized, but a mismatch <b>does not
    /// preclude</b> the same assumption.
    pub fn is_primary_thread(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "isPrimaryThread", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the message that is displayed on the server list.
    pub fn motd(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getMotd", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(jni
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Set the message that is displayed on the server list.
    pub fn set_motd(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        motd: impl Into<String>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(motd.into())?,
        ));
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "setMotd",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        jni.translate_error(res)?;
        Ok(())
    }
    /// Gets the default message that is displayed when the server is stopped.
    pub fn shutdown_message(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<Option<String>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getShutdownMessage", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(
            jni.get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
                .to_string_lossy()
                .to_string(),
        ))
    }
    /// Gets the current warning state for the server.
    pub fn warning_state(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::WarningWarningState<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Warning/WarningState;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getWarningState", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::WarningWarningState::from_raw(&jni, obj)
    }
    /// Gets the instance of the item factory (for {@link ItemMeta}).
    pub fn item_factory(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::inventory::ItemFactory<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/inventory/ItemFactory;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getItemFactory", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::inventory::ItemFactory::from_raw(&jni, obj)
    }
    /// Gets the instance of the entity factory (for {@link EntitySnapshot}).
    pub fn entity_factory(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::entity::EntityFactory<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/EntityFactory;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getEntityFactory", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::entity::EntityFactory::from_raw(&jni, obj)
    }
    /// Gets the instance of the scoreboard manager.
    ///
    /// This will only exist after the first world has loaded.
    pub fn scoreboard_manager(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<Option<crate::scoreboard::ScoreboardManager<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/scoreboard/ScoreboardManager;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getScoreboardManager", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::scoreboard::ScoreboardManager::from_raw(
            &jni, obj,
        )?))
    }
    /// Get (or create) a new {@link Criteria} by its name.
    pub fn get_scoreboard_criteria(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        name: impl Into<String>,
    ) -> Result<crate::scoreboard::Criteria<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/scoreboard/Criteria;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(name.into())?,
        ));
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getScoreboardCriteria",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::scoreboard::Criteria::from_raw(&jni, obj)
    }
    /// Gets an instance of the server's default server-icon.
    pub fn server_icon(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<Option<crate::util::CachedServerIcon<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/CachedServerIcon;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getServerIcon", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::util::CachedServerIcon::from_raw(&jni, obj)?))
    }
    /// Creates a cached server-icon for the specific image.
    ///
    /// Size and type are implementation defined. An incompatible file is
    /// guaranteed to throw an implementation-defined {@link Exception}.
    pub fn load_server_icon(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        image: jni::objects::JObject<'mc>,
    ) -> Result<crate::util::CachedServerIcon<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/awt/image/BufferedImage;";
        let val_1 = jni::objects::JValueGen::Object(image);
        args.push(val_1);
        sig += ")Lorg/bukkit/util/CachedServerIcon;";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "loadServerIcon", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::util::CachedServerIcon::from_raw(&jni, obj)
    }
    /// Set the idle kick timeout. Any players idle for the specified amount of
    /// time will be automatically kicked.
    ///
    /// A value of 0 will disable the idle kick timeout.
    pub fn set_idle_timeout(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        threshold: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(threshold);
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "setIdleTimeout",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        jni.translate_error(res)?;
        Ok(())
    }
    /// Gets the idle kick timeout.
    pub fn idle_timeout(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getIdleTimeout", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }
    /// Create a ChunkData for use in a generator.
    /// See {@link ChunkGenerator#generateChunkData(org.bukkit.World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)}
    pub fn create_chunk_data(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        world: impl Into<crate::World<'mc>>,
    ) -> Result<crate::generator::ChunkGeneratorChunkData<'mc>, Box<dyn std::error::Error>> {
        let sig =
            String::from("(Lorg/bukkit/World;)Lorg/bukkit/generator/ChunkGenerator/ChunkData;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "createChunkData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::generator::ChunkGeneratorChunkData::from_raw(&jni, obj)
    }
    /// Creates a boss bar instance to display to players. The progress defaults
    /// to 1.0.
    ///
    /// This instance is added to the persistent storage of the server and will
    /// be editable by commands and restored after restart.
    pub fn create_boss_bar(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        key: impl Into<crate::NamespacedKey<'mc>>,
        title: impl Into<String>,
        color: impl Into<crate::boss::BarColor<'mc>>,
        style: impl Into<crate::boss::BarStyle<'mc>>,
        flags: std::option::Option<impl Into<crate::boss::BarFlag<'mc>>>,
    ) -> Result<crate::boss::KeyedBossBar<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/NamespacedKey;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Ljava/lang/String;";
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(title.into())?,
        ));
        args.push(val_2);
        sig += "Lorg/bukkit/boss/BarColor;";
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(color.into().jni_object().clone())
        });
        args.push(val_3);
        sig += "Lorg/bukkit/boss/BarStyle;";
        let val_4 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(style.into().jni_object().clone())
        });
        args.push(val_4);
        if let Some(a) = flags {
            sig += "Lorg/bukkit/boss/BarFlag;";
            let val_5 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_5);
        }
        sig += ")Lorg/bukkit/boss/KeyedBossBar;";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "createBossBar", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::boss::KeyedBossBar::from_raw(&jni, obj)
    }
    /// Gets an unmodifiable iterator through all persistent bossbars.
    /// <ul>
    /// <li><b>not</b> bound to a {@link org.bukkit.entity.Boss}</li>
    /// <li>
    /// <b>not</b> created using
    /// {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
    /// </li>
    /// </ul>
    /// e.g. bossbars created using the bossbar command
    pub fn boss_bars(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<blackboxmc_java::util::JavaIterator<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Iterator;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getBossBars", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        blackboxmc_java::util::JavaIterator::from_raw(&jni, obj)
    }
    /// Gets the {@link KeyedBossBar} specified by this key.
    /// <ul>
    /// <li><b>not</b> bound to a {@link org.bukkit.entity.Boss}</li>
    /// <li>
    /// <b>not</b> created using
    /// {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
    /// </li>
    /// </ul>
    /// e.g. bossbars created using the bossbar command
    pub fn get_boss_bar(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<Option<crate::boss::KeyedBossBar<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lorg/bukkit/boss/KeyedBossBar;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getBossBar",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::boss::KeyedBossBar::from_raw(&jni, obj)?))
    }
    /// Removes a {@link KeyedBossBar} specified by this key.
    /// <ul>
    /// <li><b>not</b> bound to a {@link org.bukkit.entity.Boss}</li>
    /// <li>
    /// <b>not</b> created using
    /// {@link #createBossBar(String, BarColor, BarStyle, BarFlag...)}
    /// </li>
    /// </ul>
    /// e.g. bossbars created using the bossbar command
    pub fn remove_boss_bar(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "removeBossBar",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets an entity on the server by its UUID
    pub fn get_entity(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        uuid: impl Into<blackboxmc_java::util::JavaUUID<'mc>>,
    ) -> Result<Option<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/UUID;)Lorg/bukkit/entity/Entity;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(uuid.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getEntity",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::entity::Entity::from_raw(&jni, obj)?))
    }
    /// Get the advancement specified by this key.
    pub fn get_advancement(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<Option<crate::advancement::Advancement<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lorg/bukkit/advancement/Advancement;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getAdvancement",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::advancement::Advancement::from_raw(&jni, obj)?))
    }
    /// Get an iterator through all advancements. Advancements cannot be removed
    /// from this iterator,
    pub fn advancement_iterator(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<blackboxmc_java::util::JavaIterator<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Iterator;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "advancementIterator", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        blackboxmc_java::util::JavaIterator::from_raw(&jni, obj)
    }
    /// Creates a new {@link BlockData} instance for the specified Material, with
    /// all properties initialized to unspecified defaults, except for those
    /// provided in data.
    pub fn create_block_data(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        material: impl Into<crate::Material<'mc>>,
        data: std::option::Option<impl Into<String>>,
    ) -> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(material.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = data {
            sig += "Ljava/lang/String;";
            let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                jni.new_string(a.into())?,
            ));
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/block/data/BlockData;";
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "createBlockData", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::block::data::BlockData::from_raw(&jni, obj)
    }
    /// Gets a tag which has already been defined within the server. Plugins are
    /// suggested to use the concrete tags in {@link Tag} rather than this method
    /// which makes no guarantees about which tags are available, and may also be
    /// less performant due to lack of caching.
    ///
    /// Tags will be searched for in an implementation specific manner, but a
    /// path consisting of namespace/tags/registry/key is expected.
    ///
    /// Server implementations are allowed to handle only the registries
    /// indicated in {@link Tag}.
    pub fn get_tag(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        registry: impl Into<String>,
        tag: impl Into<crate::NamespacedKey<'mc>>,
        clazz: jni::objects::JClass<'mc>,
    ) -> Result<Option<crate::Tag<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from(
            "(Ljava/lang/String;Lorg/bukkit/NamespacedKey;Ljava/lang/Class;)Lorg/bukkit/Tag;",
        );
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(registry.into())?,
        ));
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(tag.into().jni_object().clone())
        });
        let val_3 = jni::objects::JValueGen::Object(clazz.into());
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getTag",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::Tag::from_raw(&jni, obj)?))
    }
    /// Gets the specified {@link LootTable}.
    pub fn get_loot_table(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<Option<crate::loot::LootTable<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lorg/bukkit/loot/LootTable;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getLootTable",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::loot::LootTable::from_raw(&jni, obj)?))
    }
    /// Selects entities using the given Vanilla selector.
    ///
    /// No guarantees are made about the selector format, other than they match
    /// the Vanilla format for the active Minecraft version.
    ///
    /// Usually a selector will start with '@', unless selecting a Player in
    /// which case it may simply be the Player's name or UUID.
    ///
    /// Note that in Vanilla, elevated permissions are usually required to use
    /// '@' selectors, but this method should not check such permissions from the
    /// sender.
    pub fn select_entities(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        sender: impl Into<crate::command::CommandSender<'mc>>,
        selector: impl Into<String>,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let sig =
            String::from("(Lorg/bukkit/command/CommandSender;Ljava/lang/String;)Ljava/util/List;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(sender.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(selector.into())?,
        ));
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "selectEntities",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = jni.translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&jni, res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&jni, obj)?);
        }
        Ok(new_vec)
    }
    /// Gets the structure manager for loading and saving structures.
    pub fn structure_manager(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::structure::StructureManager<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/structure/StructureManager;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getStructureManager", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::structure::StructureManager::from_raw(&jni, obj)
    }
    /// Returns the registry for the given class.
    ///
    /// If no registry is present for the given class null will be returned.
    ///
    /// Depending on the implementation not every registry present in
    /// {@link Registry} will be returned by this method.
    pub fn get_registry(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        t_class: jni::objects::JClass<'mc>,
    ) -> Result<Option<crate::Registry<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/Class;)Lorg/bukkit/Registry;");
        let val_1 = jni::objects::JValueGen::Object(t_class.into());
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getRegistry",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::Registry::from_raw(&jni, obj)?))
    }
    #[deprecated]

    pub fn get_unsafe(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::UnsafeValues<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/UnsafeValues;");
        let cls = jni.find_class("org/bukkit/Bukkit");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getUnsafe", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::UnsafeValues::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum Sound<'mc> {}
impl<'mc> std::fmt::Display for Sound<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> Sound<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Sound<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Sound");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Sound;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct SoundStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Sound<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for Sound<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Sound from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Sound")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Sound object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for SoundStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SoundStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SoundStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Sound")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SoundStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SoundStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let cls = jni.find_class("org/bukkit/Sound");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Sound::from_raw(&jni, obj)
    }

    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum CoalType<'mc> {}
impl<'mc> std::fmt::Display for CoalType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> CoalType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<CoalType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/CoalType");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/CoalType;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct CoalTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for CoalType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for CoalType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate CoalType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/CoalType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a CoalType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for CoalTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for CoalTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate CoalTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/CoalType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a CoalTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> CoalTypeStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::CoalType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/CoalType;");
        let cls = jni.find_class("org/bukkit/CoalType");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::CoalType::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Gets the associated data value representing this type of coal
    pub fn data(&self) -> Result<i8, Box<dyn std::error::Error>> {
        let sig = String::from("()B");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getData", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.b()?)
    }
    #[deprecated]
    /// Gets the type of coal with the given data value
    pub fn get_by_data(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        data: i8,
    ) -> Result<Option<crate::CoalType<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(B)Lorg/bukkit/CoalType;");
        let val_1 = jni::objects::JValueGen::Byte(data);
        let cls = jni.find_class("org/bukkit/CoalType");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::CoalType::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum SoundCategory<'mc> {}
impl<'mc> std::fmt::Display for SoundCategory<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> SoundCategory<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<SoundCategory<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/SoundCategory");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/SoundCategory;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct SoundCategoryStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SoundCategory<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for SoundCategory<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SoundCategory from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/SoundCategory")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SoundCategory object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for SoundCategoryStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SoundCategoryStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate SoundCategoryStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/SoundCategory")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SoundCategoryStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SoundCategoryStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::SoundCategory<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/SoundCategory;");
        let cls = jni.find_class("org/bukkit/SoundCategory");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::SoundCategory::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum CropState<'mc> {}
impl<'mc> std::fmt::Display for CropState<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> CropState<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<CropState<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/CropState");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/CropState;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct CropStateStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for CropState<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for CropState<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate CropState from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/CropState")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a CropState object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for CropStateStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for CropStateStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate CropStateStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/CropState")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a CropStateStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> CropStateStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::CropState<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/CropState;");
        let cls = jni.find_class("org/bukkit/CropState");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::CropState::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Gets the associated data value representing this growth state
    pub fn data(&self) -> Result<i8, Box<dyn std::error::Error>> {
        let sig = String::from("()B");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getData", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.b()?)
    }
    #[deprecated]
    /// Gets the CropState with the given data value
    pub fn get_by_data(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        data: i8,
    ) -> Result<Option<crate::CropState<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(B)Lorg/bukkit/CropState;");
        let val_1 = jni::objects::JValueGen::Byte(data);
        let cls = jni.find_class("org/bukkit/CropState");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::CropState::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum Effect<'mc> {}
impl<'mc> std::fmt::Display for Effect<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> Effect<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Effect<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Effect");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Effect;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct EffectStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Effect<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for Effect<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Effect from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Effect")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Effect object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for EffectStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EffectStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate EffectStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Effect")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EffectStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EffectStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::Effect<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Effect;");
        let cls = jni.find_class("org/bukkit/Effect");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Effect::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Gets the ID for this effect.
    pub fn id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getId", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn get_type(&self) -> Result<crate::EffectType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Effect/Type;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::EffectType::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    #[deprecated]
    /// Gets the Effect associated with the given ID.
    pub fn get_by_id(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        id: i32,
    ) -> Result<Option<crate::Effect<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Lorg/bukkit/Effect;");
        let val_1 = jni::objects::JValueGen::Int(id);
        let cls = jni.find_class("org/bukkit/Effect");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getById",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::Effect::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum EffectType<'mc> {}
impl<'mc> std::fmt::Display for EffectType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> EffectType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<EffectType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Effect/Type");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Effect/Type;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct EffectTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EffectType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for EffectType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate EffectType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Effect/Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EffectType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for EffectTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EffectTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate EffectTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Effect/Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EffectTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EffectTypeStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::EffectType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Effect/Type;");
        let cls = jni.find_class("org/bukkit/Effect/Type");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::EffectType::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum NetherWartsState<'mc> {}
impl<'mc> std::fmt::Display for NetherWartsState<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> NetherWartsState<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<NetherWartsState<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/NetherWartsState");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/NetherWartsState;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct NetherWartsStateStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for NetherWartsState<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for NetherWartsState<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate NetherWartsState from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/NetherWartsState")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a NetherWartsState object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for NetherWartsStateStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for NetherWartsStateStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate NetherWartsStateStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/NetherWartsState")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a NetherWartsStateStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> NetherWartsStateStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::NetherWartsState<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NetherWartsState;");
        let cls = jni.find_class("org/bukkit/NetherWartsState");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::NetherWartsState::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct Keyed<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Keyed<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Keyed<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Keyed from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Keyed")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Keyed object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Keyed<'mc> {
    /// Return the namespaced identifier for this object.
    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct Utility<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Utility<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Utility<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Utility from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Utility")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Utility object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Utility<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct FireworkEffect<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for FireworkEffect<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FireworkEffect<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate FireworkEffect from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/FireworkEffect")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FireworkEffect object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> FireworkEffect<'mc> {
    /// Construct a firework effect.
    pub fn builder(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::FireworkEffectBuilder<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/FireworkEffect/Builder;");
        let cls = jni.find_class("org/bukkit/FireworkEffect");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "builder", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::FireworkEffectBuilder::from_raw(&jni, obj)
    }
    /// Get whether the firework effect flickers.
    pub fn has_flicker(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "hasFlicker", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Get whether the firework effect has a trail.
    pub fn has_trail(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hasTrail", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Get the primary colors of the firework effect.
    pub fn colors(&self) -> Result<Vec<crate::Color<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getColors", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.0, res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::Color::from_raw(&self.0, obj)?);
        }
        Ok(new_vec)
    }
    /// Get the fade colors of the firework effect.
    pub fn fade_colors(&self) -> Result<Vec<crate::Color<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFadeColors", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.0, res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::Color::from_raw(&self.0, obj)?);
        }
        Ok(new_vec)
    }
    /// Get the type of the firework effect.
    pub fn get_type(&self) -> Result<crate::FireworkEffectType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/FireworkEffect/Type;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::FireworkEffectType::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn deserialize(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        map: impl Into<blackboxmc_java::util::JavaMap<'mc>>,
    ) -> Result<
        crate::configuration::serialization::ConfigurationSerializable<'mc>,
        Box<dyn std::error::Error>,
    > {
        let sig = String::from(
            "(Ljava/util/Map;)Lorg/bukkit/configuration/serialization/ConfigurationSerializable;",
        );
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(map.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/FireworkEffect");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "deserialize",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::configuration::serialization::ConfigurationSerializable::from_raw(&jni, obj)
    }

    pub fn serialize(
        &self,
    ) -> Result<blackboxmc_java::util::JavaMap<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Map;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "serialize", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaMap::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    #[doc(hidden)]
    pub fn internal_to_string(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "toString", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn hash_code(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hashCode", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn equals(
        &self,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/Object;)Z");
        let val_1 = jni::objects::JValueGen::Object(obj);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "equals",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}

impl<'mc> std::string::ToString for FireworkEffect<'mc> {
    fn to_string(&self) -> String {
        match &self.internal_to_string() {
            Ok(a) => a.clone(),
            Err(err) => format!("Error calling FireworkEffect.toString: {}", err),
        }
    }
}

impl<'mc> Into<crate::configuration::serialization::ConfigurationSerializable<'mc>>
    for FireworkEffect<'mc>
{
    fn into(self) -> crate::configuration::serialization::ConfigurationSerializable<'mc> {
        crate::configuration::serialization::ConfigurationSerializable::from_raw(&self.jni_ref(), self.1).expect("Error converting FireworkEffect into crate::configuration::serialization::ConfigurationSerializable")
    }
}
pub enum FireworkEffectType<'mc> {}
impl<'mc> std::fmt::Display for FireworkEffectType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> FireworkEffectType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<FireworkEffectType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/FireworkEffect/Type");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/FireworkEffect/Type;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct FireworkEffectTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for FireworkEffectType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for FireworkEffectType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate FireworkEffectType from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/FireworkEffect/Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FireworkEffectType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for FireworkEffectTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FireworkEffectTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate FireworkEffectTypeStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/FireworkEffect/Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FireworkEffectTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> FireworkEffectTypeStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::FireworkEffectType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/FireworkEffect/Type;");
        let cls = jni.find_class("org/bukkit/FireworkEffect/Type");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::FireworkEffectType::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct FireworkEffectBuilder<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for FireworkEffectBuilder<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FireworkEffectBuilder<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate FireworkEffectBuilder from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/FireworkEffect/Builder")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FireworkEffectBuilder object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> FireworkEffectBuilder<'mc> {
    /// Specify the type of the firework effect.
    pub fn with(
        &self,
        val_type: impl Into<crate::FireworkEffectType<'mc>>,
    ) -> Result<crate::FireworkEffectBuilder<'mc>, Box<dyn std::error::Error>> {
        let sig =
            String::from("(Lorg/bukkit/FireworkEffect/Type;)Lorg/bukkit/FireworkEffect/Builder;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(val_type.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "with",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::FireworkEffectBuilder::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Add a flicker to the firework effect.
    pub fn with_flicker(
        &self,
    ) -> Result<crate::FireworkEffectBuilder<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/FireworkEffect/Builder;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "withFlicker", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::FireworkEffectBuilder::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Set whether the firework effect should flicker.
    pub fn flicker(
        &self,
        flicker: bool,
    ) -> Result<crate::FireworkEffectBuilder<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Z)Lorg/bukkit/FireworkEffect/Builder;");
        let val_1 = jni::objects::JValueGen::Bool(flicker.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "flicker",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::FireworkEffectBuilder::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Add a trail to the firework effect.
    pub fn with_trail(
        &self,
    ) -> Result<crate::FireworkEffectBuilder<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/FireworkEffect/Builder;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "withTrail", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::FireworkEffectBuilder::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Set whether the firework effect should have a trail.
    pub fn trail(
        &self,
        trail: bool,
    ) -> Result<crate::FireworkEffectBuilder<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Z)Lorg/bukkit/FireworkEffect/Builder;");
        let val_1 = jni::objects::JValueGen::Bool(trail.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "trail",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::FireworkEffectBuilder::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Create a {@link FireworkEffect} from the current contents of this
    /// builder.
    ///
    /// To successfully build, you must have specified at least one color.
    pub fn build(&self) -> Result<crate::FireworkEffect<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/FireworkEffect;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "build", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::FireworkEffect::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum GrassSpecies<'mc> {}
impl<'mc> std::fmt::Display for GrassSpecies<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> GrassSpecies<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<GrassSpecies<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/GrassSpecies");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/GrassSpecies;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct GrassSpeciesStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for GrassSpecies<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for GrassSpecies<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate GrassSpecies from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/GrassSpecies")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a GrassSpecies object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for GrassSpeciesStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for GrassSpeciesStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate GrassSpeciesStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/GrassSpecies")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a GrassSpeciesStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> GrassSpeciesStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::GrassSpecies<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/GrassSpecies;");
        let cls = jni.find_class("org/bukkit/GrassSpecies");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::GrassSpecies::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Gets the associated data value representing this species
    pub fn data(&self) -> Result<i8, Box<dyn std::error::Error>> {
        let sig = String::from("()B");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getData", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.b()?)
    }
    #[deprecated]
    /// Gets the GrassSpecies with the given data value
    pub fn get_by_data(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        data: i8,
    ) -> Result<Option<crate::GrassSpecies<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(B)Lorg/bukkit/GrassSpecies;");
        let val_1 = jni::objects::JValueGen::Byte(data);
        let cls = jni.find_class("org/bukkit/GrassSpecies");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::GrassSpecies::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct UnsafeValues<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for UnsafeValues<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for UnsafeValues<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate UnsafeValues from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/UnsafeValues")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a UnsafeValues object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> UnsafeValues<'mc> {
    pub fn to_legacy(
        &self,
        material: impl Into<crate::Material<'mc>>,
    ) -> Result<crate::Material<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Material;)Lorg/bukkit/Material;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(material.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "toLegacy",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Material::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn from_legacy(
        &self,
        material: impl Into<crate::Material<'mc>>,
        data: std::option::Option<i8>,
    ) -> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Material;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(material.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = data {
            sig += "B";
            let val_2 = jni::objects::JValueGen::Byte(a);
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/block/data/BlockData;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "fromLegacy", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::data::BlockData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn get_material(
        &self,
        material: impl Into<String>,
        version: i32,
    ) -> Result<crate::Material<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;I)Lorg/bukkit/Material;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(material.into())?,
        ));
        let val_2 = jni::objects::JValueGen::Int(version);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaterial",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Material::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn data_version(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDataVersion", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn modify_item_stack(
        &self,
        stack: impl Into<crate::inventory::ItemStack<'mc>>,
        arguments: impl Into<String>,
    ) -> Result<crate::inventory::ItemStack<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from(
            "(Lorg/bukkit/inventory/ItemStack;Ljava/lang/String;)Lorg/bukkit/inventory/ItemStack;",
        );
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(stack.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(arguments.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "modifyItemStack",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::ItemStack::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn check_supported(
        &self,
        pdf: impl Into<crate::plugin::PluginDescriptionFile<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/plugin/PluginDescriptionFile;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(pdf.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "checkSupported",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn process_class(
        &self,
        pdf: impl Into<crate::plugin::PluginDescriptionFile<'mc>>,
        path: impl Into<String>,
        clazz: i8,
    ) -> Result<i8, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/plugin/PluginDescriptionFile;Ljava/lang/String;B)B");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(pdf.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(path.into())?,
        ));
        let val_3 = jni::objects::JValueGen::Byte(clazz);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "processClass",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.b()?)
    }
    /// Load an advancement represented by the specified string into the server.
    /// The advancement format is governed by Minecraft and has no specified
    /// layout.
    ///
    /// It is currently a JSON object, as described by the <a href="https://minecraft.wiki/w/Advancements">Minecraft wiki</a>.
    ///
    /// Loaded advancements will be stored and persisted across server restarts
    /// and reloads.
    ///
    /// Callers should be prepared for {@link Exception} to be thrown.
    pub fn load_advancement(
        &self,
        key: impl Into<crate::NamespacedKey<'mc>>,
        advancement: impl Into<String>,
    ) -> Result<crate::advancement::Advancement<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from(
            "(Lorg/bukkit/NamespacedKey;Ljava/lang/String;)Lorg/bukkit/advancement/Advancement;",
        );
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(advancement.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "loadAdvancement",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::advancement::Advancement::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Delete an advancement which was loaded and saved by
    /// {@link #loadAdvancement(org.bukkit.NamespacedKey, java.lang.String)}.
    ///
    /// This method will only remove advancement from persistent storage. It
    /// should be accompanied by a call to {@link Server#reloadData()} in order
    /// to fully remove it from the running instance.
    pub fn remove_advancement(
        &self,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removeAdvancement",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn get_default_attribute_modifiers(
        &self,
        material: impl Into<crate::Material<'mc>>,
        slot: impl Into<crate::inventory::EquipmentSlot<'mc>>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Material;Lorg/bukkit/inventory/EquipmentSlot;)Lcom/google/common/collect/Multimap;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(material.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(slot.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDefaultAttributeModifiers",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }

    pub fn get_creative_category(
        &self,
        material: impl Into<crate::Material<'mc>>,
    ) -> Result<crate::inventory::CreativeCategory<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Material;)Lorg/bukkit/inventory/CreativeCategory;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(material.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCreativeCategory",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::inventory::CreativeCategory::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn get_block_translation_key(
        &self,
        material: impl Into<crate::Material<'mc>>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Material;)Ljava/lang/String;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(material.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBlockTranslationKey",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn get_item_translation_key(
        &self,
        material: impl Into<crate::Material<'mc>>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Material;)Ljava/lang/String;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(material.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getItemTranslationKey",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn get_translation_key(
        &self,
        attribute: impl Into<crate::attribute::Attribute<'mc>>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/attribute/Attribute;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(attribute.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Ljava/lang/String;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getTranslationKey", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn get_feature_flag(
        &self,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<Option<crate::FeatureFlag<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lorg/bukkit/FeatureFlag;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getFeatureFlag",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::FeatureFlag::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    #[deprecated]
    /// Do not use, method will get removed, and the plugin won't run
    pub fn get_internal_potion_data(
        &self,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<crate::potion::PotionTypeInternalPotionData<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from(
            "(Lorg/bukkit/NamespacedKey;)Lorg/bukkit/potion/PotionType/InternalPotionData;",
        );
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getInternalPotionData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::potion::PotionTypeInternalPotionData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn get_damage_effect(
        &self,
        key: impl Into<String>,
    ) -> Result<Option<crate::damage::DamageEffect<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/damage/DamageEffect;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(key.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getDamageEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::damage::DamageEffect::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Create a new {@link DamageSource.Builder}.
    pub fn create_damage_source_builder(
        &self,
        damage_type: impl Into<crate::damage::DamageType<'mc>>,
    ) -> Result<crate::damage::DamageSourceBuilder<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from(
            "(Lorg/bukkit/damage/DamageType;)Lorg/bukkit/damage/DamageSource/Builder;",
        );
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(damage_type.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "createDamageSourceBuilder",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::damage::DamageSourceBuilder::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn get(
        &self,
        registry: impl Into<crate::Registry<'mc>>,
        key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Registry;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(registry.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/NamespacedKey;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(key.into().jni_object().clone())
        });
        args.push(val_2);
        sig += ")LB;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "get", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum TreeSpecies<'mc> {}
impl<'mc> std::fmt::Display for TreeSpecies<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> TreeSpecies<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<TreeSpecies<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/TreeSpecies");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/TreeSpecies;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct TreeSpeciesStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for TreeSpecies<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for TreeSpecies<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate TreeSpecies from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/TreeSpecies")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TreeSpecies object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for TreeSpeciesStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TreeSpeciesStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate TreeSpeciesStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/TreeSpecies")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TreeSpeciesStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> TreeSpeciesStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::TreeSpecies<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/TreeSpecies;");
        let cls = jni.find_class("org/bukkit/TreeSpecies");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::TreeSpecies::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Gets the associated data value representing this species
    pub fn data(&self) -> Result<i8, Box<dyn std::error::Error>> {
        let sig = String::from("()B");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getData", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.b()?)
    }
    #[deprecated]
    /// Gets the TreeSpecies with the given data value
    pub fn get_by_data(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        data: i8,
    ) -> Result<Option<crate::TreeSpecies<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(B)Lorg/bukkit/TreeSpecies;");
        let val_1 = jni::objects::JValueGen::Byte(data);
        let cls = jni.find_class("org/bukkit/TreeSpecies");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::TreeSpecies::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum HeightMap<'mc> {}
impl<'mc> std::fmt::Display for HeightMap<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> HeightMap<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<HeightMap<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/HeightMap");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/HeightMap;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct HeightMapStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for HeightMap<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for HeightMap<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate HeightMap from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/HeightMap")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a HeightMap object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for HeightMapStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for HeightMapStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate HeightMapStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/HeightMap")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a HeightMapStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> HeightMapStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::HeightMap<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/HeightMap;");
        let cls = jni.find_class("org/bukkit/HeightMap");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::HeightMap::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum PortalType<'mc> {}
impl<'mc> std::fmt::Display for PortalType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> PortalType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<PortalType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/PortalType");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/PortalType;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct PortalTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for PortalType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for PortalType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate PortalType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/PortalType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PortalType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for PortalTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for PortalTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate PortalTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/PortalType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a PortalTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> PortalTypeStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::PortalType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/PortalType;");
        let cls = jni.find_class("org/bukkit/PortalType");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::PortalType::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct BanList<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for BanList<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for BanList<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate BanList from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/BanList")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a BanList object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> BanList<'mc> {
    /// Gets a {@link BanEntry} by target.
    pub fn get_ban_entry(
        &self,
        target: jni::objects::JObject<'mc>,
    ) -> Result<Option<crate::BanEntry<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "LT;";
        let val_1 = jni::objects::JValueGen::Object(target);
        args.push(val_1);
        sig += ")Lorg/bukkit/BanEntry;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBanEntry", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::BanEntry::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Adds a ban to this list. If a previous ban exists, this will
    /// update the previous entry.
    pub fn add_ban(
        &self,
        target: jni::objects::JObject<'mc>,
        reason: impl Into<String>,
        duration: jni::objects::JObject<'mc>,
        source: impl Into<String>,
    ) -> Result<Option<crate::BanEntry<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "LT;";
        let val_1 = jni::objects::JValueGen::Object(target);
        args.push(val_1);
        sig += "Ljava/lang/String;";
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(reason.into())?,
        ));
        args.push(val_2);
        sig += "Ljava/time/Duration;";
        let val_3 = jni::objects::JValueGen::Object(duration);
        args.push(val_3);
        sig += "Ljava/lang/String;";
        let val_4 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(source.into())?,
        ));
        args.push(val_4);
        sig += ")Lorg/bukkit/BanEntry;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "addBan", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::BanEntry::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    #[deprecated]
    /// Gets a set containing every {@link BanEntry} in this list.
    pub fn ban_entries(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBanEntries", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets a set containing every {@link BanEntry} in this list.
    pub fn entries(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getEntries", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    #[deprecated]
    /// Gets if a {@link BanEntry} exists for the target, indicating an active ban status.
    pub fn is_banned(&self, target: impl Into<String>) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(target.into())?,
        ));
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBanned", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]
    /// Removes the specified target from this list, therefore indicating a "not banned" status.
    pub fn pardon(&self, target: impl Into<String>) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(target.into())?,
        ));
        args.push(val_1);
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "pardon", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum BanListType<'mc> {}
impl<'mc> std::fmt::Display for BanListType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> BanListType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<BanListType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/BanList/Type");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/BanList/Type;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct BanListTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for BanListType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for BanListType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate BanListType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/BanList/Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a BanListType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for BanListTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for BanListTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate BanListTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/BanList/Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a BanListTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> BanListTypeStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::BanListType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/BanList/Type;");
        let cls = jni.find_class("org/bukkit/BanList/Type");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::BanListType::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum MusicInstrument<'mc> {
    PonderGoatHorn { inner: MusicInstrumentStruct<'mc> },
    SingGoatHorn { inner: MusicInstrumentStruct<'mc> },
    SeekGoatHorn { inner: MusicInstrumentStruct<'mc> },
    FeelGoatHorn { inner: MusicInstrumentStruct<'mc> },
    AdmireGoatHorn { inner: MusicInstrumentStruct<'mc> },
    CallGoatHorn { inner: MusicInstrumentStruct<'mc> },
    YearnGoatHorn { inner: MusicInstrumentStruct<'mc> },
    DreamGoatHorn { inner: MusicInstrumentStruct<'mc> },
}
impl<'mc> std::fmt::Display for MusicInstrument<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MusicInstrument::PonderGoatHorn { .. } => f.write_str("PONDER_GOAT_HORN"),
            MusicInstrument::SingGoatHorn { .. } => f.write_str("SING_GOAT_HORN"),
            MusicInstrument::SeekGoatHorn { .. } => f.write_str("SEEK_GOAT_HORN"),
            MusicInstrument::FeelGoatHorn { .. } => f.write_str("FEEL_GOAT_HORN"),
            MusicInstrument::AdmireGoatHorn { .. } => f.write_str("ADMIRE_GOAT_HORN"),
            MusicInstrument::CallGoatHorn { .. } => f.write_str("CALL_GOAT_HORN"),
            MusicInstrument::YearnGoatHorn { .. } => f.write_str("YEARN_GOAT_HORN"),
            MusicInstrument::DreamGoatHorn { .. } => f.write_str("DREAM_GOAT_HORN"),
        }
    }
}

impl<'mc> MusicInstrument<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<MusicInstrument<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/MusicInstrument");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/MusicInstrument;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "PONDER_GOAT_HORN" => Ok(MusicInstrument::PonderGoatHorn {
                inner: MusicInstrumentStruct::from_raw(env, obj)?,
            }),
            "SING_GOAT_HORN" => Ok(MusicInstrument::SingGoatHorn {
                inner: MusicInstrumentStruct::from_raw(env, obj)?,
            }),
            "SEEK_GOAT_HORN" => Ok(MusicInstrument::SeekGoatHorn {
                inner: MusicInstrumentStruct::from_raw(env, obj)?,
            }),
            "FEEL_GOAT_HORN" => Ok(MusicInstrument::FeelGoatHorn {
                inner: MusicInstrumentStruct::from_raw(env, obj)?,
            }),
            "ADMIRE_GOAT_HORN" => Ok(MusicInstrument::AdmireGoatHorn {
                inner: MusicInstrumentStruct::from_raw(env, obj)?,
            }),
            "CALL_GOAT_HORN" => Ok(MusicInstrument::CallGoatHorn {
                inner: MusicInstrumentStruct::from_raw(env, obj)?,
            }),
            "YEARN_GOAT_HORN" => Ok(MusicInstrument::YearnGoatHorn {
                inner: MusicInstrumentStruct::from_raw(env, obj)?,
            }),
            "DREAM_GOAT_HORN" => Ok(MusicInstrument::DreamGoatHorn {
                inner: MusicInstrumentStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct MusicInstrumentStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for MusicInstrument<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::PonderGoatHorn { inner } => inner.0.clone(),
            Self::SingGoatHorn { inner } => inner.0.clone(),
            Self::SeekGoatHorn { inner } => inner.0.clone(),
            Self::FeelGoatHorn { inner } => inner.0.clone(),
            Self::AdmireGoatHorn { inner } => inner.0.clone(),
            Self::CallGoatHorn { inner } => inner.0.clone(),
            Self::YearnGoatHorn { inner } => inner.0.clone(),
            Self::DreamGoatHorn { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::PonderGoatHorn { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::SingGoatHorn { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::SeekGoatHorn { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::FeelGoatHorn { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::AdmireGoatHorn { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::CallGoatHorn { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::YearnGoatHorn { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DreamGoatHorn { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for MusicInstrument<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate MusicInstrument from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/MusicInstrument")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a MusicInstrument object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "PONDER_GOAT_HORN" => Ok(MusicInstrument::PonderGoatHorn {
                    inner: MusicInstrumentStruct::from_raw(env, obj)?,
                }),
                "SING_GOAT_HORN" => Ok(MusicInstrument::SingGoatHorn {
                    inner: MusicInstrumentStruct::from_raw(env, obj)?,
                }),
                "SEEK_GOAT_HORN" => Ok(MusicInstrument::SeekGoatHorn {
                    inner: MusicInstrumentStruct::from_raw(env, obj)?,
                }),
                "FEEL_GOAT_HORN" => Ok(MusicInstrument::FeelGoatHorn {
                    inner: MusicInstrumentStruct::from_raw(env, obj)?,
                }),
                "ADMIRE_GOAT_HORN" => Ok(MusicInstrument::AdmireGoatHorn {
                    inner: MusicInstrumentStruct::from_raw(env, obj)?,
                }),
                "CALL_GOAT_HORN" => Ok(MusicInstrument::CallGoatHorn {
                    inner: MusicInstrumentStruct::from_raw(env, obj)?,
                }),
                "YEARN_GOAT_HORN" => Ok(MusicInstrument::YearnGoatHorn {
                    inner: MusicInstrumentStruct::from_raw(env, obj)?,
                }),
                "DREAM_GOAT_HORN" => Ok(MusicInstrument::DreamGoatHorn {
                    inner: MusicInstrumentStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for MusicInstrumentStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for MusicInstrumentStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate MusicInstrumentStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/MusicInstrument")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a MusicInstrumentStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> MusicInstrumentStruct<'mc> {
    #[deprecated]
    /// Returns a {@link MusicInstrument} by a {@link NamespacedKey}.
    pub fn get_by_key(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        namespaced_key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<Option<crate::MusicInstrument<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lorg/bukkit/MusicInstrument;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(namespaced_key.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/MusicInstrument");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByKey",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::MusicInstrument::from_raw(&jni, obj)?))
    }
    #[deprecated]
    /// Returns all known MusicInstruments.
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<Vec<crate::MusicInstrument<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let cls = jni.find_class("org/bukkit/MusicInstrument");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&jni, res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::MusicInstrument::from_raw(&jni, obj)?);
        }
        Ok(new_vec)
    }
    /// Return the namespaced identifier for this object.
    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct Warning<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Warning<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Warning<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Warning from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Warning")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Warning object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Warning<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum WarningWarningState<'mc> {}
impl<'mc> std::fmt::Display for WarningWarningState<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> WarningWarningState<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<WarningWarningState<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Warning/WarningState");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Warning/WarningState;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct WarningWarningStateStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for WarningWarningState<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for WarningWarningState<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate WarningWarningState from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Warning/WarningState")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WarningWarningState object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for WarningWarningStateStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WarningWarningStateStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate WarningWarningStateStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Warning/WarningState")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WarningWarningStateStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> WarningWarningStateStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::WarningWarningState<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Warning/WarningState;");
        let cls = jni.find_class("org/bukkit/Warning/WarningState");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::WarningWarningState::from_raw(&jni, obj)
    }
    /// This method checks the provided warning should be printed for this
    /// state
    pub fn print_for(
        &self,
        warning: impl Into<crate::Warning<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Warning;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(warning.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "printFor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// This method returns the corresponding warning state for the given
    /// string value.
    pub fn value(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        value: impl Into<String>,
    ) -> Result<crate::WarningWarningState<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/Warning/WarningState;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(value.into())?,
        ));
        let cls = jni.find_class("org/bukkit/Warning/WarningState");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "value",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::WarningWarningState::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct Chunk<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Chunk<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Chunk<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Chunk from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Chunk")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Chunk object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Chunk<'mc> {
    /// Gets the X-coordinate of this chunk
    pub fn x(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getX", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the Z-coordinate of this chunk
    pub fn z(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getZ", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the world containing this chunk
    pub fn world(&self) -> Result<crate::World<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/World;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getWorld", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::World::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets a block from this chunk
    pub fn get_block(
        &self,
        x: i32,
        y: i32,
        z: i32,
    ) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(III)Lorg/bukkit/block/Block;");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(y);
        let val_3 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBlock",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Block::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Capture thread-safe read-only snapshot of chunk data
    pub fn get_chunk_snapshot(
        &self,
        include_maxblocky: bool,
        include_biome: bool,
        include_biome_temp_rain: bool,
    ) -> Result<crate::ChunkSnapshot<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(ZZZ)Lorg/bukkit/ChunkSnapshot;");
        let val_1 = jni::objects::JValueGen::Bool(include_maxblocky.into());
        let val_2 = jni::objects::JValueGen::Bool(include_biome.into());
        let val_3 = jni::objects::JValueGen::Bool(include_biome_temp_rain.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getChunkSnapshot",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::ChunkSnapshot::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Checks if entities in this chunk are loaded.
    pub fn is_entities_loaded(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isEntitiesLoaded",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Get a list of all entities in the chunk.
    /// This will force load any entities, which are not loaded.
    pub fn entities(&self) -> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Entity;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getEntities", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::Entity::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Get a list of all tile entities in the chunk.
    pub fn tile_entities(
        &self,
    ) -> Result<crate::block::BlockState<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/block/BlockState;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getTileEntities", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::BlockState::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Checks if the chunk is fully generated.
    pub fn is_generated(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isGenerated", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks if the chunk is loaded.
    pub fn is_loaded(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isLoaded", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Loads the chunk.
    pub fn load(
        &self,
        generate: std::option::Option<bool>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = generate {
            sig += "Z";
            let val_1 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_1);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "load", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Unloads and optionally saves the Chunk
    pub fn unload(
        &self,
        save: std::option::Option<bool>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = save {
            sig += "Z";
            let val_1 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_1);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "unload", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks if this chunk can spawn slimes without being a swamp biome.
    pub fn is_slime_chunk(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isSlimeChunk", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether the chunk at the specified chunk coordinates is force
    /// loaded.
    ///
    /// A force loaded chunk will not be unloaded due to lack of player activity.
    pub fn is_force_loaded(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isForceLoaded", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the chunk at the specified chunk coordinates is force
    /// loaded.
    ///
    /// A force loaded chunk will not be unloaded due to lack of player activity.
    pub fn set_force_loaded(&self, forced: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(forced.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setForceLoaded",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Adds a plugin ticket for this chunk, loading this chunk if it is not
    /// already loaded.
    ///
    /// A plugin ticket will prevent a chunk from unloading until it is
    /// explicitly removed. A plugin instance may only have one ticket per chunk,
    /// but each chunk can have multiple plugin tickets.
    ///
    pub fn add_plugin_chunk_ticket(
        &self,
        plugin: impl Into<crate::plugin::Plugin<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/plugin/Plugin;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(plugin.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "addPluginChunkTicket",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Removes the specified plugin's ticket for this chunk
    ///
    /// A plugin ticket will prevent a chunk from unloading until it is
    /// explicitly removed. A plugin instance may only have one ticket per chunk,
    /// but each chunk can have multiple plugin tickets.
    ///
    pub fn remove_plugin_chunk_ticket(
        &self,
        plugin: impl Into<crate::plugin::Plugin<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/plugin/Plugin;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(plugin.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removePluginChunkTicket",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Retrieves a collection specifying which plugins have tickets for this
    /// chunk. This collection is not updated when plugin tickets are added or
    /// removed to this chunk.
    ///
    /// A plugin ticket will prevent a chunk from unloading until it is
    /// explicitly removed. A plugin instance may only have one ticket per chunk,
    /// but each chunk can have multiple plugin tickets.
    ///
    pub fn plugin_chunk_tickets(
        &self,
    ) -> Result<Vec<crate::plugin::Plugin<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPluginChunkTickets",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::plugin::Plugin::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Gets the amount of time in ticks that this chunk has been inhabited.
    /// Note that the time is incremented once per tick per player within mob
    /// spawning distance of this chunk.
    pub fn inhabited_time(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getInhabitedTime",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    /// Sets the amount of time in ticks that this chunk has been inhabited.
    pub fn set_inhabited_time(&self, ticks: i64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(J)V");
        let val_1 = jni::objects::JValueGen::Long(ticks);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setInhabitedTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Tests if this chunk contains the specified biome.
    pub fn contains(
        &self,
        biome: impl Into<crate::block::Biome<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/block/Biome;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(biome.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "contains", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the load level of this chunk, which determines what game logic is
    /// processed.
    pub fn load_level(&self) -> Result<crate::ChunkLoadLevel<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Chunk/LoadLevel;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLoadLevel", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::ChunkLoadLevel::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets all generated structures of a given {@link Structure} that intersect
    /// this chunk.
    ///
    /// If no structures are present an empty collection will be returned.
    pub fn get_structures(
        &self,
        structure: impl Into<crate::generator::structure::Structure<'mc>>,
    ) -> Result<Vec<crate::generator::structure::GeneratedStructure<'mc>>, Box<dyn std::error::Error>>
    {
        let sig =
            String::from("(Lorg/bukkit/generator/structure/Structure;)Ljava/util/Collection;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(structure.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getStructures",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::generator::structure::GeneratedStructure::from_raw(
                &self.jni_ref(),
                obj,
            )?);
        }
        Ok(new_vec)
    }
    /// Get a list of all players who are can view the chunk from their client
    ///
    /// This list will be empty if no players are viewing the chunk, or the chunk
    /// is unloaded.
    pub fn players_seeing_chunk(
        &self,
    ) -> Result<Vec<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPlayersSeeingChunk",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Player::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Returns a custom tag container capable of storing tags on the object.
    /// Note that the tags stored on this container are all stored under their
    /// own custom namespace therefore modifying default tags using this
    /// {@link PersistentDataHolder} is impossible.
    pub fn persistent_data_container(
        &self,
    ) -> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Lorg/bukkit/persistence/PersistentDataContainer;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPersistentDataContainer",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::persistence::PersistentDataHolder<'mc>> for Chunk<'mc> {
    fn into(self) -> crate::persistence::PersistentDataHolder<'mc> {
        crate::persistence::PersistentDataHolder::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting Chunk into crate::persistence::PersistentDataHolder")
    }
}
pub enum ChunkLoadLevel<'mc> {}
impl<'mc> std::fmt::Display for ChunkLoadLevel<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> ChunkLoadLevel<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<ChunkLoadLevel<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Chunk/LoadLevel");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Chunk/LoadLevel;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct ChunkLoadLevelStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ChunkLoadLevel<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for ChunkLoadLevel<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ChunkLoadLevel from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Chunk/LoadLevel")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ChunkLoadLevel object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for ChunkLoadLevelStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ChunkLoadLevelStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ChunkLoadLevelStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Chunk/LoadLevel")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ChunkLoadLevelStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ChunkLoadLevelStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::ChunkLoadLevel<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Chunk/LoadLevel;");
        let cls = jni.find_class("org/bukkit/Chunk/LoadLevel");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::ChunkLoadLevel::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct BlockChangeDelegate<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for BlockChangeDelegate<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for BlockChangeDelegate<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate BlockChangeDelegate from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/BlockChangeDelegate")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a BlockChangeDelegate object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> BlockChangeDelegate<'mc> {
    /// Set a block data at the specified coordinates.
    pub fn set_block_data(
        &self,
        x: i32,
        y: i32,
        z: i32,
        block_data: impl Into<crate::block::data::BlockData<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(IIILorg/bukkit/block/data/BlockData;)Z");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(y);
        let val_3 = jni::objects::JValueGen::Int(z);
        let val_4 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(block_data.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBlockData",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
                jni::objects::JValueGen::from(val_4),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Get the block data at the location.
    pub fn get_block_data(
        &self,
        x: i32,
        y: i32,
        z: i32,
    ) -> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(III)Lorg/bukkit/block/data/BlockData;");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(y);
        let val_3 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBlockData",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::block::data::BlockData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the height of the world.
    pub fn height(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getHeight", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Checks if the specified block is empty (air) or not.
    pub fn is_empty(&self, x: i32, y: i32, z: i32) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(III)Z");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(y);
        let val_3 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isEmpty",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct OfflinePlayer<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for OfflinePlayer<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for OfflinePlayer<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate OfflinePlayer from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/OfflinePlayer")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a OfflinePlayer object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> OfflinePlayer<'mc> {
    /// Checks if this player is currently online
    pub fn is_online(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isOnline", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Returns the name of this player
    ///
    /// Names are no longer unique past a single game session. For persistent storage
    /// it is recommended that you use {@link #getUniqueId()} instead.
    pub fn name(&self) -> Result<Option<String>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getName", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(
            self.jni_ref()
                .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
                .to_string_lossy()
                .to_string(),
        ))
    }
    /// Returns the UUID of this player
    pub fn unique_id(
        &self,
    ) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/UUID;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getUniqueId", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets a copy of the player's profile.
    ///
    /// If the player is online, the returned profile will be complete.
    /// Otherwise, only the unique id is guaranteed to be present. You can use
    /// {@link PlayerProfile#update()} to complete the returned profile.
    pub fn player_profile(
        &self,
    ) -> Result<crate::profile::PlayerProfile<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/profile/PlayerProfile;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPlayerProfile",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::profile::PlayerProfile::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Checks if this player has had their profile banned.
    pub fn is_banned(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBanned", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Adds this user to the {@link ProfileBanList}. If a previous ban exists, this will
    /// update the entry.
    pub fn ban(
        &self,
        reason: impl Into<String>,
        duration: jni::objects::JObject<'mc>,
        source: impl Into<String>,
    ) -> Result<Option<crate::BanEntry<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(reason.into())?,
        ));
        args.push(val_1);
        sig += "Ljava/time/Duration;";
        let val_2 = jni::objects::JValueGen::Object(duration);
        args.push(val_2);
        sig += "Ljava/lang/String;";
        let val_3 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(source.into())?,
        ));
        args.push(val_3);
        sig += ")Lorg/bukkit/BanEntry;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "ban", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::BanEntry::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Checks if this player is whitelisted or not
    pub fn is_whitelisted(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isWhitelisted", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets if this player is whitelisted or not
    pub fn set_whitelisted(&self, value: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(value.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWhitelisted",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets a {@link Player} object that this represents, if there is one
    ///
    /// If the player is online, this will return that player. Otherwise,
    /// it will return null.
    pub fn player(&self) -> Result<Option<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Player;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getPlayer", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::entity::Player::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Gets the first date and time that this player was witnessed on this
    /// server.
    ///
    /// If the player has never played before, this will return 0. Otherwise,
    /// it will be the amount of milliseconds since midnight, January 1, 1970
    /// UTC.
    pub fn first_played(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFirstPlayed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    /// Gets the last date and time that this player was witnessed on this
    /// server.
    ///
    /// If the player has never played before, this will return 0. Otherwise,
    /// it will be the amount of milliseconds since midnight, January 1, 1970
    /// UTC.
    pub fn last_played(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLastPlayed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    /// Checks if this player has played on this server before.
    pub fn has_played_before(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "hasPlayedBefore", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]
    /// Gets the Location where the player will spawn at their bed, null if they have not slept in one or their current bed spawn is invalid.
    pub fn bed_spawn_location(
        &self,
    ) -> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBedSpawnLocation",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Gets the Location where the player will spawn at, null if they
    /// don't have a valid respawn point.
    pub fn respawn_location(
        &self,
    ) -> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getRespawnLocation",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Increments the given statistic for this player for the given entity.
    pub fn increment_statistic(
        &self,
        statistic: impl Into<crate::Statistic<'mc>>,
        entity_type: std::option::Option<impl Into<crate::entity::EntityType<'mc>>>,
        amount: std::option::Option<i32>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Statistic;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(statistic.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = entity_type {
            sig += "Lorg/bukkit/entity/EntityType;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        if let Some(a) = amount {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")V";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "incrementStatistic",
            sig.as_str(),
            args,
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Decrements the given statistic for this player for the given entity.
    pub fn decrement_statistic(
        &self,
        statistic: impl Into<crate::Statistic<'mc>>,
        entity_type: std::option::Option<impl Into<crate::entity::EntityType<'mc>>>,
        amount: std::option::Option<i32>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Statistic;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(statistic.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = entity_type {
            sig += "Lorg/bukkit/entity/EntityType;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        if let Some(a) = amount {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")V";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "decrementStatistic",
            sig.as_str(),
            args,
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets the given statistic for this player for the given entity.
    pub fn set_statistic(
        &self,
        statistic: impl Into<crate::Statistic<'mc>>,
        entity_type: impl Into<crate::entity::EntityType<'mc>>,
        new_value: std::option::Option<i32>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Statistic;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(statistic.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/entity/EntityType;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(entity_type.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = new_value {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "setStatistic", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the value of the given statistic for this player.
    pub fn get_statistic(
        &self,
        statistic: impl Into<crate::Statistic<'mc>>,
        entity_type: std::option::Option<impl Into<crate::entity::EntityType<'mc>>>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Statistic;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(statistic.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = entity_type {
            sig += "Lorg/bukkit/entity/EntityType;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")I";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getStatistic", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the player's last death location.
    pub fn last_death_location(
        &self,
    ) -> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Lorg/bukkit/Location;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLastDeathLocation",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Gets the player's current location.
    pub fn location(&self) -> Result<Option<crate::Location<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLocation", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Checks if this object is a server operator
    pub fn is_op(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isOp", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets the operator status of this object
    pub fn set_op(&self, value: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(value.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setOp",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Creates a Map representation of this class.
    ///
    /// This class must provide a method to restore this class, as defined in
    /// the {@link ConfigurationSerializable} interface javadocs.
    pub fn serialize(
        &self,
    ) -> Result<blackboxmc_java::util::JavaMap<'mc>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Ljava/util/Map;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "serialize", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaMap::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::permissions::ServerOperator<'mc>> for OfflinePlayer<'mc> {
    fn into(self) -> crate::permissions::ServerOperator<'mc> {
        crate::permissions::ServerOperator::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting OfflinePlayer into crate::permissions::ServerOperator")
    }
}
impl<'mc> Into<crate::entity::AnimalTamer<'mc>> for OfflinePlayer<'mc> {
    fn into(self) -> crate::entity::AnimalTamer<'mc> {
        crate::entity::AnimalTamer::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting OfflinePlayer into crate::entity::AnimalTamer")
    }
}
impl<'mc> Into<crate::configuration::serialization::ConfigurationSerializable<'mc>>
    for OfflinePlayer<'mc>
{
    fn into(self) -> crate::configuration::serialization::ConfigurationSerializable<'mc> {
        crate::configuration::serialization::ConfigurationSerializable::from_raw(&self.jni_ref(), self.1).expect("Error converting OfflinePlayer into crate::configuration::serialization::ConfigurationSerializable")
    }
}
pub enum SandstoneType<'mc> {}
impl<'mc> std::fmt::Display for SandstoneType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> SandstoneType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<SandstoneType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/SandstoneType");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/SandstoneType;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct SandstoneTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SandstoneType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for SandstoneType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SandstoneType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/SandstoneType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SandstoneType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for SandstoneTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SandstoneTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate SandstoneTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/SandstoneType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SandstoneTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SandstoneTypeStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::SandstoneType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/SandstoneType;");
        let cls = jni.find_class("org/bukkit/SandstoneType");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::SandstoneType::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Gets the associated data value representing this type of sandstone
    pub fn data(&self) -> Result<i8, Box<dyn std::error::Error>> {
        let sig = String::from("()B");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getData", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.b()?)
    }
    #[deprecated]
    /// Gets the type of sandstone with the given data value
    pub fn get_by_data(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        data: i8,
    ) -> Result<Option<crate::SandstoneType<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(B)Lorg/bukkit/SandstoneType;");
        let val_1 = jni::objects::JValueGen::Byte(data);
        let cls = jni.find_class("org/bukkit/SandstoneType");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::SandstoneType::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct World<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for World<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for World<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate World from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/World")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a World object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> World<'mc> {
    /// Gets the {@link Block} at the given coordinates
    pub fn get_block_at(
        &self,
        x: i32,
        y: std::option::Option<i32>,
        z: std::option::Option<i32>,
    ) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = y {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/block/Block;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBlockAt", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Block::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the highest block corresponding to the {@link HeightMap} at the
    /// given coordinates.
    pub fn get_highest_block_at(
        &self,
        location: impl Into<crate::Location<'mc>>,
        height_map: std::option::Option<impl Into<crate::HeightMap<'mc>>>,
    ) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = height_map {
            sig += "Lorg/bukkit/HeightMap;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/block/Block;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getHighestBlockAt", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Block::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the {@link Chunk} at the given coordinates
    pub fn get_chunk_at(
        &self,
        x: i32,
        z: std::option::Option<i32>,
        generate: std::option::Option<bool>,
    ) -> Result<crate::Chunk<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = z {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = generate {
            sig += "Z";
            let val_3 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/Chunk;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getChunkAt", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::Chunk::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Checks if the {@link Chunk} at the specified coordinates is loaded
    pub fn is_chunk_loaded(
        &self,
        x: i32,
        z: std::option::Option<i32>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = z {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        sig += ")Z";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isChunkLoaded", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets an array of all loaded {@link Chunk}s
    pub fn loaded_chunks(&self) -> Result<crate::Chunk<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Chunk;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLoadedChunks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Chunk::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Loads the {@link Chunk} at the specified coordinates.
    ///
    /// <b>This method will keep the specified chunk loaded until one of the
    /// unload methods is manually called. Callers are advised to instead use
    /// getChunkAt which will only temporarily load the requested chunk.</b>
    pub fn load_chunk(
        &self,
        x: i32,
        z: std::option::Option<i32>,
        generate: std::option::Option<bool>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = z {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = generate {
            sig += "Z";
            let val_3 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_3);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "loadChunk", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks if the {@link Chunk} at the specified coordinates is generated
    pub fn is_chunk_generated(&self, x: i32, z: i32) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(II)Z");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isChunkGenerated",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]
    /// Checks if the {@link Chunk} at the specified coordinates is loaded and in use by one or more players
    pub fn is_chunk_in_use(&self, x: i32, z: i32) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(II)Z");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isChunkInUse",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Safely unloads and optionally saves the {@link Chunk} at the specified
    /// coordinates.
    pub fn unload_chunk(
        &self,
        x: i32,
        z: std::option::Option<i32>,
        save: std::option::Option<bool>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = z {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = save {
            sig += "Z";
            let val_3 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_3);
        }
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "unloadChunk", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Safely queues the {@link Chunk} at the specified coordinates for
    /// unloading.
    pub fn unload_chunk_request(&self, x: i32, z: i32) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(II)Z");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "unloadChunkRequest",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]
    /// Regenerates the {@link Chunk} at the specified coordinates
    pub fn regenerate_chunk(&self, x: i32, z: i32) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(II)Z");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "regenerateChunk",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]
    /// Resends the {@link Chunk} to all clients
    pub fn refresh_chunk(&self, x: i32, z: i32) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(II)Z");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "refreshChunk",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Get a list of all players who are can view the specified chunk from their
    /// client
    ///
    /// This list will be empty if no players are viewing the chunk, or the chunk
    /// is unloaded.
    pub fn get_players_seeing_chunk(
        &self,
        x: i32,
        z: std::option::Option<i32>,
    ) -> Result<Vec<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = z {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        sig += ")Ljava/util/Collection;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPlayersSeeingChunk",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Player::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Gets whether the chunk at the specified chunk coordinates is force
    /// loaded.
    ///
    /// A force loaded chunk will not be unloaded due to lack of player activity.
    pub fn is_chunk_force_loaded(
        &self,
        x: i32,
        z: i32,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(II)Z");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isChunkForceLoaded",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the chunk at the specified chunk coordinates is force
    /// loaded.
    ///
    /// A force loaded chunk will not be unloaded due to lack of player activity.
    pub fn set_chunk_force_loaded(
        &self,
        x: i32,
        z: i32,
        forced: bool,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(IIZ)V");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(z);
        let val_3 = jni::objects::JValueGen::Bool(forced.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setChunkForceLoaded",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Returns all force loaded chunks in this world.
    ///
    /// A force loaded chunk will not be unloaded due to lack of player activity.
    pub fn force_loaded_chunks(
        &self,
    ) -> Result<Vec<crate::Chunk<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getForceLoadedChunks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::Chunk::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Adds a plugin ticket for the specified chunk, loading the chunk if it is
    /// not already loaded.
    ///
    /// A plugin ticket will prevent a chunk from unloading until it is
    /// explicitly removed. A plugin instance may only have one ticket per chunk,
    /// but each chunk can have multiple plugin tickets.
    ///
    pub fn add_plugin_chunk_ticket(
        &self,
        x: i32,
        z: i32,
        plugin: impl Into<crate::plugin::Plugin<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(IILorg/bukkit/plugin/Plugin;)Z");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(z);
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(plugin.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "addPluginChunkTicket",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Removes the specified plugin's ticket for the specified chunk
    ///
    /// A plugin ticket will prevent a chunk from unloading until it is
    /// explicitly removed. A plugin instance may only have one ticket per chunk,
    /// but each chunk can have multiple plugin tickets.
    ///
    pub fn remove_plugin_chunk_ticket(
        &self,
        x: i32,
        z: i32,
        plugin: impl Into<crate::plugin::Plugin<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(IILorg/bukkit/plugin/Plugin;)Z");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(z);
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(plugin.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removePluginChunkTicket",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Removes all plugin tickets for the specified plugin
    ///
    /// A plugin ticket will prevent a chunk from unloading until it is
    /// explicitly removed. A plugin instance may only have one ticket per chunk,
    /// but each chunk can have multiple plugin tickets.
    ///
    pub fn remove_plugin_chunk_tickets(
        &self,
        plugin: impl Into<crate::plugin::Plugin<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/plugin/Plugin;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(plugin.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "removePluginChunkTickets",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Returns a map of which plugins have tickets for what chunks. The returned
    /// map is not updated when plugin tickets are added or removed to chunks. If
    /// a plugin has no tickets, it will be absent from the map.
    ///
    /// A plugin ticket will prevent a chunk from unloading until it is
    /// explicitly removed. A plugin instance may only have one ticket per chunk,
    /// but each chunk can have multiple plugin tickets.
    ///
    pub fn plugin_chunk_tickets(
        &self,
    ) -> Result<blackboxmc_java::util::JavaMap<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Map;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPluginChunkTickets",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaMap::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets all Chunks intersecting the given BoundingBox.
    pub fn get_intersecting_chunks(
        &self,
        val_box: impl Into<crate::util::BoundingBox<'mc>>,
    ) -> Result<Vec<crate::Chunk<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/BoundingBox;)Ljava/util/Collection;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(val_box.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getIntersectingChunks",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::Chunk::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Drops an item at the specified {@link Location}
    /// Note that functions will run before the entity is spawned
    pub fn drop_item(
        &self,
        location: impl Into<crate::Location<'mc>>,
        item: impl Into<crate::inventory::ItemStack<'mc>>,
        function: std::option::Option<
            impl Into<blackboxmc_java::util::function::JavaConsumer<'mc>>,
        >,
    ) -> Result<crate::entity::Item<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/inventory/ItemStack;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(item.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = function {
            sig += "Ljava/util/function/Consumer;";
            let val_3 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/entity/Item;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "dropItem", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::Item::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Drops an item at the specified {@link Location} with a random offset
    /// Note that functions will run before the entity is spawned
    pub fn drop_item_naturally(
        &self,
        location: impl Into<crate::Location<'mc>>,
        item: impl Into<crate::inventory::ItemStack<'mc>>,
        function: std::option::Option<
            impl Into<blackboxmc_java::util::function::JavaConsumer<'mc>>,
        >,
    ) -> Result<crate::entity::Item<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/inventory/ItemStack;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(item.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = function {
            sig += "Ljava/util/function/Consumer;";
            let val_3 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/entity/Item;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "dropItemNaturally", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::Item::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Creates an arrow entity of the given class at the given {@link Location}
    pub fn spawn_arrow(
        &self,
        location: impl Into<crate::Location<'mc>>,
        direction: impl Into<crate::util::Vector<'mc>>,
        speed: f32,
        spread: f32,
        clazz: std::option::Option<jni::objects::JClass<'mc>>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/util/Vector;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(direction.into().jni_object().clone())
        });
        args.push(val_2);
        sig += "F";
        let val_3 = jni::objects::JValueGen::Float(speed);
        args.push(val_3);
        sig += "F";
        let val_4 = jni::objects::JValueGen::Float(spread);
        args.push(val_4);
        if let Some(a) = clazz {
            sig += "Ljava/lang/Class;";
            let val_5 = jni::objects::JValueGen::Object(a.into());
            args.push(val_5);
        }
        sig += ")LT;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "spawnArrow", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }
    /// Creates a tree at the given {@link Location}
    ///
    /// The provided predicate gets called for every block which gets changed
    /// as a result of the tree generation. When the predicate gets called no
    /// modifications to the world are done yet. Which means, that calling
    /// {@link #getBlockState(Location)} in the predicate will return the state
    /// of the block before the generation.
    ///
    /// If the predicate returns {@code true} the block gets set in the world.
    /// If it returns {@code false} the block won't get set in the world.
    pub fn generate_tree(
        &self,
        location: impl Into<crate::Location<'mc>>,
        random: impl Into<blackboxmc_java::util::JavaRandom<'mc>>,
        val_type: std::option::Option<impl Into<crate::TreeType<'mc>>>,
        state_predicate: std::option::Option<
            impl Into<blackboxmc_java::util::function::JavaPredicate<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Ljava/util/Random;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(random.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = val_type {
            sig += "Lorg/bukkit/TreeType;";
            let val_3 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_3);
        }
        if let Some(a) = state_predicate {
            sig += "Ljava/util/function/Predicate;";
            let val_4 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_4);
        }
        sig += ")Z";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "generateTree", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Strikes lightning at the given {@link Location}
    pub fn strike_lightning(
        &self,
        loc: impl Into<crate::Location<'mc>>,
    ) -> Result<crate::entity::LightningStrike<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)Lorg/bukkit/entity/LightningStrike;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(loc.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "strikeLightning",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::LightningStrike::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Strikes lightning at the given {@link Location} without doing damage
    pub fn strike_lightning_effect(
        &self,
        loc: impl Into<crate::Location<'mc>>,
    ) -> Result<crate::entity::LightningStrike<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)Lorg/bukkit/entity/LightningStrike;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(loc.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "strikeLightningEffect",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::LightningStrike::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Get a list of all entities in this RegionAccessor
    pub fn entities(&self) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Ljava/util/List;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getEntities", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Get a list of all living entities in this RegionAccessor
    pub fn living_entities(
        &self,
    ) -> Result<Vec<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Ljava/util/List;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLivingEntities", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::LivingEntity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Get a collection of all entities in this RegionAccessor matching the given
    /// class/interface
    pub fn get_entities_by_class(
        &self,
        cls: jni::objects::JClass<'mc>,
    ) -> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/Class;";
        let val_1 = jni::objects::JValueGen::Object(cls.into());
        args.push(val_1);
        sig += ")Ljava/util/Collection;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getEntitiesByClass",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(obj);
        }
        Ok(new_vec)
    }
    /// Get a collection of all entities in this RegionAccessor matching any of the
    /// given classes/interfaces
    pub fn get_entities_by_classes(
        &self,
        classes: jni::objects::JClass<'mc>,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/Class;";
        let val_1 = jni::objects::JValueGen::Object(classes.into());
        args.push(val_1);
        sig += ")Ljava/util/Collection;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getEntitiesByClasses",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Get a list of all players in this World
    pub fn players(&self) -> Result<Vec<crate::entity::Player<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPlayers", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Player::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Returns a list of entities within a bounding box centered around a
    /// Location.
    ///
    /// This may not consider entities in currently unloaded chunks. Some
    /// implementations may impose artificial restrictions on the size of the
    /// search bounding box.
    pub fn get_nearby_entities(
        &self,
        location: impl Into<crate::Location<'mc>>,
        x: std::option::Option<f64>,
        y: std::option::Option<f64>,
        z: std::option::Option<f64>,
        filter: std::option::Option<impl Into<blackboxmc_java::util::function::JavaPredicate<'mc>>>,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = x {
            sig += "D";
            let val_2 = jni::objects::JValueGen::Double(a);
            args.push(val_2);
        }
        if let Some(a) = y {
            sig += "D";
            let val_3 = jni::objects::JValueGen::Double(a);
            args.push(val_3);
        }
        if let Some(a) = z {
            sig += "D";
            let val_4 = jni::objects::JValueGen::Double(a);
            args.push(val_4);
        }
        if let Some(a) = filter {
            sig += "Ljava/util/function/Predicate;";
            let val_5 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_5);
        }
        sig += ")Ljava/util/Collection;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getNearbyEntities", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Performs a ray trace that checks for entity collisions.
    ///
    /// This may not consider entities in currently unloaded chunks. Some
    /// implementations may impose artificial restrictions on the maximum
    /// distance.
    pub fn ray_trace_entities(
        &self,
        start: impl Into<crate::Location<'mc>>,
        direction: impl Into<crate::util::Vector<'mc>>,
        max_distance: f64,
        ray_size: std::option::Option<f64>,
        filter: std::option::Option<impl Into<blackboxmc_java::util::function::JavaPredicate<'mc>>>,
    ) -> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(start.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/util/Vector;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(direction.into().jni_object().clone())
        });
        args.push(val_2);
        sig += "D";
        let val_3 = jni::objects::JValueGen::Double(max_distance);
        args.push(val_3);
        if let Some(a) = ray_size {
            sig += "D";
            let val_4 = jni::objects::JValueGen::Double(a);
            args.push(val_4);
        }
        if let Some(a) = filter {
            sig += "Ljava/util/function/Predicate;";
            let val_5 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_5);
        }
        sig += ")Lorg/bukkit/util/RayTraceResult;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "rayTraceEntities", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::util::RayTraceResult::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Performs a ray trace that checks for block collisions using the blocks'
    /// precise collision shapes.
    ///
    /// If collisions with passable blocks are ignored, fluid collisions are
    /// ignored as well regardless of the fluid collision mode.
    ///
    /// Portal blocks are only considered passable if the ray starts within
    /// them. Apart from that collisions with portal blocks will be considered
    /// even if collisions with passable blocks are otherwise ignored.
    ///
    /// This may cause loading of chunks! Some implementations may impose
    /// artificial restrictions on the maximum distance.
    pub fn ray_trace_blocks(
        &self,
        start: impl Into<crate::Location<'mc>>,
        direction: impl Into<crate::util::Vector<'mc>>,
        max_distance: f64,
        fluid_collision_mode: std::option::Option<impl Into<crate::FluidCollisionMode<'mc>>>,
        ignore_passable_blocks: std::option::Option<bool>,
    ) -> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(start.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/util/Vector;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(direction.into().jni_object().clone())
        });
        args.push(val_2);
        sig += "D";
        let val_3 = jni::objects::JValueGen::Double(max_distance);
        args.push(val_3);
        if let Some(a) = fluid_collision_mode {
            sig += "Lorg/bukkit/FluidCollisionMode;";
            let val_4 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_4);
        }
        if let Some(a) = ignore_passable_blocks {
            sig += "Z";
            let val_5 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_5);
        }
        sig += ")Lorg/bukkit/util/RayTraceResult;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "rayTraceBlocks", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::util::RayTraceResult::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Performs a ray trace that checks for both block and entity collisions.
    ///
    /// Block collisions use the blocks' precise collision shapes. The
    /// <code>raySize</code> parameter is only taken into account for entity
    /// collision checks.
    ///
    /// If collisions with passable blocks are ignored, fluid collisions are
    /// ignored as well regardless of the fluid collision mode.
    ///
    /// Portal blocks are only considered passable if the ray starts within them.
    /// Apart from that collisions with portal blocks will be considered even if
    /// collisions with passable blocks are otherwise ignored.
    ///
    /// This may cause loading of chunks! Some implementations may impose
    /// artificial restrictions on the maximum distance.
    pub fn ray_trace(
        &self,
        start: impl Into<crate::Location<'mc>>,
        direction: impl Into<crate::util::Vector<'mc>>,
        max_distance: f64,
        fluid_collision_mode: impl Into<crate::FluidCollisionMode<'mc>>,
        ignore_passable_blocks: bool,
        ray_size: f64,
        filter: impl Into<blackboxmc_java::util::function::JavaPredicate<'mc>>,
    ) -> Result<Option<crate::util::RayTraceResult<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;Lorg/bukkit/util/Vector;DLorg/bukkit/FluidCollisionMode;ZDLjava/util/function/Predicate;)Lorg/bukkit/util/RayTraceResult;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(start.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(direction.into().jni_object().clone())
        });
        let val_3 = jni::objects::JValueGen::Double(max_distance);
        let val_4 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(fluid_collision_mode.into().jni_object().clone())
        });
        let val_5 = jni::objects::JValueGen::Bool(ignore_passable_blocks.into());
        let val_6 = jni::objects::JValueGen::Double(ray_size);
        let val_7 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(filter.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "rayTrace",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
                jni::objects::JValueGen::from(val_4),
                jni::objects::JValueGen::from(val_5),
                jni::objects::JValueGen::from(val_6),
                jni::objects::JValueGen::from(val_7),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::util::RayTraceResult::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Gets the default spawn {@link Location} of this world
    pub fn spawn_location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getSpawnLocation",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the spawn location of the world
    pub fn set_spawn_location(
        &self,
        x: i32,
        y: std::option::Option<i32>,
        z: std::option::Option<i32>,
        angle: std::option::Option<f32>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = y {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        if let Some(a) = angle {
            sig += "F";
            let val_4 = jni::objects::JValueGen::Float(a);
            args.push(val_4);
        }
        sig += ")Z";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "setSpawnLocation", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the relative in-game time of this world.
    ///
    /// The relative time is analogous to hours * 1000
    pub fn time(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getTime", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    /// Sets the relative in-game time on the server.
    ///
    /// The relative time is analogous to hours * 1000
    ///
    /// Note that setting the relative time below the current relative time
    /// will actually move the clock forward a day. If you require to rewind
    /// time, please see {@link #setFullTime(long)}
    pub fn set_time(&self, time: i64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(J)V");
        let val_1 = jni::objects::JValueGen::Long(time);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the full in-game time on this world
    pub fn full_time(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFullTime", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    /// Sets the in-game time on the server
    ///
    /// Note that this sets the full time of the world, which may cause adverse
    /// effects such as breaking redstone clocks and any scheduled events
    pub fn set_full_time(&self, time: i64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(J)V");
        let val_1 = jni::objects::JValueGen::Long(time);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setFullTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the full in-game time on this world since the world generation
    pub fn game_time(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getGameTime", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    /// Returns whether the world has an ongoing storm.
    pub fn has_storm(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hasStorm", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set whether there is a storm. A duration will be set for the new
    /// current conditions.
    /// This will implicitly call {@link #setClearWeatherDuration(int)} with 0
    /// ticks to reset the world's clear weather.
    pub fn set_storm(&self, has_storm: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(has_storm.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setStorm",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Get the remaining time in ticks of the current conditions.
    pub fn weather_duration(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getWeatherDuration",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the remaining time in ticks of the current conditions.
    pub fn set_weather_duration(&self, duration: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(duration);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWeatherDuration",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Returns whether there is thunder.
    pub fn is_thundering(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isThundering", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set whether it is thundering.
    /// This will implicitly call {@link #setClearWeatherDuration(int)} with 0
    /// ticks to reset the world's clear weather.
    pub fn set_thundering(&self, thundering: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(thundering.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setThundering",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Get the thundering duration.
    pub fn thunder_duration(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getThunderDuration",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Set the thundering duration.
    pub fn set_thunder_duration(&self, duration: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(duration);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setThunderDuration",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Returns whether the world has clear weather.
    /// This will be true such that {@link #isThundering()} and
    /// {@link #hasStorm()} are both false.
    pub fn is_clear_weather(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isClearWeather", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Set the clear weather duration.
    /// The clear weather ticks determine whether or not the world will be
    /// allowed to rain or storm. If clear weather ticks are &gt; 0, the world will
    /// not naturally do either until the duration has elapsed.
    /// This method is equivalent to calling {@code /weather clear} with a set
    /// amount of ticks.
    pub fn set_clear_weather_duration(
        &self,
        duration: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(duration);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setClearWeatherDuration",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Get the clear weather duration.
    pub fn clear_weather_duration(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getClearWeatherDuration",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Creates explosion at given coordinates with given power and optionally
    /// setting blocks on fire or breaking blocks.
    ///
    /// Note that if a non-null {@code source} Entity is provided and {@code
    /// breakBlocks} is {@code true}, the value of {@code breakBlocks} will be
    /// ignored if {@link GameRule#MOB_GRIEFING} is {@code false} in the world
    /// in which the explosion occurs. In other words, the mob griefing gamerule
    /// will take priority over {@code breakBlocks} if explosions are not allowed.
    pub fn create_explosion(
        &self,
        loc: impl Into<crate::Location<'mc>>,
        power: f32,
        set_fire: std::option::Option<bool>,
        break_blocks: std::option::Option<bool>,
        source: std::option::Option<impl Into<crate::entity::Entity<'mc>>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(loc.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "F";
        let val_2 = jni::objects::JValueGen::Float(power);
        args.push(val_2);
        if let Some(a) = set_fire {
            sig += "Z";
            let val_3 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_3);
        }
        if let Some(a) = break_blocks {
            sig += "Z";
            let val_4 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_4);
        }
        if let Some(a) = source {
            sig += "Lorg/bukkit/entity/Entity;";
            let val_5 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_5);
        }
        sig += ")Z";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "createExplosion", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the current PVP setting for this world.
    pub fn pvp(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getPVP", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets the PVP setting for this world.
    pub fn set_pvp(&self, pvp: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(pvp.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPVP",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the chunk generator for this world
    pub fn generator(
        &self,
    ) -> Result<Option<crate::generator::ChunkGenerator<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/generator/ChunkGenerator;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getGenerator", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::generator::ChunkGenerator::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Gets the biome provider for this world
    pub fn biome_provider(
        &self,
    ) -> Result<Option<crate::generator::BiomeProvider<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/generator/BiomeProvider;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBiomeProvider",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::generator::BiomeProvider::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Saves world to disk
    pub fn save(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "save", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets a list of all applied {@link BlockPopulator}s for this World
    pub fn populators(
        &self,
    ) -> Result<Vec<crate::generator::BlockPopulator<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPopulators", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::generator::BlockPopulator::from_raw(
                &self.jni_ref(),
                obj,
            )?);
        }
        Ok(new_vec)
    }
    /// Creates a new entity at the given {@link Location} with the supplied
    /// function run before the entity is added to the world.
    ///
    /// Note that when the function is run, the entity will not be actually in
    /// the world. Any operation involving such as teleporting the entity is undefined
    /// until after this function returns.
    /// The passed function however is run after the potential entity's spawn
    /// randomization and hence already allows access to the values of the mob,
    /// whether or not those were randomized, such as attributes or the entity
    /// equipment.
    pub fn spawn(
        &self,
        location: impl Into<crate::Location<'mc>>,
        clazz: jni::objects::JClass<'mc>,
        spawn_reason: std::option::Option<
            impl Into<crate::event::entity::CreatureSpawnEventSpawnReason<'mc>>,
        >,
        randomize_data: std::option::Option<bool>,
        function: std::option::Option<
            impl Into<blackboxmc_java::util::function::JavaConsumer<'mc>>,
        >,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Ljava/lang/Class;";
        let val_2 = jni::objects::JValueGen::Object(clazz.into());
        args.push(val_2);
        if let Some(a) = spawn_reason {
            sig += "Lorg/bukkit/event/entity/CreatureSpawnEvent/SpawnReason;";
            let val_3 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_3);
        }
        if let Some(a) = randomize_data {
            sig += "Z";
            let val_4 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_4);
        }
        if let Some(a) = function {
            sig += "Ljava/util/function/Consumer;";
            let val_5 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_5);
        }
        sig += ")LT;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "spawn", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }
    #[deprecated]
    /// Spawn a {@link FallingBlock} entity at the given {@link Location} of the specified {@link Material}. The material dictates what is falling. When the FallingBlock hits the ground, it will place that block.The Material must be a block type, check with {@link Material#isBlock() material.isBlock()}. The Material may not be air.
    pub fn spawn_falling_block(
        &self,
        location: impl Into<crate::Location<'mc>>,
        material: impl Into<crate::Material<'mc>>,
        data: std::option::Option<i8>,
    ) -> Result<crate::entity::FallingBlock<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/Material;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(material.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = data {
            sig += "B";
            let val_3 = jni::objects::JValueGen::Byte(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/entity/FallingBlock;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "spawnFallingBlock", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::FallingBlock::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Plays an effect to all players within a given radius around a location.
    pub fn play_effect(
        &self,
        location: impl Into<crate::Location<'mc>>,
        effect: impl Into<crate::Effect<'mc>>,
        data: jni::objects::JObject<'mc>,
        radius: std::option::Option<i32>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/Effect;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(effect.into().jni_object().clone())
        });
        args.push(val_2);
        sig += "LT;";
        let val_3 = jni::objects::JValueGen::Object(data);
        args.push(val_3);
        if let Some(a) = radius {
            sig += "I";
            let val_4 = jni::objects::JValueGen::Int(a);
            args.push(val_4);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "playEffect", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Get empty chunk snapshot (equivalent to all air blocks), optionally
    /// including valid biome data. Used for representing an ungenerated chunk,
    /// or for fetching only biome data without loading a chunk.
    pub fn get_empty_chunk_snapshot(
        &self,
        x: i32,
        z: i32,
        include_biome: bool,
        include_biome_temp: bool,
    ) -> Result<crate::ChunkSnapshot<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(IIZZ)Lorg/bukkit/ChunkSnapshot;");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(z);
        let val_3 = jni::objects::JValueGen::Bool(include_biome.into());
        let val_4 = jni::objects::JValueGen::Bool(include_biome_temp.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getEmptyChunkSnapshot",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
                jni::objects::JValueGen::from(val_4),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::ChunkSnapshot::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the spawn flags for this.
    pub fn set_spawn_flags(
        &self,
        allow_monsters: bool,
        allow_animals: bool,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(ZZ)V");
        let val_1 = jni::objects::JValueGen::Bool(allow_monsters.into());
        let val_2 = jni::objects::JValueGen::Bool(allow_animals.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSpawnFlags",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets whether animals can spawn in this world.
    pub fn allow_animals(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getAllowAnimals", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether monsters can spawn in this world.
    pub fn allow_monsters(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getAllowMonsters",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the {@link Biome} at the given coordinates.
    pub fn get_biome(
        &self,
        x: i32,
        y: std::option::Option<i32>,
        z: std::option::Option<i32>,
    ) -> Result<crate::block::Biome<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = y {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/block/Biome;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBiome", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Biome::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the {@link Biome} for the given block coordinates
    pub fn set_biome(
        &self,
        x: i32,
        y: i32,
        z: std::option::Option<i32>,
        biome: std::option::Option<impl Into<crate::block::Biome<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(y);
        args.push(val_2);
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        if let Some(a) = biome {
            sig += "Lorg/bukkit/block/Biome;";
            let val_4 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_4);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "setBiome", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the temperature for the given block coordinates.
    ///
    /// It is safe to run this method when the block does not exist, it will
    /// not create the block.
    ///
    /// This method will return the raw temperature without adjusting for block
    /// height effects.
    pub fn get_temperature(
        &self,
        x: i32,
        y: i32,
        z: std::option::Option<i32>,
    ) -> Result<f64, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(y);
        args.push(val_2);
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")D";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getTemperature", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Gets the humidity for the given block coordinates.
    ///
    /// It is safe to run this method when the block does not exist, it will
    /// not create the block.
    pub fn get_humidity(
        &self,
        x: i32,
        y: i32,
        z: std::option::Option<i32>,
    ) -> Result<f64, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(y);
        args.push(val_2);
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")D";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getHumidity", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Gets the maximum height to which chorus fruits and nether portals can
    /// bring players within this dimension.
    /// This excludes portals that were already built above the limit as they
    /// still connect normally. May not be greater than {@link #getMaxHeight()}.
    pub fn logical_height(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getLogicalHeight",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets if this world is natural.
    /// When false, compasses spin randomly, and using a bed to set the respawn
    /// point or sleep, is disabled. When true, nether portals can spawn
    /// zombified piglins.
    pub fn is_natural(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isNatural", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets if beds work in this world.
    /// A non-working bed will blow up when trying to sleep. {@link #isNatural()}
    /// defines if a bed can be used to set spawn point.
    pub fn is_bed_works(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isBedWorks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets if this world has skylight access.
    pub fn has_sky_light(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "hasSkyLight", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets if this world has a ceiling.
    pub fn has_ceiling(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "hasCeiling", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets if this world allow to piglins to survive without shaking and
    /// transforming to zombified piglins.
    pub fn is_piglin_safe(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isPiglinSafe", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets if this world allows players to charge and use respawn anchors.
    pub fn is_respawn_anchor_works(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isRespawnAnchorWorks",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets if players with the bad omen effect in this world will trigger a
    /// raid.
    pub fn has_raids(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hasRaids", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets if various water/lava mechanics will be triggered in this world, eg:
    ///
    /// <ul>
    /// <li>Water is evaporated</li>
    /// <li>Sponges dry</li>
    /// <li>Lava spreads faster and further</li>
    /// </ul>
    pub fn is_ultra_warm(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isUltraWarm", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the sea level for this world.
    ///
    /// This is often half of {@link #getMaxHeight()}
    pub fn sea_level(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getSeaLevel", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets whether the world's spawn area should be kept loaded into memory or not.
    pub fn keep_spawn_in_memory(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getKeepSpawnInMemory",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]
    /// Sets whether the world's spawn area should be kept loaded into memory or not.
    pub fn set_keep_spawn_in_memory(
        &self,
        keep_loaded: bool,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(keep_loaded.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setKeepSpawnInMemory",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets whether or not the world will automatically save
    pub fn is_auto_save(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isAutoSave", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether or not the world will automatically save
    pub fn set_auto_save(&self, value: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(value.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAutoSave",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets the Difficulty of the world.
    pub fn set_difficulty(
        &self,
        difficulty: impl Into<crate::Difficulty<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Difficulty;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(difficulty.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDifficulty",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the Difficulty of the world.
    pub fn difficulty(&self) -> Result<crate::Difficulty<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Difficulty;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDifficulty", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Difficulty::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Returns the view distance used for this world.
    pub fn view_distance(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getViewDistance", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Returns the simulation distance used for this world.
    pub fn simulation_distance(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getSimulationDistance",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets the type of this world.
    pub fn world_type(&self) -> Result<Option<crate::WorldType<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/WorldType;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getWorldType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::WorldType::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Gets whether or not structures are being generated.
    pub fn can_generate_structures(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "canGenerateStructures",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets whether the world is hardcore or not.
    /// In a hardcore world the difficulty is locked to hard.
    pub fn is_hardcore(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isHardcore", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Sets whether the world is hardcore or not.
    /// In a hardcore world the difficulty is locked to hard.
    pub fn set_hardcore(&self, hardcore: bool) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Z)V");
        let val_1 = jni::objects::JValueGen::Bool(hardcore.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setHardcore",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets the world's ticks per animal spawns valueThis value determines how many ticks there are between attempts to spawn animals.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn animals in this world every tick. <li>A value of 400 will mean the server will attempt to spawn animals in this world every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, animal spawning will be disabled for this world. We recommend using {@link #setSpawnFlags(boolean, boolean)} to control this instead.Minecraft default: 400.
    pub fn ticks_per_animal_spawns(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerAnimalSpawns",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    #[deprecated]
    /// Sets the world's ticks per animal spawns valueThis value determines how many ticks there are between attempts to spawn animals.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn animals in this world every tick. <li>A value of 400 will mean the server will attempt to spawn animals in this world every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, animal spawning will be disabled for this world. We recommend using {@link #setSpawnFlags(boolean, boolean)} to control this instead.Minecraft default: 400.
    pub fn set_ticks_per_animal_spawns(
        &self,
        ticks_per_animal_spawns: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(ticks_per_animal_spawns);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTicksPerAnimalSpawns",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets the world's ticks per monster spawns valueThis value determines how many ticks there are between attempts to spawn monsters.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn monsters in this world every tick. <li>A value of 400 will mean the server will attempt to spawn monsters in this world every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, monsters spawning will be disabled for this world. We recommend using {@link #setSpawnFlags(boolean, boolean)} to control this instead.Minecraft default: 1.
    pub fn ticks_per_monster_spawns(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerMonsterSpawns",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    #[deprecated]
    /// Sets the world's ticks per monster spawns valueThis value determines how many ticks there are between attempts to spawn monsters.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn monsters in this world on every tick. <li>A value of 400 will mean the server will attempt to spawn monsters in this world every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, monsters spawning will be disabled for this world. We recommend using {@link #setSpawnFlags(boolean, boolean)} to control this instead.Minecraft default: 1.
    pub fn set_ticks_per_monster_spawns(
        &self,
        ticks_per_monster_spawns: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(ticks_per_monster_spawns);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTicksPerMonsterSpawns",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets the world's ticks per water mob spawns valueThis value determines how many ticks there are between attempts to spawn water mobs.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn water mobs in this world every tick. <li>A value of 400 will mean the server will attempt to spawn water mobs in this world every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, water mobs spawning will be disabled for this world.Minecraft default: 1.
    pub fn ticks_per_water_spawns(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerWaterSpawns",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    #[deprecated]
    /// Sets the world's ticks per water mob spawns valueThis value determines how many ticks there are between attempts to spawn water mobs.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn water mobs in this world on every tick. <li>A value of 400 will mean the server will attempt to spawn water mobs in this world every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, water mobs spawning will be disabled for this world.Minecraft default: 1.
    pub fn set_ticks_per_water_spawns(
        &self,
        ticks_per_water_spawns: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(ticks_per_water_spawns);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTicksPerWaterSpawns",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets the default ticks per water ambient mob spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn water ambient mobs every tick. <li>A value of 400 will mean the server will attempt to spawn water ambient mobs every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, ambient mobs spawning will be disabled.Minecraft default: 1.
    pub fn ticks_per_water_ambient_spawns(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerWaterAmbientSpawns",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    #[deprecated]
    /// Sets the world's ticks per water ambient mob spawns valueThis value determines how many ticks there are between attempts to spawn water ambient mobs.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn water ambient mobs in this world on every tick. <li>A value of 400 will mean the server will attempt to spawn water ambient mobs in this world every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, water ambient mobs spawning will be disabled for this world.Minecraft default: 1.
    pub fn set_ticks_per_water_ambient_spawns(
        &self,
        ticks_per_ambient_spawns: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(ticks_per_ambient_spawns);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTicksPerWaterAmbientSpawns",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets the default ticks per water underground creature spawns value.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn water underground creature every tick. <li>A value of 400 will mean the server will attempt to spawn water underground creature every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, water underground creature spawning will be disabled.Minecraft default: 1.
    pub fn ticks_per_water_underground_creature_spawns(
        &self,
    ) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerWaterUndergroundCreatureSpawns",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    #[deprecated]
    /// Sets the world's ticks per water underground creature spawns valueThis value determines how many ticks there are between attempts to spawn water underground creature.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn water underground creature in this world on every tick. <li>A value of 400 will mean the server will attempt to spawn water underground creature in this world every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, water underground creature spawning will be disabled for this world.Minecraft default: 1.
    pub fn set_ticks_per_water_underground_creature_spawns(
        &self,
        ticks_per_water_underground_creature_spawns: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(ticks_per_water_underground_creature_spawns);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTicksPerWaterUndergroundCreatureSpawns",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets the world's ticks per ambient mob spawns valueThis value determines how many ticks there are between attempts to spawn ambient mobs.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn ambient mobs in this world every tick. <li>A value of 400 will mean the server will attempt to spawn ambient mobs in this world every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, ambient mobs spawning will be disabled for this world.Minecraft default: 1.
    pub fn ticks_per_ambient_spawns(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerAmbientSpawns",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    #[deprecated]
    /// Sets the world's ticks per ambient mob spawns valueThis value determines how many ticks there are between attempts to spawn ambient mobs.<b>Example Usage:</b> <ul> <li>A value of 1 will mean the server will attempt to spawn ambient mobs in this world on every tick. <li>A value of 400 will mean the server will attempt to spawn ambient mobs in this world every 400th tick. <li>A value below 0 will be reset back to Minecraft's default. </ul><b>Note:</b> If set to 0, ambient mobs spawning will be disabled for this world.Minecraft default: 1.
    pub fn set_ticks_per_ambient_spawns(
        &self,
        ticks_per_ambient_spawns: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(ticks_per_ambient_spawns);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTicksPerAmbientSpawns",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the world's ticks per {@link SpawnCategory} mob spawns value
    ///
    /// This value determines how many ticks there are between attempts to
    /// spawn {@link SpawnCategory} mobs.
    ///
    /// <b>Example Usage:</b>
    /// <ul>
    /// <li>A value of 1 will mean the server will attempt to spawn {@link SpawnCategory} mobs in
    /// this world every tick.
    /// <li>A value of 400 will mean the server will attempt to spawn {@link SpawnCategory} mobs
    /// in this world every 400th tick.
    /// <li>A value below 0 will be reset back to Minecraft's default.
    /// </ul>
    ///
    /// <b>Note:</b>
    /// If set to 0, {@link SpawnCategory} mobs spawning will be disabled for this world.
    ///
    /// Minecraft default: 1.
    pub fn get_ticks_per_spawns(
        &self,
        spawn_category: impl Into<crate::entity::SpawnCategory<'mc>>,
    ) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/SpawnCategory;)J");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(spawn_category.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTicksPerSpawns",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    /// Sets the world's ticks per {@link SpawnCategory} mob spawns value
    ///
    /// This value determines how many ticks there are between attempts to
    /// spawn {@link SpawnCategory} mobs.
    ///
    /// <b>Example Usage:</b>
    /// <ul>
    /// <li>A value of 1 will mean the server will attempt to spawn {@link SpawnCategory} mobs in
    /// this world on every tick.
    /// <li>A value of 400 will mean the server will attempt to spawn {@link SpawnCategory} mobs
    /// in this world every 400th tick.
    /// <li>A value below 0 will be reset back to Minecraft's default.
    /// </ul>
    ///
    /// <b>Note:</b>
    /// If set to 0, {@link SpawnCategory} mobs spawning will be disabled for this world.
    ///
    /// Minecraft default: 1.
    pub fn set_ticks_per_spawns(
        &self,
        spawn_category: impl Into<crate::entity::SpawnCategory<'mc>>,
        ticks_per_category_spawn: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/SpawnCategory;I)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(spawn_category.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(ticks_per_category_spawn);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setTicksPerSpawns",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets limit for number of monsters that can spawn in a chunk in this world
    pub fn monster_spawn_limit(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMonsterSpawnLimit",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Sets the limit for number of monsters that can spawn in a chunk in this world<b>Note:</b> If set to a negative number the world will use the server-wide spawn limit instead.
    pub fn set_monster_spawn_limit(&self, limit: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(limit);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setMonsterSpawnLimit",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets the limit for number of animals that can spawn in a chunk in this world
    pub fn animal_spawn_limit(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getAnimalSpawnLimit",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Sets the limit for number of animals that can spawn in a chunk in this world<b>Note:</b> If set to a negative number the world will use the server-wide spawn limit instead.
    pub fn set_animal_spawn_limit(&self, limit: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(limit);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAnimalSpawnLimit",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets the limit for number of water animals that can spawn in a chunk in this world
    pub fn water_animal_spawn_limit(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getWaterAnimalSpawnLimit",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Sets the limit for number of water animals that can spawn in a chunk in this world<b>Note:</b> If set to a negative number the world will use the server-wide spawn limit instead.
    pub fn set_water_animal_spawn_limit(
        &self,
        limit: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(limit);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWaterAnimalSpawnLimit",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets the limit for number of water underground creature that can spawn in a chunk in this world
    pub fn water_underground_creature_spawn_limit(
        &self,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getWaterUndergroundCreatureSpawnLimit",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Sets the limit for number of water underground creature that can spawn in a chunk in this world<b>Note:</b> If set to a negative number the world will use the server-wide spawn limit instead.
    pub fn set_water_underground_creature_spawn_limit(
        &self,
        limit: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(limit);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWaterUndergroundCreatureSpawnLimit",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets user-specified limit for number of water ambient mobs that can spawn in a chunk.
    pub fn water_ambient_spawn_limit(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getWaterAmbientSpawnLimit",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Sets the limit for number of water ambient mobs that can spawn in a chunk in this world<b>Note:</b> If set to a negative number the world will use the server-wide spawn limit instead.
    pub fn set_water_ambient_spawn_limit(
        &self,
        limit: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(limit);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWaterAmbientSpawnLimit",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    #[deprecated]
    /// Gets the limit for number of ambient mobs that can spawn in a chunk in this world
    pub fn ambient_spawn_limit(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getAmbientSpawnLimit",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Sets the limit for number of ambient mobs that can spawn in a chunk in this world<b>Note:</b> If set to a negative number the world will use the server-wide spawn limit instead.
    pub fn set_ambient_spawn_limit(&self, limit: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(limit);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAmbientSpawnLimit",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the limit for number of {@link SpawnCategory} entities that can spawn in a chunk in
    /// this world
    pub fn get_spawn_limit(
        &self,
        spawn_category: impl Into<crate::entity::SpawnCategory<'mc>>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/SpawnCategory;)I");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(spawn_category.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getSpawnLimit",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the limit for number of {@link SpawnCategory} entities that can spawn in a chunk in
    /// this world
    ///
    /// <b>Note:</b> If set to a negative number the world will use the
    /// server-wide spawn limit instead.
    pub fn set_spawn_limit(
        &self,
        spawn_category: impl Into<crate::entity::SpawnCategory<'mc>>,
        limit: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/SpawnCategory;I)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(spawn_category.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(limit);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSpawnLimit",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Play a note at the provided Location in the World.
    ///
    /// This <i>will</i> work with cake.
    ///
    /// This method will fail silently when called with {@link Instrument#CUSTOM_HEAD}.
    pub fn play_note(
        &self,
        loc: impl Into<crate::Location<'mc>>,
        instrument: impl Into<crate::Instrument<'mc>>,
        note: impl Into<crate::Note<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;Lorg/bukkit/Instrument;Lorg/bukkit/Note;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(loc.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(instrument.into().jni_object().clone())
        });
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(note.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "playNote",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Play a Sound at the provided Location in the World. For sounds with multiple
    /// variations passing the same seed will always play the same variation.
    ///
    /// This function will fail silently if Location or Sound are null. No sound will
    /// be heard by the players if their clients do not have the respective sound for
    /// the value passed.
    pub fn play_sound(
        &self,
        location: impl Into<crate::Location<'mc>>,
        sound: impl Into<String>,
        category: impl Into<crate::SoundCategory<'mc>>,
        volume: f32,
        pitch: std::option::Option<f32>,
        seed: std::option::Option<i64>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Ljava/lang/String;";
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(sound.into())?,
        ));
        args.push(val_2);
        sig += "Lorg/bukkit/SoundCategory;";
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(category.into().jni_object().clone())
        });
        args.push(val_3);
        sig += "F";
        let val_4 = jni::objects::JValueGen::Float(volume);
        args.push(val_4);
        if let Some(a) = pitch {
            sig += "F";
            let val_5 = jni::objects::JValueGen::Float(a);
            args.push(val_5);
        }
        if let Some(a) = seed {
            sig += "J";
            let val_6 = jni::objects::JValueGen::Long(a);
            args.push(val_6);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "playSound", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Get an array containing the names of all the {@link GameRule}s.
    pub fn game_rules(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getGameRules", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Get the current value for a given {@link GameRule}.
    pub fn get_game_rule_value(
        &self,
        rule: impl Into<crate::GameRule<'mc>>,
    ) -> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/GameRule;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(rule.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")LT;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getGameRuleValue", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(res.l()?))
    }
    #[deprecated]
    /// Set the specified gamerule to specified value.The rule may attempt to validate the value passed, will return true if value was set.If rule is null, the function will return false.
    pub fn set_game_rule_value(
        &self,
        rule: impl Into<String>,
        value: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;Ljava/lang/String;)Z");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(rule.into())?,
        ));
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(value.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setGameRuleValue",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks if string is a valid game rule
    pub fn is_game_rule(
        &self,
        rule: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Z");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(rule.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isGameRule",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Get the default value for a given {@link GameRule}. This value is not
    /// guaranteed to match the current value.
    pub fn get_game_rule_default(
        &self,
        rule: impl Into<crate::GameRule<'mc>>,
    ) -> Result<Option<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/GameRule;)LT;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(rule.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getGameRuleDefault",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(res.l()?))
    }
    /// Set the given {@link GameRule}'s new value.
    pub fn set_game_rule(
        &self,
        rule: impl Into<crate::GameRule<'mc>>,
        new_value: jni::objects::JObject<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/GameRule;LT;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(rule.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(new_value);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setGameRule",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the world border for this world.
    pub fn world_border(&self) -> Result<crate::WorldBorder<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/WorldBorder;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getWorldBorder", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::WorldBorder::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Spawns the particle (the number of times specified by count)
    /// at the target location. The position of each particle will be
    /// randomized positively and negatively by the offset parameters
    /// on each axis.
    pub fn spawn_particle(
        &self,
        particle: impl Into<crate::Particle<'mc>>,
        x: f64,
        y: f64,
        z: std::option::Option<f64>,
        count: std::option::Option<i32>,
        offset_x: std::option::Option<f64>,
        offset_y: std::option::Option<f64>,
        offset_z: std::option::Option<f64>,
        extra: std::option::Option<f64>,
        data: std::option::Option<jni::objects::JObject<'mc>>,
        force: std::option::Option<bool>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Particle;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(particle.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "D";
        let val_2 = jni::objects::JValueGen::Double(x);
        args.push(val_2);
        sig += "D";
        let val_3 = jni::objects::JValueGen::Double(y);
        args.push(val_3);
        if let Some(a) = z {
            sig += "D";
            let val_4 = jni::objects::JValueGen::Double(a);
            args.push(val_4);
        }
        if let Some(a) = count {
            sig += "I";
            let val_5 = jni::objects::JValueGen::Int(a);
            args.push(val_5);
        }
        if let Some(a) = offset_x {
            sig += "D";
            let val_6 = jni::objects::JValueGen::Double(a);
            args.push(val_6);
        }
        if let Some(a) = offset_y {
            sig += "D";
            let val_7 = jni::objects::JValueGen::Double(a);
            args.push(val_7);
        }
        if let Some(a) = offset_z {
            sig += "D";
            let val_8 = jni::objects::JValueGen::Double(a);
            args.push(val_8);
        }
        if let Some(a) = extra {
            sig += "D";
            let val_9 = jni::objects::JValueGen::Double(a);
            args.push(val_9);
        }
        if let Some(a) = data {
            sig += "LT;";
            let val_10 = jni::objects::JValueGen::Object(a);
            args.push(val_10);
        }
        if let Some(a) = force {
            sig += "Z";
            let val_11 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_11);
        }
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "spawnParticle", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Find the closest nearby structure of a given {@link Structure}. Finding
    /// unexplored structures can, and will, block if the world is looking in
    /// chunks that gave not generated yet. This can lead to the world
    /// temporarily freezing while locating an unexplored structure.
    ///
    /// The {@code radius} is not a rigid square radius. Each structure may alter
    /// how many chunks to check for each iteration. Do not assume that only a
    /// radius x radius chunk area will be checked. For example,
    /// {@link Structure#MANSION} can potentially check up to 20,000 blocks away
    /// (or more) regardless of the radius used.
    ///
    /// This will <i>not</i> load or generate chunks. This can also lead to
    /// instances where the server can hang if you are only looking for
    /// unexplored structures. This is because it will keep looking further and
    /// further out in order to find the structure.
    ///
    /// The difference between searching for a {@link StructureType} and a
    /// {@link Structure} is, that a {@link StructureType} can refer to multiple
    /// {@link Structure Structures} while searching for a {@link Structure}
    /// while only search for the given {@link Structure}.
    pub fn locate_nearest_structure(
        &self,
        origin: impl Into<crate::Location<'mc>>,
        structure: impl Into<crate::generator::structure::Structure<'mc>>,
        radius: i32,
        find_unexplored: bool,
    ) -> Result<Option<crate::util::StructureSearchResult<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(origin.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/generator/structure/Structure;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(structure.into().jni_object().clone())
        });
        args.push(val_2);
        sig += "I";
        let val_3 = jni::objects::JValueGen::Int(radius);
        args.push(val_3);
        sig += "Z";
        let val_4 = jni::objects::JValueGen::Bool(find_unexplored.into());
        args.push(val_4);
        sig += ")Lorg/bukkit/util/StructureSearchResult;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "locateNearestStructure",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::util::StructureSearchResult::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Find the closest nearby location with a biome matching the provided
    /// {@link Biome}(s). Finding biomes can, and will, block if the world is looking
    /// in chunks that have not generated yet. This can lead to the world temporarily
    /// freezing while locating a biome.
    ///
    /// <b>Note:</b> This will <i>not</i> reflect changes made to the world after
    /// generation, this method only sees the biome at the time of world generation.
    /// This will <i>not</i> load or generate chunks.
    ///
    /// If multiple biomes are provided {@link BiomeSearchResult#getBiome()} will
    /// indicate which one was located. Higher values for {@code horizontalInterval}
    /// and {@code verticalInterval} will result in faster searches, but may lead to
    /// small biomes being missed.
    pub fn locate_nearest_biome(
        &self,
        origin: impl Into<crate::Location<'mc>>,
        radius: i32,
        horizontal_interval: i32,
        vertical_interval: std::option::Option<i32>,
        biomes: std::option::Option<impl Into<crate::block::Biome<'mc>>>,
    ) -> Result<Option<crate::util::BiomeSearchResult<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(origin.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(radius);
        args.push(val_2);
        sig += "I";
        let val_3 = jni::objects::JValueGen::Int(horizontal_interval);
        args.push(val_3);
        if let Some(a) = vertical_interval {
            sig += "I";
            let val_4 = jni::objects::JValueGen::Int(a);
            args.push(val_4);
        }
        if let Some(a) = biomes {
            sig += "Lorg/bukkit/block/Biome;";
            let val_5 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_5);
        }
        sig += ")Lorg/bukkit/util/BiomeSearchResult;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "locateNearestBiome",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::util::BiomeSearchResult::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Finds the nearest raid close to the given location.
    pub fn locate_nearest_raid(
        &self,
        location: impl Into<crate::Location<'mc>>,
        radius: i32,
    ) -> Result<Option<crate::Raid<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;I)Lorg/bukkit/Raid;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Int(radius);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "locateNearestRaid",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Raid::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Gets all raids that are going on over this world.
    pub fn raids(&self) -> Result<Vec<crate::Raid<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getRaids", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::Raid::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Get the {@link DragonBattle} associated with this world.
    /// If this world's environment is not {@link Environment#THE_END}, null will
    /// be returned.
    ///
    /// If an end world, a dragon battle instance will be returned regardless of
    /// whether or not a dragon is present in the world or a fight sequence has
    /// been activated. The dragon battle instance acts as a state holder.
    pub fn ender_dragon_battle(
        &self,
    ) -> Result<Option<crate::boss::DragonBattle<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/boss/DragonBattle;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getEnderDragonBattle",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::boss::DragonBattle::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Get all {@link FeatureFlag} enabled in this world.
    pub fn feature_flags(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFeatureFlags", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets all generated structures of a given {@link Structure} that intersect
    /// the chunk at the given coordinates.
    ///
    /// If no structures are present an empty collection will be returned.
    pub fn get_structures(
        &self,
        x: i32,
        z: i32,
        structure: std::option::Option<impl Into<crate::generator::structure::Structure<'mc>>>,
    ) -> Result<Vec<crate::generator::structure::GeneratedStructure<'mc>>, Box<dyn std::error::Error>>
    {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(z);
        args.push(val_2);
        if let Some(a) = structure {
            sig += "Lorg/bukkit/generator/structure/Structure;";
            let val_3 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_3);
        }
        sig += ")Ljava/util/Collection;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getStructures", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::generator::structure::GeneratedStructure::from_raw(
                &self.jni_ref(),
                obj,
            )?);
        }
        Ok(new_vec)
    }
    /// Gets the {@link BlockState} at the given coordinates.
    pub fn get_block_state(
        &self,
        x: i32,
        y: std::option::Option<i32>,
        z: std::option::Option<i32>,
    ) -> Result<crate::block::BlockState<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = y {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/block/BlockState;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBlockState", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::BlockState::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the {@link BlockData} at the given coordinates.
    pub fn get_block_data(
        &self,
        x: i32,
        y: std::option::Option<i32>,
        z: std::option::Option<i32>,
    ) -> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = y {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/block/data/BlockData;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBlockData", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::data::BlockData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the type of the block at the given coordinates.
    pub fn get_type(
        &self,
        x: i32,
        y: std::option::Option<i32>,
        z: std::option::Option<i32>,
    ) -> Result<crate::Material<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = y {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/Material;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getType", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::Material::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the {@link BlockData} at the given coordinates.
    pub fn set_block_data(
        &self,
        x: i32,
        y: i32,
        z: std::option::Option<i32>,
        block_data: std::option::Option<impl Into<crate::block::data::BlockData<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(y);
        args.push(val_2);
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        if let Some(a) = block_data {
            sig += "Lorg/bukkit/block/data/BlockData;";
            let val_4 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_4);
        }
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "setBlockData", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets the {@link Material} at the given coordinates.
    pub fn set_type(
        &self,
        x: i32,
        y: i32,
        z: std::option::Option<i32>,
        material: std::option::Option<impl Into<crate::Material<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(y);
        args.push(val_2);
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        if let Some(a) = material {
            sig += "Lorg/bukkit/Material;";
            let val_4 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_4);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "setType", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Creates a new entity at the given {@link Location}.
    pub fn spawn_entity(
        &self,
        loc: impl Into<crate::Location<'mc>>,
        val_type: impl Into<crate::entity::EntityType<'mc>>,
        randomize_data: std::option::Option<bool>,
    ) -> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(loc.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/entity/EntityType;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(val_type.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = randomize_data {
            sig += "Z";
            let val_3 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/entity/Entity;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "spawnEntity", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::Entity::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Creates an entity of a specific class at the given {@link Location} but
    /// does not spawn it in the world.
    ///
    /// <b>Note:</b> The created entity keeps a reference to the world it was
    /// created in, care should be taken that the entity does not outlive the
    /// world instance as this will lead to memory leaks.
    pub fn create_entity(
        &self,
        location: impl Into<crate::Location<'mc>>,
        clazz: jni::objects::JClass<'mc>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;Ljava/lang/Class;)LT;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(clazz.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "createEntity",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }
    /// Gets the highest coordinate corresponding to the {@link HeightMap} at the
    /// given {@link Location}.
    pub fn get_highest_block_yat(
        &self,
        location: impl Into<crate::Location<'mc>>,
        height_map: std::option::Option<impl Into<crate::HeightMap<'mc>>>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = height_map {
            sig += "Lorg/bukkit/HeightMap;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")I";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getHighestBlockYAt",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Spawns a previously created entity in the world.
    ///
    /// The provided entity must not have already been spawned in a world.
    pub fn add_entity(
        &self,
        entity: jni::objects::JObject<'mc>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(LT;)LT;");
        let val_1 = jni::objects::JValueGen::Object(entity);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "addEntity",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }
    /// Gets the unique name of this world
    pub fn name(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getName", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets the Unique ID of this world
    pub fn uid(&self) -> Result<blackboxmc_java::util::JavaUUID<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/UUID;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getUID", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaUUID::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the {@link World.Environment} type of this world
    pub fn environment(&self) -> Result<crate::WorldEnvironment<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/World/Environment;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getEnvironment", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::WorldEnvironment::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the Seed for this world.
    pub fn seed(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getSeed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    /// Gets the minimum height of this world.
    ///
    /// If the min height is 0, there are only blocks from y=0.
    pub fn min_height(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMinHeight", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the maximum height of this world.
    ///
    /// If the max height is 100, there are only blocks from y=0 to y=99.
    pub fn max_height(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxHeight", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sends this recipient a Plugin Message on the specified outgoing
    /// channel.
    ///
    /// The message may not be larger than {@link Messenger#MAX_MESSAGE_SIZE}
    /// bytes, and the plugin must be registered to send messages on the
    /// specified channel.
    pub fn send_plugin_message(
        &self,
        source: impl Into<crate::plugin::Plugin<'mc>>,
        channel: impl Into<String>,
        message: i8,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/plugin/Plugin;Ljava/lang/String;B)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(source.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(channel.into())?,
        ));
        let val_3 = jni::objects::JValueGen::Byte(message);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "sendPluginMessage",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets a set containing all the Plugin Channels that this client is
    /// listening on.
    pub fn listening_plugin_channels(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getListeningPluginChannels",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets a metadata value in the implementing object's metadata store.
    pub fn set_metadata(
        &self,
        metadata_key: impl Into<String>,
        new_metadata_value: std::option::Option<impl Into<crate::metadata::MetadataValue<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(metadata_key.into())?,
        ));
        args.push(val_1);
        if let Some(a) = new_metadata_value {
            sig += "Lorg/bukkit/metadata/MetadataValue;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "setMetadata", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Returns a list of previously set metadata values from the implementing
    /// object's metadata store.
    pub fn get_metadata(
        &self,
        metadata_key: impl Into<String>,
    ) -> Result<Vec<crate::metadata::MetadataValue<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(metadata_key.into())?,
        ));
        args.push(val_1);
        sig += ")Ljava/util/List;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getMetadata", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::metadata::MetadataValue::from_raw(
                &self.jni_ref(),
                obj,
            )?);
        }
        Ok(new_vec)
    }
    /// Tests to see whether the implementing object contains the given
    /// metadata value in its metadata store.
    pub fn has_metadata(
        &self,
        metadata_key: impl Into<String>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(metadata_key.into())?,
        ));
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hasMetadata", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Removes the given metadata value from the implementing object's
    /// metadata store.
    pub fn remove_metadata(
        &self,
        metadata_key: impl Into<String>,
        owning_plugin: impl Into<crate::plugin::Plugin<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(metadata_key.into())?,
        ));
        args.push(val_1);
        sig += "Lorg/bukkit/plugin/Plugin;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(owning_plugin.into().jni_object().clone())
        });
        args.push(val_2);
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "removeMetadata", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Returns a custom tag container capable of storing tags on the object.
    /// Note that the tags stored on this container are all stored under their
    /// own custom namespace therefore modifying default tags using this
    /// {@link PersistentDataHolder} is impossible.
    pub fn persistent_data_container(
        &self,
    ) -> Result<crate::persistence::PersistentDataContainer<'mc>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Lorg/bukkit/persistence/PersistentDataContainer;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getPersistentDataContainer",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::persistence::PersistentDataContainer::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Return the namespaced identifier for this object.
    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::RegionAccessor<'mc>> for World<'mc> {
    fn into(self) -> crate::RegionAccessor<'mc> {
        crate::RegionAccessor::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting World into crate::RegionAccessor")
    }
}
impl<'mc> Into<crate::generator::WorldInfo<'mc>> for World<'mc> {
    fn into(self) -> crate::generator::WorldInfo<'mc> {
        crate::generator::WorldInfo::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting World into crate::generator::WorldInfo")
    }
}
impl<'mc> Into<crate::plugin::messaging::PluginMessageRecipient<'mc>> for World<'mc> {
    fn into(self) -> crate::plugin::messaging::PluginMessageRecipient<'mc> {
        crate::plugin::messaging::PluginMessageRecipient::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting World into crate::plugin::messaging::PluginMessageRecipient")
    }
}
impl<'mc> Into<crate::metadata::Metadatable<'mc>> for World<'mc> {
    fn into(self) -> crate::metadata::Metadatable<'mc> {
        crate::metadata::Metadatable::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting World into crate::metadata::Metadatable")
    }
}
impl<'mc> Into<crate::persistence::PersistentDataHolder<'mc>> for World<'mc> {
    fn into(self) -> crate::persistence::PersistentDataHolder<'mc> {
        crate::persistence::PersistentDataHolder::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting World into crate::persistence::PersistentDataHolder")
    }
}
impl<'mc> Into<crate::Keyed<'mc>> for World<'mc> {
    fn into(self) -> crate::Keyed<'mc> {
        crate::Keyed::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting World into crate::Keyed")
    }
}
pub enum WorldEnvironment<'mc> {}
impl<'mc> std::fmt::Display for WorldEnvironment<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> WorldEnvironment<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<WorldEnvironment<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/World/Environment");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/World/Environment;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct WorldEnvironmentStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for WorldEnvironment<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for WorldEnvironment<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate WorldEnvironment from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/World/Environment")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WorldEnvironment object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for WorldEnvironmentStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WorldEnvironmentStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate WorldEnvironmentStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/World/Environment")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WorldEnvironmentStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> WorldEnvironmentStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::WorldEnvironment<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/World/Environment;");
        let cls = jni.find_class("org/bukkit/World/Environment");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::WorldEnvironment::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Gets the dimension ID of this environment
    pub fn id(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getId", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Get an environment by ID
    pub fn get_environment(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        id: i32,
    ) -> Result<Option<crate::WorldEnvironment<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Lorg/bukkit/World/Environment;");
        let val_1 = jni::objects::JValueGen::Int(id);
        let cls = jni.find_class("org/bukkit/World/Environment");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getEnvironment",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::WorldEnvironment::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct Vibration<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Vibration<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Vibration<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Vibration from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Vibration")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Vibration object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Vibration<'mc> {
    pub fn new(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        origin: impl Into<crate::Location<'mc>>,
        destination: impl Into<crate::VibrationDestination<'mc>>,
        arrival_time: i32,
    ) -> Result<crate::Vibration<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;Lorg/bukkit/Vibration/Destination;I)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(origin.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(destination.into().jni_object().clone())
        });
        let val_3 = jni::objects::JValueGen::Int(arrival_time);
        let cls = jni.find_class("org/bukkit/Vibration");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.new_object(
            cls,
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = jni.translate_error_no_gen(res)?;
        crate::Vibration::from_raw(&jni, res)
    }
    /// Get the origin of the vibration.
    pub fn origin(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getOrigin", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Get the vibration destination.
    pub fn destination(
        &self,
    ) -> Result<crate::VibrationDestination<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Vibration/Destination;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDestination", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::VibrationDestination::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Get the vibration arrival time in ticks.
    pub fn arrival_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getArrivalTime", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct VibrationDestination<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for VibrationDestination<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for VibrationDestination<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate VibrationDestination from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Vibration/Destination")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a VibrationDestination object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> VibrationDestination<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct VibrationDestinationEntityDestination<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for VibrationDestinationEntityDestination<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for VibrationDestinationEntityDestination<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate VibrationDestinationEntityDestination from null object."
            )
            .into());
        }
        let (valid, name) =
            env.validate_name(&obj, "org/bukkit/Vibration/Destination/EntityDestination")?;
        if !valid {
            Err(eyre::eyre!(
                    "Invalid argument passed. Expected a VibrationDestinationEntityDestination object, got {}",
                    name
                )
                .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> VibrationDestinationEntityDestination<'mc> {
    pub fn new(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        entity: impl Into<crate::entity::Entity<'mc>>,
    ) -> Result<crate::VibrationDestinationEntityDestination<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/entity/Entity;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(entity.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Vibration/Destination/EntityDestination");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.new_object(
            cls,
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error_no_gen(res)?;
        crate::VibrationDestinationEntityDestination::from_raw(&jni, res)
    }

    pub fn entity(&self) -> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/entity/Entity;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getEntity", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::Entity::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::VibrationDestination<'mc>> for VibrationDestinationEntityDestination<'mc> {
    fn into(self) -> crate::VibrationDestination<'mc> {
        crate::VibrationDestination::from_raw(&self.jni_ref(), self.1).expect("Error converting VibrationDestinationEntityDestination into crate::VibrationDestination")
    }
}
#[repr(C)]
pub struct VibrationDestinationBlockDestination<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for VibrationDestinationBlockDestination<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for VibrationDestinationBlockDestination<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate VibrationDestinationBlockDestination from null object."
            )
            .into());
        }
        let (valid, name) =
            env.validate_name(&obj, "org/bukkit/Vibration/Destination/BlockDestination")?;
        if !valid {
            Err(eyre::eyre!(
                    "Invalid argument passed. Expected a VibrationDestinationBlockDestination object, got {}",
                    name
                )
                .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> VibrationDestinationBlockDestination<'mc> {
    pub fn new(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        block: impl Into<crate::block::Block<'mc>>,
    ) -> Result<crate::VibrationDestinationBlockDestination<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/block/Block;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(block.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")V";
        let cls = jni.find_class("org/bukkit/Vibration/Destination/BlockDestination");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.new_object(cls, sig.as_str(), args);
        let res = jni.translate_error_no_gen(res)?;
        crate::VibrationDestinationBlockDestination::from_raw(&jni, res)
    }

    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLocation", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn block(&self) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/block/Block;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBlock", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Block::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
impl<'mc> Into<crate::VibrationDestination<'mc>> for VibrationDestinationBlockDestination<'mc> {
    fn into(self) -> crate::VibrationDestination<'mc> {
        crate::VibrationDestination::from_raw(&self.jni_ref(), self.1).expect("Error converting VibrationDestinationBlockDestination into crate::VibrationDestination")
    }
}
pub enum ChatColor<'mc> {
    ColorChar { inner: ChatColorStruct<'mc> },
}
impl<'mc> std::fmt::Display for ChatColor<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ChatColor::ColorChar { .. } => f.write_str("COLOR_CHAR"),
        }
    }
}

impl<'mc> ChatColor<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<ChatColor<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/ChatColor");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/ChatColor;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "COLOR_CHAR" => Ok(ChatColor::ColorChar {
                inner: ChatColorStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct ChatColorStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ChatColor<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::ColorChar { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::ColorChar { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ChatColor<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ChatColor from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/ChatColor")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ChatColor object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "COLOR_CHAR" => Ok(ChatColor::ColorChar {
                    inner: ChatColorStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for ChatColorStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ChatColorStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate ChatColorStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/ChatColor")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ChatColorStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ChatColorStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::ChatColor<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/ChatColor;");
        let cls = jni.find_class("org/bukkit/ChatColor");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::ChatColor::from_raw(&jni, obj)
    }
    /// Gets the char value associated with this color
    pub fn char(&self) -> Result<u16, Box<dyn std::error::Error>> {
        let sig = String::from("()C");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getChar", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.c()?)
    }

    #[doc(hidden)]
    pub fn internal_to_string(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "toString", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Checks if this code is a format code as opposed to a color code.
    pub fn is_format(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isFormat", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks if this code is a color code as opposed to a format code.
    pub fn is_color(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isColor", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the color represented by the specified color code
    pub fn get_by_char(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        code: impl Into<String>,
    ) -> Result<Option<crate::ChatColor<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(code.into())?,
        ));
        args.push(val_1);
        sig += ")Lorg/bukkit/ChatColor;";
        let cls = jni.find_class("org/bukkit/ChatColor");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getByChar", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::ChatColor::from_raw(&jni, obj)?))
    }
    /// Strips the given message of all color codes
    pub fn strip_color(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        input: impl Into<String>,
    ) -> Result<Option<String>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Ljava/lang/String;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(input.into())?,
        ));
        let cls = jni.find_class("org/bukkit/ChatColor");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "stripColor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(
            jni.get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
                .to_string_lossy()
                .to_string(),
        ))
    }
    /// Translates a string using an alternate color code character into a
    /// string that uses the internal ChatColor.COLOR_CODE color code
    /// character. The alternate color code character will only be replaced if
    /// it is immediately followed by 0-9, A-F, a-f, K-O, k-o, R or r.
    pub fn translate_alternate_color_codes(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        alt_color_char: u16,
        text_to_translate: impl Into<String>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("(CLjava/lang/String;)Ljava/lang/String;");
        let val_1 = jni::objects::JValueGen::Char(alt_color_char);
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(text_to_translate.into())?,
        ));
        let cls = jni.find_class("org/bukkit/ChatColor");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "translateAlternateColorCodes",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = jni.translate_error(res)?;
        Ok(jni
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets the ChatColors used at the end of the given input string.
    pub fn get_last_colors(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        input: impl Into<String>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Ljava/lang/String;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(input.into())?,
        ));
        let cls = jni.find_class("org/bukkit/ChatColor");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getLastColors",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        Ok(jni
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct Note<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Note<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Note<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Note from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Note")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Note object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Note<'mc> {
    /// Creates a new note.
    pub fn new(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        octave: i32,
        tone: std::option::Option<impl Into<crate::NoteTone<'mc>>>,
        sharped: std::option::Option<bool>,
    ) -> Result<crate::Note<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(octave);
        args.push(val_1);
        if let Some(a) = tone {
            sig += "Lorg/bukkit/Note/Tone;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        if let Some(a) = sharped {
            sig += "Z";
            let val_3 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_3);
        }
        sig += ")V";
        let cls = jni.find_class("org/bukkit/Note");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.new_object(cls, sig.as_str(), args);
        let res = jni.translate_error_no_gen(res)?;
        crate::Note::from_raw(&jni, res)
    }
    /// Creates a new note for a flat tone, such as A-flat.
    pub fn flat(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        octave: i32,
        tone: impl Into<crate::NoteTone<'mc>>,
    ) -> Result<crate::Note<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(ILorg/bukkit/Note/Tone;)Lorg/bukkit/Note;");
        let val_1 = jni::objects::JValueGen::Int(octave);
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(tone.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Note");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "flat",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Note::from_raw(&jni, obj)
    }
    /// Creates a new note for a sharp tone, such as A-sharp.
    pub fn sharp(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        octave: i32,
        tone: impl Into<crate::NoteTone<'mc>>,
    ) -> Result<crate::Note<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(ILorg/bukkit/Note/Tone;)Lorg/bukkit/Note;");
        let val_1 = jni::objects::JValueGen::Int(octave);
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(tone.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Note");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "sharp",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Note::from_raw(&jni, obj)
    }
    /// Creates a new note for a natural tone, such as A-natural.
    pub fn natural(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        octave: i32,
        tone: impl Into<crate::NoteTone<'mc>>,
    ) -> Result<crate::Note<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(ILorg/bukkit/Note/Tone;)Lorg/bukkit/Note;");
        let val_1 = jni::objects::JValueGen::Int(octave);
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(tone.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Note");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "natural",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Note::from_raw(&jni, obj)
    }

    pub fn sharped(&self) -> Result<crate::Note<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Note;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "sharped", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Note::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn flattened(&self) -> Result<crate::Note<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Note;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "flattened", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Note::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    #[deprecated]
    /// Returns the internal id of this note.
    pub fn id(&self) -> Result<i8, Box<dyn std::error::Error>> {
        let sig = String::from("()B");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getId", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.b()?)
    }
    /// Returns the octave of this note.
    pub fn octave(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getOctave", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Returns the tone of this note.
    pub fn tone(&self) -> Result<crate::NoteTone<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Note/Tone;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getTone", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NoteTone::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Returns if this note is sharped.
    pub fn is_sharped(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isSharped", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the pitch of this note. This is the value used with
    /// {@link World#playSound} or the /playsound command.
    pub fn pitch(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getPitch", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }

    pub fn hash_code(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hashCode", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn equals(
        &self,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/Object;)Z");
        let val_1 = jni::objects::JValueGen::Object(obj);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "equals",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    #[doc(hidden)]
    pub fn internal_to_string(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "toString", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}

impl<'mc> std::string::ToString for Note<'mc> {
    fn to_string(&self) -> String {
        match &self.internal_to_string() {
            Ok(a) => a.clone(),
            Err(err) => format!("Error calling Note.toString: {}", err),
        }
    }
}

pub enum NoteTone<'mc> {
    TonesCount { inner: NoteToneStruct<'mc> },
}
impl<'mc> std::fmt::Display for NoteTone<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            NoteTone::TonesCount { .. } => f.write_str("TONES_COUNT"),
        }
    }
}

impl<'mc> NoteTone<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<NoteTone<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Note/Tone");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Note/Tone;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "TONES_COUNT" => Ok(NoteTone::TonesCount {
                inner: NoteToneStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct NoteToneStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for NoteTone<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::TonesCount { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::TonesCount { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for NoteTone<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate NoteTone from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Note/Tone")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a NoteTone object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "TONES_COUNT" => Ok(NoteTone::TonesCount {
                    inner: NoteToneStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for NoteToneStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for NoteToneStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate NoteToneStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Note/Tone")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a NoteToneStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> NoteToneStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::NoteTone<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Note/Tone;");
        let cls = jni.find_class("org/bukkit/Note/Tone");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::NoteTone::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Returns the id of this tone. These method allows to return the sharped id of the tone. If the tone couldn't be sharped it always return the not sharped id of this tone.
    pub fn get_id(&self, sharped: bool) -> Result<i8, Box<dyn std::error::Error>> {
        let sig = String::from("(Z)B");
        let val_1 = jni::objects::JValueGen::Bool(sharped.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getId",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.b()?)
    }
    /// Returns if this tone could be sharped.
    pub fn is_sharpable(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isSharpable", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]
    /// Returns if this tone id is the sharped id of the tone.
    pub fn is_sharped(&self, id: i8) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(B)Z");
        let val_1 = jni::objects::JValueGen::Byte(id);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isSharped",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    #[deprecated]
    /// Returns the tone to id. Also returning the semitones.
    pub fn get_by_id(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        id: i8,
    ) -> Result<Option<crate::NoteTone<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(B)Lorg/bukkit/Note/Tone;");
        let val_1 = jni::objects::JValueGen::Byte(id);
        let cls = jni.find_class("org/bukkit/Note/Tone");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getById",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::NoteTone::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum Instrument<'mc> {}
impl<'mc> std::fmt::Display for Instrument<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> Instrument<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Instrument<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Instrument");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Instrument;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct InstrumentStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Instrument<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for Instrument<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Instrument from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Instrument")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Instrument object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for InstrumentStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for InstrumentStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate InstrumentStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Instrument")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a InstrumentStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> InstrumentStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::Instrument<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Instrument;");
        let cls = jni.find_class("org/bukkit/Instrument");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Instrument::from_raw(&jni, obj)
    }
    /// Gets the sound associated with this instrument.
    ///
    /// Will be null for {@link Instrument#CUSTOM_HEAD}
    pub fn sound(&self) -> Result<Option<crate::Sound<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getSound", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    #[deprecated]

    pub fn get_type(&self) -> Result<i8, Box<dyn std::error::Error>> {
        let sig = String::from("()B");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.b()?)
    }
    #[deprecated]
    /// Get an instrument by its type ID.
    pub fn get_by_type(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        val_type: i8,
    ) -> Result<Option<crate::Instrument<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(B)Lorg/bukkit/Instrument;");
        let val_1 = jni::objects::JValueGen::Byte(val_type);
        let cls = jni.find_class("org/bukkit/Instrument");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByType",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::Instrument::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum SkullType<'mc> {}
impl<'mc> std::fmt::Display for SkullType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> SkullType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<SkullType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/SkullType");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/SkullType;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct SkullTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SkullType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for SkullType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SkullType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/SkullType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SkullType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for SkullTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SkullTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate SkullTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/SkullType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SkullTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SkullTypeStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::SkullType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/SkullType;");
        let cls = jni.find_class("org/bukkit/SkullType");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::SkullType::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum GameRule<'mc> {
    AnnounceAdvancements { inner: GameRuleStruct<'mc> },
    CommandBlockOutput { inner: GameRuleStruct<'mc> },
    DisableElytraMovementCheck { inner: GameRuleStruct<'mc> },
    DoDaylightCycle { inner: GameRuleStruct<'mc> },
    DoEntityDrops { inner: GameRuleStruct<'mc> },
    DoFireTick { inner: GameRuleStruct<'mc> },
    DoLimitedCrafting { inner: GameRuleStruct<'mc> },
    DoMobLoot { inner: GameRuleStruct<'mc> },
    ProjectilesCanBreakBlocks { inner: GameRuleStruct<'mc> },
    DoMobSpawning { inner: GameRuleStruct<'mc> },
    DoTileDrops { inner: GameRuleStruct<'mc> },
    DoWeatherCycle { inner: GameRuleStruct<'mc> },
    KeepInventory { inner: GameRuleStruct<'mc> },
    LogAdminCommands { inner: GameRuleStruct<'mc> },
    MobGriefing { inner: GameRuleStruct<'mc> },
    NaturalRegeneration { inner: GameRuleStruct<'mc> },
    ReducedDebugInfo { inner: GameRuleStruct<'mc> },
    SendCommandFeedback { inner: GameRuleStruct<'mc> },
    ShowDeathMessages { inner: GameRuleStruct<'mc> },
    SpectatorsGenerateChunks { inner: GameRuleStruct<'mc> },
    DisableRaids { inner: GameRuleStruct<'mc> },
    DoInsomnia { inner: GameRuleStruct<'mc> },
    DoImmediateRespawn { inner: GameRuleStruct<'mc> },
    DrowningDamage { inner: GameRuleStruct<'mc> },
    FallDamage { inner: GameRuleStruct<'mc> },
    FireDamage { inner: GameRuleStruct<'mc> },
    FreezeDamage { inner: GameRuleStruct<'mc> },
    DoPatrolSpawning { inner: GameRuleStruct<'mc> },
    DoTraderSpawning { inner: GameRuleStruct<'mc> },
    DoWardenSpawning { inner: GameRuleStruct<'mc> },
    ForgiveDeadPlayers { inner: GameRuleStruct<'mc> },
    UniversalAnger { inner: GameRuleStruct<'mc> },
    BlockExplosionDropDecay { inner: GameRuleStruct<'mc> },
    MobExplosionDropDecay { inner: GameRuleStruct<'mc> },
    TntExplosionDropDecay { inner: GameRuleStruct<'mc> },
    WaterSourceConversion { inner: GameRuleStruct<'mc> },
    LavaSourceConversion { inner: GameRuleStruct<'mc> },
    GlobalSoundEvents { inner: GameRuleStruct<'mc> },
    DoVinesSpread { inner: GameRuleStruct<'mc> },
    EnderPearlsVanishOnDeath { inner: GameRuleStruct<'mc> },
    RandomTickSpeed { inner: GameRuleStruct<'mc> },
    SpawnRadius { inner: GameRuleStruct<'mc> },
    MaxEntityCramming { inner: GameRuleStruct<'mc> },
    MaxCommandChainLength { inner: GameRuleStruct<'mc> },
    MaxCommandForkCount { inner: GameRuleStruct<'mc> },
    CommandModificationBlockLimit { inner: GameRuleStruct<'mc> },
    PlayersSleepingPercentage { inner: GameRuleStruct<'mc> },
    SnowAccumulationHeight { inner: GameRuleStruct<'mc> },
    PlayersNetherPortalDefaultDelay { inner: GameRuleStruct<'mc> },
    PlayersNetherPortalCreativeDelay { inner: GameRuleStruct<'mc> },
    SpawnChunkRadius { inner: GameRuleStruct<'mc> },
}
impl<'mc> std::fmt::Display for GameRule<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GameRule::AnnounceAdvancements { .. } => f.write_str("ANNOUNCE_ADVANCEMENTS"),
            GameRule::CommandBlockOutput { .. } => f.write_str("COMMAND_BLOCK_OUTPUT"),
            GameRule::DisableElytraMovementCheck { .. } => {
                f.write_str("DISABLE_ELYTRA_MOVEMENT_CHECK")
            }
            GameRule::DoDaylightCycle { .. } => f.write_str("DO_DAYLIGHT_CYCLE"),
            GameRule::DoEntityDrops { .. } => f.write_str("DO_ENTITY_DROPS"),
            GameRule::DoFireTick { .. } => f.write_str("DO_FIRE_TICK"),
            GameRule::DoLimitedCrafting { .. } => f.write_str("DO_LIMITED_CRAFTING"),
            GameRule::DoMobLoot { .. } => f.write_str("DO_MOB_LOOT"),
            GameRule::ProjectilesCanBreakBlocks { .. } => {
                f.write_str("PROJECTILES_CAN_BREAK_BLOCKS")
            }
            GameRule::DoMobSpawning { .. } => f.write_str("DO_MOB_SPAWNING"),
            GameRule::DoTileDrops { .. } => f.write_str("DO_TILE_DROPS"),
            GameRule::DoWeatherCycle { .. } => f.write_str("DO_WEATHER_CYCLE"),
            GameRule::KeepInventory { .. } => f.write_str("KEEP_INVENTORY"),
            GameRule::LogAdminCommands { .. } => f.write_str("LOG_ADMIN_COMMANDS"),
            GameRule::MobGriefing { .. } => f.write_str("MOB_GRIEFING"),
            GameRule::NaturalRegeneration { .. } => f.write_str("NATURAL_REGENERATION"),
            GameRule::ReducedDebugInfo { .. } => f.write_str("REDUCED_DEBUG_INFO"),
            GameRule::SendCommandFeedback { .. } => f.write_str("SEND_COMMAND_FEEDBACK"),
            GameRule::ShowDeathMessages { .. } => f.write_str("SHOW_DEATH_MESSAGES"),
            GameRule::SpectatorsGenerateChunks { .. } => f.write_str("SPECTATORS_GENERATE_CHUNKS"),
            GameRule::DisableRaids { .. } => f.write_str("DISABLE_RAIDS"),
            GameRule::DoInsomnia { .. } => f.write_str("DO_INSOMNIA"),
            GameRule::DoImmediateRespawn { .. } => f.write_str("DO_IMMEDIATE_RESPAWN"),
            GameRule::DrowningDamage { .. } => f.write_str("DROWNING_DAMAGE"),
            GameRule::FallDamage { .. } => f.write_str("FALL_DAMAGE"),
            GameRule::FireDamage { .. } => f.write_str("FIRE_DAMAGE"),
            GameRule::FreezeDamage { .. } => f.write_str("FREEZE_DAMAGE"),
            GameRule::DoPatrolSpawning { .. } => f.write_str("DO_PATROL_SPAWNING"),
            GameRule::DoTraderSpawning { .. } => f.write_str("DO_TRADER_SPAWNING"),
            GameRule::DoWardenSpawning { .. } => f.write_str("DO_WARDEN_SPAWNING"),
            GameRule::ForgiveDeadPlayers { .. } => f.write_str("FORGIVE_DEAD_PLAYERS"),
            GameRule::UniversalAnger { .. } => f.write_str("UNIVERSAL_ANGER"),
            GameRule::BlockExplosionDropDecay { .. } => f.write_str("BLOCK_EXPLOSION_DROP_DECAY"),
            GameRule::MobExplosionDropDecay { .. } => f.write_str("MOB_EXPLOSION_DROP_DECAY"),
            GameRule::TntExplosionDropDecay { .. } => f.write_str("TNT_EXPLOSION_DROP_DECAY"),
            GameRule::WaterSourceConversion { .. } => f.write_str("WATER_SOURCE_CONVERSION"),
            GameRule::LavaSourceConversion { .. } => f.write_str("LAVA_SOURCE_CONVERSION"),
            GameRule::GlobalSoundEvents { .. } => f.write_str("GLOBAL_SOUND_EVENTS"),
            GameRule::DoVinesSpread { .. } => f.write_str("DO_VINES_SPREAD"),
            GameRule::EnderPearlsVanishOnDeath { .. } => {
                f.write_str("ENDER_PEARLS_VANISH_ON_DEATH")
            }
            GameRule::RandomTickSpeed { .. } => f.write_str("RANDOM_TICK_SPEED"),
            GameRule::SpawnRadius { .. } => f.write_str("SPAWN_RADIUS"),
            GameRule::MaxEntityCramming { .. } => f.write_str("MAX_ENTITY_CRAMMING"),
            GameRule::MaxCommandChainLength { .. } => f.write_str("MAX_COMMAND_CHAIN_LENGTH"),
            GameRule::MaxCommandForkCount { .. } => f.write_str("MAX_COMMAND_FORK_COUNT"),
            GameRule::CommandModificationBlockLimit { .. } => {
                f.write_str("COMMAND_MODIFICATION_BLOCK_LIMIT")
            }
            GameRule::PlayersSleepingPercentage { .. } => {
                f.write_str("PLAYERS_SLEEPING_PERCENTAGE")
            }
            GameRule::SnowAccumulationHeight { .. } => f.write_str("SNOW_ACCUMULATION_HEIGHT"),
            GameRule::PlayersNetherPortalDefaultDelay { .. } => {
                f.write_str("PLAYERS_NETHER_PORTAL_DEFAULT_DELAY")
            }
            GameRule::PlayersNetherPortalCreativeDelay { .. } => {
                f.write_str("PLAYERS_NETHER_PORTAL_CREATIVE_DELAY")
            }
            GameRule::SpawnChunkRadius { .. } => f.write_str("SPAWN_CHUNK_RADIUS"),
        }
    }
}

impl<'mc> GameRule<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<GameRule<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/GameRule");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/GameRule;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "ANNOUNCE_ADVANCEMENTS" => Ok(GameRule::AnnounceAdvancements {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "COMMAND_BLOCK_OUTPUT" => Ok(GameRule::CommandBlockOutput {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DISABLE_ELYTRA_MOVEMENT_CHECK" => Ok(GameRule::DisableElytraMovementCheck {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_DAYLIGHT_CYCLE" => Ok(GameRule::DoDaylightCycle {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_ENTITY_DROPS" => Ok(GameRule::DoEntityDrops {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_FIRE_TICK" => Ok(GameRule::DoFireTick {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_LIMITED_CRAFTING" => Ok(GameRule::DoLimitedCrafting {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_MOB_LOOT" => Ok(GameRule::DoMobLoot {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "PROJECTILES_CAN_BREAK_BLOCKS" => Ok(GameRule::ProjectilesCanBreakBlocks {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_MOB_SPAWNING" => Ok(GameRule::DoMobSpawning {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_TILE_DROPS" => Ok(GameRule::DoTileDrops {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_WEATHER_CYCLE" => Ok(GameRule::DoWeatherCycle {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "KEEP_INVENTORY" => Ok(GameRule::KeepInventory {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "LOG_ADMIN_COMMANDS" => Ok(GameRule::LogAdminCommands {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "MOB_GRIEFING" => Ok(GameRule::MobGriefing {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "NATURAL_REGENERATION" => Ok(GameRule::NaturalRegeneration {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "REDUCED_DEBUG_INFO" => Ok(GameRule::ReducedDebugInfo {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "SEND_COMMAND_FEEDBACK" => Ok(GameRule::SendCommandFeedback {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "SHOW_DEATH_MESSAGES" => Ok(GameRule::ShowDeathMessages {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "SPECTATORS_GENERATE_CHUNKS" => Ok(GameRule::SpectatorsGenerateChunks {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DISABLE_RAIDS" => Ok(GameRule::DisableRaids {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_INSOMNIA" => Ok(GameRule::DoInsomnia {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_IMMEDIATE_RESPAWN" => Ok(GameRule::DoImmediateRespawn {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DROWNING_DAMAGE" => Ok(GameRule::DrowningDamage {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "FALL_DAMAGE" => Ok(GameRule::FallDamage {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "FIRE_DAMAGE" => Ok(GameRule::FireDamage {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "FREEZE_DAMAGE" => Ok(GameRule::FreezeDamage {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_PATROL_SPAWNING" => Ok(GameRule::DoPatrolSpawning {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_TRADER_SPAWNING" => Ok(GameRule::DoTraderSpawning {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_WARDEN_SPAWNING" => Ok(GameRule::DoWardenSpawning {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "FORGIVE_DEAD_PLAYERS" => Ok(GameRule::ForgiveDeadPlayers {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "UNIVERSAL_ANGER" => Ok(GameRule::UniversalAnger {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "BLOCK_EXPLOSION_DROP_DECAY" => Ok(GameRule::BlockExplosionDropDecay {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "MOB_EXPLOSION_DROP_DECAY" => Ok(GameRule::MobExplosionDropDecay {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "TNT_EXPLOSION_DROP_DECAY" => Ok(GameRule::TntExplosionDropDecay {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "WATER_SOURCE_CONVERSION" => Ok(GameRule::WaterSourceConversion {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "LAVA_SOURCE_CONVERSION" => Ok(GameRule::LavaSourceConversion {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "GLOBAL_SOUND_EVENTS" => Ok(GameRule::GlobalSoundEvents {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "DO_VINES_SPREAD" => Ok(GameRule::DoVinesSpread {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "ENDER_PEARLS_VANISH_ON_DEATH" => Ok(GameRule::EnderPearlsVanishOnDeath {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "RANDOM_TICK_SPEED" => Ok(GameRule::RandomTickSpeed {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "SPAWN_RADIUS" => Ok(GameRule::SpawnRadius {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "MAX_ENTITY_CRAMMING" => Ok(GameRule::MaxEntityCramming {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "MAX_COMMAND_CHAIN_LENGTH" => Ok(GameRule::MaxCommandChainLength {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "MAX_COMMAND_FORK_COUNT" => Ok(GameRule::MaxCommandForkCount {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "COMMAND_MODIFICATION_BLOCK_LIMIT" => Ok(GameRule::CommandModificationBlockLimit {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "PLAYERS_SLEEPING_PERCENTAGE" => Ok(GameRule::PlayersSleepingPercentage {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "SNOW_ACCUMULATION_HEIGHT" => Ok(GameRule::SnowAccumulationHeight {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),
            "PLAYERS_NETHER_PORTAL_DEFAULT_DELAY" => {
                Ok(GameRule::PlayersNetherPortalDefaultDelay {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                })
            }
            "PLAYERS_NETHER_PORTAL_CREATIVE_DELAY" => {
                Ok(GameRule::PlayersNetherPortalCreativeDelay {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                })
            }
            "SPAWN_CHUNK_RADIUS" => Ok(GameRule::SpawnChunkRadius {
                inner: GameRuleStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct GameRuleStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for GameRule<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::AnnounceAdvancements { inner } => inner.0.clone(),
            Self::CommandBlockOutput { inner } => inner.0.clone(),
            Self::DisableElytraMovementCheck { inner } => inner.0.clone(),
            Self::DoDaylightCycle { inner } => inner.0.clone(),
            Self::DoEntityDrops { inner } => inner.0.clone(),
            Self::DoFireTick { inner } => inner.0.clone(),
            Self::DoLimitedCrafting { inner } => inner.0.clone(),
            Self::DoMobLoot { inner } => inner.0.clone(),
            Self::ProjectilesCanBreakBlocks { inner } => inner.0.clone(),
            Self::DoMobSpawning { inner } => inner.0.clone(),
            Self::DoTileDrops { inner } => inner.0.clone(),
            Self::DoWeatherCycle { inner } => inner.0.clone(),
            Self::KeepInventory { inner } => inner.0.clone(),
            Self::LogAdminCommands { inner } => inner.0.clone(),
            Self::MobGriefing { inner } => inner.0.clone(),
            Self::NaturalRegeneration { inner } => inner.0.clone(),
            Self::ReducedDebugInfo { inner } => inner.0.clone(),
            Self::SendCommandFeedback { inner } => inner.0.clone(),
            Self::ShowDeathMessages { inner } => inner.0.clone(),
            Self::SpectatorsGenerateChunks { inner } => inner.0.clone(),
            Self::DisableRaids { inner } => inner.0.clone(),
            Self::DoInsomnia { inner } => inner.0.clone(),
            Self::DoImmediateRespawn { inner } => inner.0.clone(),
            Self::DrowningDamage { inner } => inner.0.clone(),
            Self::FallDamage { inner } => inner.0.clone(),
            Self::FireDamage { inner } => inner.0.clone(),
            Self::FreezeDamage { inner } => inner.0.clone(),
            Self::DoPatrolSpawning { inner } => inner.0.clone(),
            Self::DoTraderSpawning { inner } => inner.0.clone(),
            Self::DoWardenSpawning { inner } => inner.0.clone(),
            Self::ForgiveDeadPlayers { inner } => inner.0.clone(),
            Self::UniversalAnger { inner } => inner.0.clone(),
            Self::BlockExplosionDropDecay { inner } => inner.0.clone(),
            Self::MobExplosionDropDecay { inner } => inner.0.clone(),
            Self::TntExplosionDropDecay { inner } => inner.0.clone(),
            Self::WaterSourceConversion { inner } => inner.0.clone(),
            Self::LavaSourceConversion { inner } => inner.0.clone(),
            Self::GlobalSoundEvents { inner } => inner.0.clone(),
            Self::DoVinesSpread { inner } => inner.0.clone(),
            Self::EnderPearlsVanishOnDeath { inner } => inner.0.clone(),
            Self::RandomTickSpeed { inner } => inner.0.clone(),
            Self::SpawnRadius { inner } => inner.0.clone(),
            Self::MaxEntityCramming { inner } => inner.0.clone(),
            Self::MaxCommandChainLength { inner } => inner.0.clone(),
            Self::MaxCommandForkCount { inner } => inner.0.clone(),
            Self::CommandModificationBlockLimit { inner } => inner.0.clone(),
            Self::PlayersSleepingPercentage { inner } => inner.0.clone(),
            Self::SnowAccumulationHeight { inner } => inner.0.clone(),
            Self::PlayersNetherPortalDefaultDelay { inner } => inner.0.clone(),
            Self::PlayersNetherPortalCreativeDelay { inner } => inner.0.clone(),
            Self::SpawnChunkRadius { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::AnnounceAdvancements { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::CommandBlockOutput { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DisableElytraMovementCheck { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoDaylightCycle { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoEntityDrops { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoFireTick { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoLimitedCrafting { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoMobLoot { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ProjectilesCanBreakBlocks { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoMobSpawning { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoTileDrops { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoWeatherCycle { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::KeepInventory { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::LogAdminCommands { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MobGriefing { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::NaturalRegeneration { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ReducedDebugInfo { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::SendCommandFeedback { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ShowDeathMessages { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::SpectatorsGenerateChunks { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DisableRaids { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoInsomnia { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoImmediateRespawn { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DrowningDamage { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::FallDamage { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::FireDamage { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::FreezeDamage { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoPatrolSpawning { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoTraderSpawning { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoWardenSpawning { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ForgiveDeadPlayers { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::UniversalAnger { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlockExplosionDropDecay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MobExplosionDropDecay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::TntExplosionDropDecay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::WaterSourceConversion { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::LavaSourceConversion { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::GlobalSoundEvents { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DoVinesSpread { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EnderPearlsVanishOnDeath { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::RandomTickSpeed { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::SpawnRadius { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MaxEntityCramming { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MaxCommandChainLength { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MaxCommandForkCount { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::CommandModificationBlockLimit { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::PlayersSleepingPercentage { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::SnowAccumulationHeight { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::PlayersNetherPortalDefaultDelay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::PlayersNetherPortalCreativeDelay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::SpawnChunkRadius { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for GameRule<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate GameRule from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/GameRule")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a GameRule object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "ANNOUNCE_ADVANCEMENTS" => Ok(GameRule::AnnounceAdvancements {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "COMMAND_BLOCK_OUTPUT" => Ok(GameRule::CommandBlockOutput {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DISABLE_ELYTRA_MOVEMENT_CHECK" => Ok(GameRule::DisableElytraMovementCheck {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_DAYLIGHT_CYCLE" => Ok(GameRule::DoDaylightCycle {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_ENTITY_DROPS" => Ok(GameRule::DoEntityDrops {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_FIRE_TICK" => Ok(GameRule::DoFireTick {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_LIMITED_CRAFTING" => Ok(GameRule::DoLimitedCrafting {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_MOB_LOOT" => Ok(GameRule::DoMobLoot {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "PROJECTILES_CAN_BREAK_BLOCKS" => Ok(GameRule::ProjectilesCanBreakBlocks {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_MOB_SPAWNING" => Ok(GameRule::DoMobSpawning {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_TILE_DROPS" => Ok(GameRule::DoTileDrops {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_WEATHER_CYCLE" => Ok(GameRule::DoWeatherCycle {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "KEEP_INVENTORY" => Ok(GameRule::KeepInventory {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "LOG_ADMIN_COMMANDS" => Ok(GameRule::LogAdminCommands {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "MOB_GRIEFING" => Ok(GameRule::MobGriefing {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "NATURAL_REGENERATION" => Ok(GameRule::NaturalRegeneration {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "REDUCED_DEBUG_INFO" => Ok(GameRule::ReducedDebugInfo {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "SEND_COMMAND_FEEDBACK" => Ok(GameRule::SendCommandFeedback {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "SHOW_DEATH_MESSAGES" => Ok(GameRule::ShowDeathMessages {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "SPECTATORS_GENERATE_CHUNKS" => Ok(GameRule::SpectatorsGenerateChunks {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DISABLE_RAIDS" => Ok(GameRule::DisableRaids {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_INSOMNIA" => Ok(GameRule::DoInsomnia {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_IMMEDIATE_RESPAWN" => Ok(GameRule::DoImmediateRespawn {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DROWNING_DAMAGE" => Ok(GameRule::DrowningDamage {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "FALL_DAMAGE" => Ok(GameRule::FallDamage {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "FIRE_DAMAGE" => Ok(GameRule::FireDamage {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "FREEZE_DAMAGE" => Ok(GameRule::FreezeDamage {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_PATROL_SPAWNING" => Ok(GameRule::DoPatrolSpawning {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_TRADER_SPAWNING" => Ok(GameRule::DoTraderSpawning {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_WARDEN_SPAWNING" => Ok(GameRule::DoWardenSpawning {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "FORGIVE_DEAD_PLAYERS" => Ok(GameRule::ForgiveDeadPlayers {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "UNIVERSAL_ANGER" => Ok(GameRule::UniversalAnger {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "BLOCK_EXPLOSION_DROP_DECAY" => Ok(GameRule::BlockExplosionDropDecay {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "MOB_EXPLOSION_DROP_DECAY" => Ok(GameRule::MobExplosionDropDecay {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "TNT_EXPLOSION_DROP_DECAY" => Ok(GameRule::TntExplosionDropDecay {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "WATER_SOURCE_CONVERSION" => Ok(GameRule::WaterSourceConversion {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "LAVA_SOURCE_CONVERSION" => Ok(GameRule::LavaSourceConversion {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "GLOBAL_SOUND_EVENTS" => Ok(GameRule::GlobalSoundEvents {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "DO_VINES_SPREAD" => Ok(GameRule::DoVinesSpread {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "ENDER_PEARLS_VANISH_ON_DEATH" => Ok(GameRule::EnderPearlsVanishOnDeath {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "RANDOM_TICK_SPEED" => Ok(GameRule::RandomTickSpeed {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "SPAWN_RADIUS" => Ok(GameRule::SpawnRadius {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "MAX_ENTITY_CRAMMING" => Ok(GameRule::MaxEntityCramming {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "MAX_COMMAND_CHAIN_LENGTH" => Ok(GameRule::MaxCommandChainLength {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "MAX_COMMAND_FORK_COUNT" => Ok(GameRule::MaxCommandForkCount {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "COMMAND_MODIFICATION_BLOCK_LIMIT" => Ok(GameRule::CommandModificationBlockLimit {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "PLAYERS_SLEEPING_PERCENTAGE" => Ok(GameRule::PlayersSleepingPercentage {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "SNOW_ACCUMULATION_HEIGHT" => Ok(GameRule::SnowAccumulationHeight {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                "PLAYERS_NETHER_PORTAL_DEFAULT_DELAY" => {
                    Ok(GameRule::PlayersNetherPortalDefaultDelay {
                        inner: GameRuleStruct::from_raw(env, obj)?,
                    })
                }
                "PLAYERS_NETHER_PORTAL_CREATIVE_DELAY" => {
                    Ok(GameRule::PlayersNetherPortalCreativeDelay {
                        inner: GameRuleStruct::from_raw(env, obj)?,
                    })
                }
                "SPAWN_CHUNK_RADIUS" => Ok(GameRule::SpawnChunkRadius {
                    inner: GameRuleStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for GameRuleStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for GameRuleStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate GameRuleStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/GameRule")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a GameRuleStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> GameRuleStruct<'mc> {
    /// Get the name of this GameRule.
    pub fn name(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getName", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Get the type of this rule.
    pub fn get_type(&self) -> Result<jni::objects::JClass<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/Class;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(unsafe { jni::objects::JClass::from_raw(res.as_jni().l) })
    }

    pub fn equals(
        &self,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/Object;)Z");
        let val_1 = jni::objects::JValueGen::Object(obj);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "equals",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    #[doc(hidden)]
    pub fn internal_to_string(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "toString", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct Raid<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Raid<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Raid<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Raid from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Raid")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Raid object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Raid<'mc> {
    /// Get whether this raid started.
    pub fn is_started(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isStarted", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the amount of ticks this raid has existed.
    pub fn active_ticks(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getActiveTicks", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    /// Gets the Bad Omen level of this raid.
    pub fn bad_omen_level(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBadOmenLevel", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the Bad Omen level.
    ///
    /// If the level is higher than 1, there will be an additional wave that as
    /// strong as the final wave.
    pub fn set_bad_omen_level(
        &self,
        bad_omen_level: i32,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(bad_omen_level);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBadOmenLevel",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the center location where the raid occurs.
    pub fn location(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLocation", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the current status of the raid.
    ///
    /// Do not use this method to check if the raid has been started, call
    /// {@link #isStarted()} instead.
    pub fn status(&self) -> Result<crate::RaidRaidStatus<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Raid/RaidStatus;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getStatus", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::RaidRaidStatus::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the number of raider groups which have spawned.
    pub fn spawned_groups(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getSpawnedGroups",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the number of raider groups which would spawn.
    ///
    /// This also includes the group which spawns in the additional wave (if
    /// present).
    pub fn total_groups(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getTotalGroups", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the number of waves in this raid (exclude the additional wave).
    pub fn total_waves(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getTotalWaves", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the sum of all raider's health.
    pub fn total_health(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getTotalHealth", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Get the UUID of all heroes in this raid.
    pub fn heroes(
        &self,
    ) -> Result<blackboxmc_java::util::JavaSet<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Set;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getHeroes", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaSet::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets all remaining {@link Raider} in the present wave.
    pub fn raiders(&self) -> Result<Vec<crate::entity::Raider<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/List;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getRaiders", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Raider::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum RaidRaidStatus<'mc> {}
impl<'mc> std::fmt::Display for RaidRaidStatus<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> RaidRaidStatus<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<RaidRaidStatus<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Raid/RaidStatus");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Raid/RaidStatus;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct RaidRaidStatusStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for RaidRaidStatus<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for RaidRaidStatus<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate RaidRaidStatus from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Raid/RaidStatus")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a RaidRaidStatus object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for RaidRaidStatusStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for RaidRaidStatusStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate RaidRaidStatusStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Raid/RaidStatus")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a RaidRaidStatusStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> RaidRaidStatusStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::RaidRaidStatus<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Raid/RaidStatus;");
        let cls = jni.find_class("org/bukkit/Raid/RaidStatus");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::RaidRaidStatus::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum Rotation<'mc> {}
impl<'mc> std::fmt::Display for Rotation<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> Rotation<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Rotation<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Rotation");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Rotation;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct RotationStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Rotation<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for Rotation<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Rotation from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Rotation")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Rotation object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for RotationStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for RotationStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate RotationStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Rotation")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a RotationStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> RotationStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::Rotation<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Rotation;");
        let cls = jni.find_class("org/bukkit/Rotation");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Rotation::from_raw(&jni, obj)
    }
    /// Rotate clockwise by 90 degrees.
    pub fn rotate_clockwise(&self) -> Result<crate::Rotation<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Rotation;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "rotateClockwise", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Rotation::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Rotate counter-clockwise by 90 degrees.
    pub fn rotate_counter_clockwise(
        &self,
    ) -> Result<crate::Rotation<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Rotation;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "rotateCounterClockwise",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Rotation::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct UndefinedNullability<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for UndefinedNullability<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for UndefinedNullability<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate UndefinedNullability from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/UndefinedNullability")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a UndefinedNullability object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> UndefinedNullability<'mc> {
    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum WeatherType<'mc> {}
impl<'mc> std::fmt::Display for WeatherType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> WeatherType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<WeatherType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/WeatherType");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/WeatherType;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct WeatherTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for WeatherType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for WeatherType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate WeatherType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/WeatherType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WeatherType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for WeatherTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WeatherTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate WeatherTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/WeatherType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WeatherTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> WeatherTypeStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::WeatherType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/WeatherType;");
        let cls = jni.find_class("org/bukkit/WeatherType");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::WeatherType::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum Statistic<'mc> {}
impl<'mc> std::fmt::Display for Statistic<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> Statistic<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Statistic<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Statistic");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Statistic;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct StatisticStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Statistic<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for Statistic<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Statistic from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Statistic")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Statistic object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for StatisticStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for StatisticStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate StatisticStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Statistic")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a StatisticStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> StatisticStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::Statistic<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Statistic;");
        let cls = jni.find_class("org/bukkit/Statistic");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Statistic::from_raw(&jni, obj)
    }
    /// Gets the type of this statistic.
    pub fn get_type(&self) -> Result<crate::StatisticType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Statistic/Type;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getType", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::StatisticType::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Checks if this is a substatistic.
    ///
    /// A substatistic exists en masse for each block, item, or entitytype, depending on
    /// {@link #getType()}.
    ///
    /// This is a redundant method and equivalent to checking
    /// <code>getType() != Type.UNTYPED</code>
    pub fn is_substatistic(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isSubstatistic", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Checks if this is a substatistic dealing with blocks.
    ///
    /// This is a redundant method and equivalent to checking
    /// <code>getType() == Type.BLOCK</code>
    pub fn is_block(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "isBlock", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum StatisticType<'mc> {}
impl<'mc> std::fmt::Display for StatisticType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> StatisticType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<StatisticType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Statistic/Type");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Statistic/Type;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct StatisticTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for StatisticType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for StatisticType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate StatisticType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Statistic/Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a StatisticType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for StatisticTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for StatisticTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate StatisticTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Statistic/Type")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a StatisticTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> StatisticTypeStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::StatisticType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Statistic/Type;");
        let cls = jni.find_class("org/bukkit/Statistic/Type");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::StatisticType::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct WorldBorder<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for WorldBorder<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WorldBorder<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate WorldBorder from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/WorldBorder")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WorldBorder object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> WorldBorder<'mc> {
    /// Get the {@link World} in which the border resides.
    pub fn world(&self) -> Result<Option<crate::World<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/World;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getWorld", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::World::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Resets the border to default values.
    pub fn reset(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "reset", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the current side length of the border.
    pub fn size(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getSize", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Gets the current border center.
    pub fn center(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getCenter", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the new border center.
    pub fn set_center(
        &self,
        x: f64,
        z: std::option::Option<f64>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "D";
        let val_1 = jni::objects::JValueGen::Double(x);
        args.push(val_1);
        if let Some(a) = z {
            sig += "D";
            let val_2 = jni::objects::JValueGen::Double(a);
            args.push(val_2);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "setCenter", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the current border damage buffer.
    pub fn damage_buffer(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDamageBuffer", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Sets the amount of blocks a player may safely be outside the border before taking damage.
    pub fn set_damage_buffer(&self, blocks: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(blocks);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDamageBuffer",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the current border damage amount.
    pub fn damage_amount(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDamageAmount", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Sets the amount of damage a player takes when outside the border plus the border buffer.
    pub fn set_damage_amount(&self, damage: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(damage);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDamageAmount",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the current border warning time in seconds.
    pub fn warning_time(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getWarningTime", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the warning time that causes the screen to be tinted red when a contracting border will reach the player within the specified time.
    pub fn set_warning_time(&self, seconds: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(seconds);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWarningTime",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the current border warning distance.
    pub fn warning_distance(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getWarningDistance",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the warning distance that causes the screen to be tinted red when the player is within the specified number of blocks from the border.
    pub fn set_warning_distance(&self, distance: i32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(I)V");
        let val_1 = jni::objects::JValueGen::Int(distance);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWarningDistance",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Check if the specified location is inside this border.
    pub fn is_inside(
        &self,
        location: impl Into<crate::Location<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)Z");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isInside",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the maximum possible size of a WorldBorder.
    pub fn max_size(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMaxSize", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Gets the absolute value of the maximum x/z center coordinate of a
    /// WorldBorder.
    pub fn max_center_coordinate(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getMaxCenterCoordinate",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum EntityEffect<'mc> {}
impl<'mc> std::fmt::Display for EntityEffect<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> EntityEffect<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<EntityEffect<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/EntityEffect");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/EntityEffect;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct EntityEffectStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for EntityEffect<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for EntityEffect<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate EntityEffect from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/EntityEffect")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EntityEffect object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for EntityEffectStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for EntityEffectStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate EntityEffectStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/EntityEffect")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a EntityEffectStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> EntityEffectStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::EntityEffect<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/EntityEffect;");
        let cls = jni.find_class("org/bukkit/EntityEffect");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::EntityEffect::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Gets the data value of this EntityEffect, may not be unique.
    pub fn data(&self) -> Result<i8, Box<dyn std::error::Error>> {
        let sig = String::from("()B");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getData", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.b()?)
    }
    /// Gets entity superclass which this affect is applicable to.
    pub fn applicable(&self) -> Result<jni::objects::JClass<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/Class;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getApplicable", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(unsafe { jni::objects::JClass::from_raw(res.as_jni().l) })
    }
    /// Checks if this effect is applicable to the given entity class.
    pub fn is_applicable_to(
        &self,
        clazz: jni::objects::JClass<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/Class;";
        let val_1 = jni::objects::JValueGen::Object(clazz.into());
        args.push(val_1);
        sig += ")Z";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isApplicableTo", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum WorldType<'mc> {}
impl<'mc> std::fmt::Display for WorldType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> WorldType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<WorldType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/WorldType");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/WorldType;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct WorldTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for WorldType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for WorldType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate WorldType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/WorldType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WorldType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for WorldTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WorldTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate WorldTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/WorldType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WorldTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> WorldTypeStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::WorldType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/WorldType;");
        let cls = jni.find_class("org/bukkit/WorldType");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::WorldType::from_raw(&jni, obj)
    }
    /// Gets the name of this WorldType
    pub fn name(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getName", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets a WorldType by its name
    pub fn get_by_name(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        name: impl Into<String>,
    ) -> Result<Option<crate::WorldType<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/WorldType;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(name.into())?,
        ));
        let cls = jni.find_class("org/bukkit/WorldType");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByName",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::WorldType::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct Nameable<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Nameable<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Nameable<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Nameable from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Nameable")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Nameable object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Nameable<'mc> {
    /// Gets the custom name on a mob or block. If there is no name this method
    /// will return null.
    ///
    /// This value has no effect on players, they will always use their real
    /// name.
    pub fn custom_name(&self) -> Result<Option<String>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Ljava/lang/String;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getCustomName", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(
            self.jni_ref()
                .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
                .to_string_lossy()
                .to_string(),
        ))
    }
    /// Sets a custom name on a mob or block. This name will be used in death
    /// messages and can be sent to the client as a nameplate over the mob.
    ///
    /// Setting the name to null or an empty string will clear it.
    ///
    /// This value has no effect on players, they will always use their real
    /// name.
    pub fn set_custom_name(
        &self,
        name: impl Into<String>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(name.into())?,
        ));
        args.push(val_1);
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "setCustomName", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct Color<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Color<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Color<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Color from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Color")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Color object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Color<'mc> {
    /// Creates a new Color object from an alpha, red, green, and blue
    pub fn from_argb(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        alpha: i32,
        red: std::option::Option<i32>,
        green: std::option::Option<i32>,
        blue: std::option::Option<i32>,
    ) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(alpha);
        args.push(val_1);
        if let Some(a) = red {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = green {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        if let Some(a) = blue {
            sig += "I";
            let val_4 = jni::objects::JValueGen::Int(a);
            args.push(val_4);
        }
        sig += ")Lorg/bukkit/Color;";
        let cls = jni.find_class("org/bukkit/Color");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "fromARGB", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Color::from_raw(&jni, obj)
    }
    /// Creates a new Color object from a red, green, and blue
    pub fn from_rgb(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        red: i32,
        green: std::option::Option<i32>,
        blue: std::option::Option<i32>,
    ) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(red);
        args.push(val_1);
        if let Some(a) = green {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = blue {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/Color;";
        let cls = jni.find_class("org/bukkit/Color");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "fromRGB", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Color::from_raw(&jni, obj)
    }
    /// Creates a new Color object from a blue, green, and red
    pub fn from_bgr(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        blue: i32,
        green: std::option::Option<i32>,
        red: std::option::Option<i32>,
    ) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(blue);
        args.push(val_1);
        if let Some(a) = green {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = red {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/Color;";
        let cls = jni.find_class("org/bukkit/Color");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "fromBGR", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Color::from_raw(&jni, obj)
    }
    /// Gets the alpha component
    pub fn alpha(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getAlpha", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Creates a new Color object with specified component
    pub fn set_alpha(&self, alpha: i32) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Lorg/bukkit/Color;");
        let val_1 = jni::objects::JValueGen::Int(alpha);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setAlpha",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the red component
    pub fn red(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getRed", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Creates a new Color object with specified component
    pub fn set_red(&self, red: i32) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Lorg/bukkit/Color;");
        let val_1 = jni::objects::JValueGen::Int(red);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setRed",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the green component
    pub fn green(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getGreen", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Creates a new Color object with specified component
    pub fn set_green(&self, green: i32) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Lorg/bukkit/Color;");
        let val_1 = jni::objects::JValueGen::Int(green);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setGreen",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the blue component
    pub fn blue(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBlue", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Creates a new Color object with specified component
    pub fn set_blue(&self, blue: i32) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Lorg/bukkit/Color;");
        let val_1 = jni::objects::JValueGen::Int(blue);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setBlue",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the color as an RGB integer.
    pub fn as_rgb(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "asRGB", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the color as an ARGB integer.
    pub fn as_argb(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "asARGB", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the color as an BGR integer.
    pub fn as_bgr(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "asBGR", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Creates a new color with its RGB components changed as if it was dyed
    /// with the colors passed in, replicating vanilla workbench dyeing
    pub fn mix_dyes(
        &self,
        colors: impl Into<crate::DyeColor<'mc>>,
    ) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/DyeColor;)Lorg/bukkit/Color;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(colors.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "mixDyes",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Creates a new color with its RGB components changed as if it was dyed
    /// with the colors passed in, replicating vanilla workbench dyeing.
    /// <b>Note that this method does not currently take into account alpha
    /// components.</b>
    pub fn mix_colors(
        &self,
        colors: impl Into<crate::Color<'mc>>,
    ) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Color;)Lorg/bukkit/Color;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(colors.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "mixColors",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn equals(
        &self,
        o: jni::objects::JObject<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/Object;)Z");
        let val_1 = jni::objects::JValueGen::Object(o);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "equals",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn hash_code(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hashCode", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn serialize(
        &self,
    ) -> Result<blackboxmc_java::util::JavaMap<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Map;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "serialize", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaMap::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn deserialize(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        map: impl Into<blackboxmc_java::util::JavaMap<'mc>>,
    ) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/Map;)Lorg/bukkit/Color;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(map.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Color");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "deserialize",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Color::from_raw(&jni, obj)
    }

    #[doc(hidden)]
    pub fn internal_to_string(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "toString", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}

impl<'mc> std::string::ToString for Color<'mc> {
    fn to_string(&self) -> String {
        match &self.internal_to_string() {
            Ok(a) => a.clone(),
            Err(err) => format!("Error calling Color.toString: {}", err),
        }
    }
}

impl<'mc> Into<crate::configuration::serialization::ConfigurationSerializable<'mc>> for Color<'mc> {
    fn into(self) -> crate::configuration::serialization::ConfigurationSerializable<'mc> {
        crate::configuration::serialization::ConfigurationSerializable::from_raw(&self.jni_ref(), self.1).expect("Error converting Color into crate::configuration::serialization::ConfigurationSerializable")
    }
}
#[repr(C)]
pub struct RegionAccessor<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for RegionAccessor<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for RegionAccessor<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate RegionAccessor from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/RegionAccessor")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a RegionAccessor object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> RegionAccessor<'mc> {
    /// Gets the {@link Biome} at the given coordinates.
    pub fn get_biome(
        &self,
        x: i32,
        y: std::option::Option<i32>,
        z: std::option::Option<i32>,
    ) -> Result<crate::block::Biome<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = y {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/block/Biome;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBiome", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Biome::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the {@link Biome} for the given block coordinates
    pub fn set_biome(
        &self,
        x: i32,
        y: i32,
        z: std::option::Option<i32>,
        biome: std::option::Option<impl Into<crate::block::Biome<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(y);
        args.push(val_2);
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        if let Some(a) = biome {
            sig += "Lorg/bukkit/block/Biome;";
            let val_4 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_4);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "setBiome", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the {@link BlockState} at the given coordinates.
    pub fn get_block_state(
        &self,
        x: i32,
        y: std::option::Option<i32>,
        z: std::option::Option<i32>,
    ) -> Result<crate::block::BlockState<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = y {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/block/BlockState;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBlockState", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::BlockState::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the {@link BlockData} at the given coordinates.
    pub fn get_block_data(
        &self,
        x: i32,
        y: std::option::Option<i32>,
        z: std::option::Option<i32>,
    ) -> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = y {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/block/data/BlockData;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBlockData", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::data::BlockData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the type of the block at the given coordinates.
    pub fn get_type(
        &self,
        x: i32,
        y: std::option::Option<i32>,
        z: std::option::Option<i32>,
    ) -> Result<crate::Material<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        if let Some(a) = y {
            sig += "I";
            let val_2 = jni::objects::JValueGen::Int(a);
            args.push(val_2);
        }
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/Material;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getType", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::Material::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the {@link BlockData} at the given coordinates.
    pub fn set_block_data(
        &self,
        x: i32,
        y: i32,
        z: std::option::Option<i32>,
        block_data: std::option::Option<impl Into<crate::block::data::BlockData<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(y);
        args.push(val_2);
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        if let Some(a) = block_data {
            sig += "Lorg/bukkit/block/data/BlockData;";
            let val_4 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_4);
        }
        sig += ")V";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "setBlockData", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Sets the {@link Material} at the given coordinates.
    pub fn set_type(
        &self,
        x: i32,
        y: i32,
        z: std::option::Option<i32>,
        material: std::option::Option<impl Into<crate::Material<'mc>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(y);
        args.push(val_2);
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        if let Some(a) = material {
            sig += "Lorg/bukkit/Material;";
            let val_4 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_4);
        }
        sig += ")V";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "setType", sig.as_str(), args);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Creates a tree at the given {@link Location}
    ///
    /// The provided predicate gets called for every block which gets changed
    /// as a result of the tree generation. When the predicate gets called no
    /// modifications to the world are done yet. Which means, that calling
    /// {@link #getBlockState(Location)} in the predicate will return the state
    /// of the block before the generation.
    ///
    /// If the predicate returns {@code true} the block gets set in the world.
    /// If it returns {@code false} the block won't get set in the world.
    pub fn generate_tree(
        &self,
        location: impl Into<crate::Location<'mc>>,
        random: impl Into<blackboxmc_java::util::JavaRandom<'mc>>,
        val_type: impl Into<crate::TreeType<'mc>>,
        state_predicate: std::option::Option<
            impl Into<blackboxmc_java::util::function::JavaPredicate<'mc>>,
        >,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Ljava/util/Random;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(random.into().jni_object().clone())
        });
        args.push(val_2);
        sig += "Lorg/bukkit/TreeType;";
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(val_type.into().jni_object().clone())
        });
        args.push(val_3);
        if let Some(a) = state_predicate {
            sig += "Ljava/util/function/Predicate;";
            let val_4 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_4);
        }
        sig += ")Z";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "generateTree", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Creates a new entity at the given {@link Location}.
    pub fn spawn_entity(
        &self,
        loc: impl Into<crate::Location<'mc>>,
        val_type: impl Into<crate::entity::EntityType<'mc>>,
        randomize_data: std::option::Option<bool>,
    ) -> Result<crate::entity::Entity<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(loc.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Lorg/bukkit/entity/EntityType;";
        let val_2 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(val_type.into().jni_object().clone())
        });
        args.push(val_2);
        if let Some(a) = randomize_data {
            sig += "Z";
            let val_3 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/entity/Entity;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "spawnEntity", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::entity::Entity::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Get a list of all entities in this RegionAccessor
    pub fn entities(&self) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Ljava/util/List;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getEntities", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Get a list of all living entities in this RegionAccessor
    pub fn living_entities(
        &self,
    ) -> Result<Vec<crate::entity::LivingEntity<'mc>>, Box<dyn std::error::Error>> {
        let args = Vec::new();
        let mut sig = String::from("(");
        sig += ")Ljava/util/List;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getLivingEntities", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let list = blackboxmc_java::util::JavaList::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = list.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::LivingEntity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Get a collection of all entities in this RegionAccessor matching the given
    /// class/interface
    pub fn get_entities_by_class(
        &self,
        cls: jni::objects::JClass<'mc>,
    ) -> Result<Vec<jni::objects::JObject<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/Class;";
        let val_1 = jni::objects::JValueGen::Object(cls.into());
        args.push(val_1);
        sig += ")Ljava/util/Collection;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getEntitiesByClass",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(obj);
        }
        Ok(new_vec)
    }
    /// Get a collection of all entities in this RegionAccessor matching any of the
    /// given classes/interfaces
    pub fn get_entities_by_classes(
        &self,
        classes: jni::objects::JClass<'mc>,
    ) -> Result<Vec<crate::entity::Entity<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/Class;";
        let val_1 = jni::objects::JValueGen::Object(classes.into());
        args.push(val_1);
        sig += ")Ljava/util/Collection;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getEntitiesByClasses",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&self.jni_ref(), res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::entity::Entity::from_raw(&self.jni_ref(), obj)?);
        }
        Ok(new_vec)
    }
    /// Creates an entity of a specific class at the given {@link Location} but
    /// does not spawn it in the world.
    ///
    /// <b>Note:</b> The created entity keeps a reference to the world it was
    /// created in, care should be taken that the entity does not outlive the
    /// world instance as this will lead to memory leaks.
    pub fn create_entity(
        &self,
        location: impl Into<crate::Location<'mc>>,
        clazz: jni::objects::JClass<'mc>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;Ljava/lang/Class;)LT;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        let val_2 = jni::objects::JValueGen::Object(clazz.into());
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "createEntity",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }
    /// Creates a new entity at the given {@link Location} with the supplied
    /// function run before the entity is added to the world.
    ///
    /// Note that when the function is run, the entity will not be actually in
    /// the world. Any operation involving such as teleporting the entity is undefined
    /// until after this function returns.
    /// The passed function however is run after the potential entity's spawn
    /// randomization and hence already allows access to the values of the mob,
    /// whether or not those were randomized, such as attributes or the entity
    /// equipment.
    pub fn spawn(
        &self,
        location: impl Into<crate::Location<'mc>>,
        clazz: jni::objects::JClass<'mc>,
        randomize_data: std::option::Option<bool>,
        function: std::option::Option<
            impl Into<blackboxmc_java::util::function::JavaConsumer<'mc>>,
        >,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Ljava/lang/Class;";
        let val_2 = jni::objects::JValueGen::Object(clazz.into());
        args.push(val_2);
        if let Some(a) = randomize_data {
            sig += "Z";
            let val_3 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_3);
        }
        if let Some(a) = function {
            sig += "Ljava/util/function/Consumer;";
            let val_4 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_4);
        }
        sig += ")LT;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "spawn", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }
    /// Gets the highest coordinate corresponding to the {@link HeightMap} at the
    /// given {@link Location}.
    pub fn get_highest_block_yat(
        &self,
        location: impl Into<crate::Location<'mc>>,
        height_map: std::option::Option<impl Into<crate::HeightMap<'mc>>>,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/Location;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(location.into().jni_object().clone())
        });
        args.push(val_1);
        if let Some(a) = height_map {
            sig += "Lorg/bukkit/HeightMap;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")I";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getHighestBlockYAt",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Spawns a previously created entity in the world.
    ///
    /// The provided entity must not have already been spawned in a world.
    pub fn add_entity(
        &self,
        entity: jni::objects::JObject<'mc>,
    ) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(LT;)LT;");
        let val_1 = jni::objects::JValueGen::Object(entity);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "addEntity",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct WorldCreator<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for WorldCreator<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for WorldCreator<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate WorldCreator from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/WorldCreator")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a WorldCreator object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> WorldCreator<'mc> {
    /// Creates an empty WorldCreationOptions for the given world name
    pub fn new(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        name: impl Into<String>,
    ) -> Result<crate::WorldCreator<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(name.into())?,
        ));
        let cls = jni.find_class("org/bukkit/WorldCreator");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.new_object(
            cls,
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error_no_gen(res)?;
        crate::WorldCreator::from_raw(&jni, res)
    }
    /// Copies the options from the specified {@link WorldCreator}
    pub fn copy(
        &self,
        creator: impl Into<crate::WorldCreator<'mc>>,
    ) -> Result<crate::WorldCreator<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/WorldCreator;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(creator.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Lorg/bukkit/WorldCreator;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "copy", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::WorldCreator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Creates a new {@link WorldCreator} for the given world name
    pub fn name(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        name: std::option::Option<impl Into<String>>,
    ) -> Result<crate::WorldCreator<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = name {
            sig += "Ljava/lang/String;";
            let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                jni.new_string(a.into())?,
            ));
            args.push(val_1);
        }
        sig += ")Lorg/bukkit/WorldCreator;";
        let cls = jni.find_class("org/bukkit/WorldCreator");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "name", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::WorldCreator::from_raw(&jni, obj)
    }
    /// Sets the seed that will be used to create this world
    pub fn seed(
        &self,
        seed: std::option::Option<i64>,
    ) -> Result<crate::WorldCreator<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = seed {
            sig += "J";
            let val_1 = jni::objects::JValueGen::Long(a);
            args.push(val_1);
        }
        sig += ")Lorg/bukkit/WorldCreator;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "seed", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::WorldCreator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the environment that will be used to create or load the world
    pub fn environment(
        &self,
        env: std::option::Option<impl Into<crate::WorldEnvironment<'mc>>>,
    ) -> Result<crate::WorldCreator<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = env {
            sig += "Lorg/bukkit/World/Environment;";
            let val_1 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_1);
        }
        sig += ")Lorg/bukkit/WorldCreator;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "environment", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::WorldCreator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the type of the world that will be created or loaded
    pub fn get_type(
        &self,
        val_type: std::option::Option<impl Into<crate::WorldType<'mc>>>,
    ) -> Result<crate::WorldCreator<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = val_type {
            sig += "Lorg/bukkit/WorldType;";
            let val_1 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_1);
        }
        sig += ")Lorg/bukkit/WorldCreator;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "type", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::WorldCreator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the generator that will be used to create or load the world.
    ///
    /// This may be null, in which case the "natural" generator for this
    /// environment will be used.
    ///
    /// If the generator cannot be found for the given name, the natural
    /// environment generator will be used instead and a warning will be
    /// printed to the specified output
    pub fn generator(
        &self,
        generator: std::option::Option<impl Into<String>>,
        output: std::option::Option<impl Into<crate::command::CommandSender<'mc>>>,
    ) -> Result<crate::WorldCreator<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = generator {
            sig += "Ljava/lang/String;";
            let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                self.jni_ref().new_string(a.into())?,
            ));
            args.push(val_1);
        }
        if let Some(a) = output {
            sig += "Lorg/bukkit/command/CommandSender;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/WorldCreator;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "generator", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::WorldCreator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the biome provider that will be used to create or load the world.
    ///
    /// This may be null, in which case the biome provider from the
    /// {@link ChunkGenerator} will be used. If no {@link ChunkGenerator} is
    /// specific the "natural" biome provider for this environment will be used.
    ///
    /// If the biome provider cannot be found for the given name and no
    /// {@link ChunkGenerator} is specific, the natural environment biome
    /// provider will be used instead and a warning will be printed to the
    /// specified output
    pub fn biome_provider(
        &self,
        biome_provider: std::option::Option<impl Into<String>>,
        output: std::option::Option<impl Into<crate::command::CommandSender<'mc>>>,
    ) -> Result<crate::WorldCreator<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = biome_provider {
            sig += "Ljava/lang/String;";
            let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                self.jni_ref().new_string(a.into())?,
            ));
            args.push(val_1);
        }
        if let Some(a) = output {
            sig += "Lorg/bukkit/command/CommandSender;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/WorldCreator;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "biomeProvider", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::WorldCreator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the generator settings of the world that will be created or loaded.
    ///
    /// Currently only {@link WorldType#FLAT} uses these settings, and expects
    /// them to be in JSON format with a valid biome (1.18.2 and
    /// above) defined. An example valid configuration is as follows:
    /// <code>{"layers": [{"block": "stone", "height": 1}, {"block": "grass_block", "height": 1}], "biome":"plains"}</code>
    pub fn generator_settings(
        &self,
        generator_settings: std::option::Option<impl Into<String>>,
    ) -> Result<crate::WorldCreator<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = generator_settings {
            sig += "Ljava/lang/String;";
            let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
                self.jni_ref().new_string(a.into())?,
            ));
            args.push(val_1);
        }
        sig += ")Lorg/bukkit/WorldCreator;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "generatorSettings", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::WorldCreator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets whether or not worlds created or loaded with this creator will
    /// have structures.
    pub fn generate_structures(
        &self,
        generate: std::option::Option<bool>,
    ) -> Result<crate::WorldCreator<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = generate {
            sig += "Z";
            let val_1 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_1);
        }
        sig += ")Lorg/bukkit/WorldCreator;";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "generateStructures",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::WorldCreator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets whether the world will be hardcore or not.
    /// In a hardcore world the difficulty will be locked to hard.
    pub fn hardcore(
        &self,
        hardcore: std::option::Option<bool>,
    ) -> Result<crate::WorldCreator<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = hardcore {
            sig += "Z";
            let val_1 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_1);
        }
        sig += ")Lorg/bukkit/WorldCreator;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hardcore", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::WorldCreator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets whether the spawn chunks will be kept loaded.
    ///
    /// Setting this to false will also stop the spawn chunks from being generated
    /// when creating a new world.
    ///
    /// Has little performance benefit unless paired with a {@link ChunkGenerator}
    /// that overrides {@link ChunkGenerator#getFixedSpawnLocation(World, Random)}.
    pub fn keep_spawn_in_memory(
        &self,
        keep_spawn_in_memory: std::option::Option<bool>,
    ) -> Result<crate::WorldCreator<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        if let Some(a) = keep_spawn_in_memory {
            sig += "Z";
            let val_1 = jni::objects::JValueGen::Bool(a.into());
            args.push(val_1);
        }
        sig += ")Lorg/bukkit/WorldCreator;";
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "keepSpawnInMemory", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::WorldCreator::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Creates a world with the specified options.
    ///
    /// If the world already exists, it will be loaded from disk and some
    /// options may be ignored.
    pub fn create_world(&self) -> Result<Option<crate::World<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/World;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "createWorld", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::World::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Attempts to get the {@link ChunkGenerator} with the given name.
    ///
    /// If the generator is not found, null will be returned and a message will
    /// be printed to the specified {@link CommandSender} explaining why.
    ///
    /// The name must be in the "plugin:id" notation, or optionally just
    /// "plugin", where "plugin" is the safe-name of a plugin and "id" is an
    /// optional unique identifier for the generator you wish to request from
    /// the plugin.
    pub fn get_generator_for_name(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        world: impl Into<String>,
        name: impl Into<String>,
        output: impl Into<crate::command::CommandSender<'mc>>,
    ) -> Result<Option<crate::generator::ChunkGenerator<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;Ljava/lang/String;Lorg/bukkit/command/CommandSender;)Lorg/bukkit/generator/ChunkGenerator;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(world.into())?,
        ));
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(name.into())?,
        ));
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(output.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/WorldCreator");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getGeneratorForName",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::generator::ChunkGenerator::from_raw(&jni, obj)?))
    }
    /// Attempts to get the {@link BiomeProvider} with the given name.
    ///
    /// If the biome provider is not found, null will be returned and a message
    /// will be printed to the specified {@link CommandSender} explaining why.
    ///
    /// The name must be in the "plugin:id" notation, or optionally just
    /// "plugin", where "plugin" is the safe-name of a plugin and "id" is an
    /// optional unique identifier for the biome provider you wish to request
    /// from the plugin.
    pub fn get_biome_provider_for_name(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        world: impl Into<String>,
        name: impl Into<String>,
        output: impl Into<crate::command::CommandSender<'mc>>,
    ) -> Result<Option<crate::generator::BiomeProvider<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;Ljava/lang/String;Lorg/bukkit/command/CommandSender;)Lorg/bukkit/generator/BiomeProvider;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(world.into())?,
        ));
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(name.into())?,
        ));
        let val_3 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(output.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/WorldCreator");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getBiomeProviderForName",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::generator::BiomeProvider::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct ChunkSnapshot<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for ChunkSnapshot<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for ChunkSnapshot<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate ChunkSnapshot from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/ChunkSnapshot")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a ChunkSnapshot object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> ChunkSnapshot<'mc> {
    /// Gets the X-coordinate of this chunk
    pub fn x(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getX", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the Z-coordinate of this chunk
    pub fn z(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getZ", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets name of the world containing this chunk
    pub fn world_name(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getWorldName", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Get block type for block at corresponding coordinate in the chunk
    pub fn get_block_type(
        &self,
        x: i32,
        y: i32,
        z: i32,
    ) -> Result<crate::Material<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(III)Lorg/bukkit/Material;");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(y);
        let val_3 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBlockType",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Material::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Get block data for block at corresponding coordinate in the chunk
    pub fn get_block_data(
        &self,
        x: i32,
        y: i32,
        z: i32,
    ) -> Result<crate::block::data::BlockData<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(III)Lorg/bukkit/block/data/BlockData;");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(y);
        let val_3 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBlockData",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::block::data::BlockData::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    #[deprecated]
    /// Get block data for block at corresponding coordinate in the chunk
    pub fn get_data(&self, x: i32, y: i32, z: i32) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(III)I");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(y);
        let val_3 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getData",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Get sky light level for block at corresponding coordinate in the chunk
    pub fn get_block_sky_light(
        &self,
        x: i32,
        y: i32,
        z: i32,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(III)I");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(y);
        let val_3 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBlockSkyLight",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Get light level emitted by block at corresponding coordinate in the
    /// chunk
    pub fn get_block_emitted_light(
        &self,
        x: i32,
        y: i32,
        z: i32,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(III)I");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(y);
        let val_3 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getBlockEmittedLight",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
                jni::objects::JValueGen::from(val_3),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Gets the highest non-air coordinate at the given coordinates
    pub fn get_highest_block_yat(&self, x: i32, z: i32) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(II)I");
        let val_1 = jni::objects::JValueGen::Int(x);
        let val_2 = jni::objects::JValueGen::Int(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getHighestBlockYAt",
            sig.as_str(),
            vec![
                jni::objects::JValueGen::from(val_1),
                jni::objects::JValueGen::from(val_2),
            ],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Get biome at given coordinates
    pub fn get_biome(
        &self,
        x: i32,
        y: i32,
        z: std::option::Option<i32>,
    ) -> Result<crate::block::Biome<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(y);
        args.push(val_2);
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/block/Biome;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBiome", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Biome::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Get raw biome temperature at given coordinates
    pub fn get_raw_biome_temperature(
        &self,
        x: i32,
        y: i32,
        z: std::option::Option<i32>,
    ) -> Result<f64, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "I";
        let val_1 = jni::objects::JValueGen::Int(x);
        args.push(val_1);
        sig += "I";
        let val_2 = jni::objects::JValueGen::Int(y);
        args.push(val_2);
        if let Some(a) = z {
            sig += "I";
            let val_3 = jni::objects::JValueGen::Int(a);
            args.push(val_3);
        }
        sig += ")D";
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getRawBiomeTemperature",
            sig.as_str(),
            args,
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Get world full time when chunk snapshot was captured
    pub fn capture_full_time(&self) -> Result<i64, Box<dyn std::error::Error>> {
        let sig = String::from("()J");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getCaptureFullTime",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.j()?)
    }
    /// Test if section is empty
    pub fn is_section_empty(&self, sy: i32) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Z");
        let val_1 = jni::objects::JValueGen::Int(sy);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "isSectionEmpty",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Tests if this chunk contains the specified biome.
    pub fn contains(
        &self,
        biome: impl Into<crate::block::Biome<'mc>>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/block/Biome;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(biome.into().jni_object().clone())
        });
        args.push(val_1);
        sig += ")Z";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "contains", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct SoundGroup<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for SoundGroup<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for SoundGroup<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate SoundGroup from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/SoundGroup")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a SoundGroup object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> SoundGroup<'mc> {
    /// Get the volume these sounds are played at.
    /// Note that this volume does not always represent the actual volume
    /// received by the client.
    pub fn volume(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getVolume", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Gets the pitch these sounds are played at.
    /// Note that this pitch does not always represent the actual pitch received
    /// by the client.
    pub fn pitch(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getPitch", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Gets the corresponding breaking sound for this group.
    pub fn break_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBreakSound", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the corresponding step sound for this group.
    pub fn step_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getStepSound", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the corresponding place sound for this group.
    pub fn place_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getPlaceSound", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the corresponding hit sound for this group.
    pub fn hit_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getHitSound", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the corresponding fall sound for this group.
    pub fn fall_sound(&self) -> Result<crate::Sound<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Sound;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getFallSound", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Sound::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct Translatable<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Translatable<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Translatable<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Translatable from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Translatable")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Translatable object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Translatable<'mc> {
    /// Get the translation key, suitable for use in a translation component.
    pub fn translation_key(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getTranslationKey",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum GameMode<'mc> {}
impl<'mc> std::fmt::Display for GameMode<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> GameMode<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<GameMode<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/GameMode");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/GameMode;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct GameModeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for GameMode<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for GameMode<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate GameMode from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/GameMode")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a GameMode object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for GameModeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for GameModeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate GameModeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/GameMode")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a GameModeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> GameModeStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::GameMode<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/GameMode;");
        let cls = jni.find_class("org/bukkit/GameMode");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::GameMode::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Gets the mode value associated with this GameMode
    pub fn value(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getValue", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets the GameMode represented by the specified value
    pub fn get_by_value(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        value: i32,
    ) -> Result<Option<crate::GameMode<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Lorg/bukkit/GameMode;");
        let val_1 = jni::objects::JValueGen::Int(value);
        let cls = jni.find_class("org/bukkit/GameMode");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByValue",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::GameMode::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum Difficulty<'mc> {}
impl<'mc> std::fmt::Display for Difficulty<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> Difficulty<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Difficulty<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Difficulty");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Difficulty;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct DifficultyStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Difficulty<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for Difficulty<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Difficulty from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Difficulty")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Difficulty object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for DifficultyStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for DifficultyStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate DifficultyStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Difficulty")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a DifficultyStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> DifficultyStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::Difficulty<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Difficulty;");
        let cls = jni.find_class("org/bukkit/Difficulty");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Difficulty::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Gets the difficulty value associated with this Difficulty.
    pub fn value(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getValue", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    #[deprecated]
    /// Gets the Difficulty represented by the specified value
    pub fn get_by_value(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        value: i32,
    ) -> Result<Option<crate::Difficulty<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(I)Lorg/bukkit/Difficulty;");
        let val_1 = jni::objects::JValueGen::Int(value);
        let cls = jni.find_class("org/bukkit/Difficulty");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByValue",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::Difficulty::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct StructureType<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for StructureType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for StructureType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate StructureType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/StructureType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a StructureType object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> StructureType<'mc> {
    /// Get the name of this structure. This is case-sensitive when used in
    /// commands.
    pub fn name(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getName", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Get the {@link org.bukkit.map.MapCursor.Type} that this structure can use on maps. If
    /// this is null, this structure will not appear on explorer maps.
    pub fn map_icon(
        &self,
    ) -> Result<Option<crate::map::MapCursorType<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/map/MapCursor/Type;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getMapIcon", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::map::MapCursorType::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }

    pub fn equals(
        &self,
        other: jni::objects::JObject<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/Object;)Z");
        let val_1 = jni::objects::JValueGen::Object(other);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "equals",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn hash_code(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hashCode", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    #[doc(hidden)]
    pub fn internal_to_string(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "toString", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Get all registered {@link StructureType}s.
    pub fn structure_types(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<blackboxmc_java::util::JavaMap<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Map;");
        let cls = jni.find_class("org/bukkit/StructureType");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "getStructureTypes", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        blackboxmc_java::util::JavaMap::from_raw(&jni, obj)
    }

    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}

impl<'mc> std::string::ToString for StructureType<'mc> {
    fn to_string(&self) -> String {
        match &self.internal_to_string() {
            Ok(a) => a.clone(),
            Err(err) => format!("Error calling StructureType.toString: {}", err),
        }
    }
}

impl<'mc> Into<crate::Keyed<'mc>> for StructureType<'mc> {
    fn into(self) -> crate::Keyed<'mc> {
        crate::Keyed::from_raw(&self.jni_ref(), self.1)
            .expect("Error converting StructureType into crate::Keyed")
    }
}
#[repr(C)]
pub struct Location<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Location<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for Location<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Location from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Location")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Location object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> Location<'mc> {
    /// Constructs a new Location with the given coordinates and direction
    pub fn new(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        world: impl Into<crate::World<'mc>>,
        x: f64,
        y: f64,
        z: f64,
        yaw: std::option::Option<f32>,
        pitch: std::option::Option<f32>,
    ) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/World;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "D";
        let val_2 = jni::objects::JValueGen::Double(x);
        args.push(val_2);
        sig += "D";
        let val_3 = jni::objects::JValueGen::Double(y);
        args.push(val_3);
        sig += "D";
        let val_4 = jni::objects::JValueGen::Double(z);
        args.push(val_4);
        if let Some(a) = yaw {
            sig += "F";
            let val_5 = jni::objects::JValueGen::Float(a);
            args.push(val_5);
        }
        if let Some(a) = pitch {
            sig += "F";
            let val_6 = jni::objects::JValueGen::Float(a);
            args.push(val_6);
        }
        sig += ")V";
        let cls = jni.find_class("org/bukkit/Location");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.new_object(cls, sig.as_str(), args);
        let res = jni.translate_error_no_gen(res)?;
        crate::Location::from_raw(&jni, res)
    }
    /// Sets the world that this location resides in
    pub fn set_world(
        &self,
        world: impl Into<crate::World<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/World;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(world.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setWorld",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Checks if world in this location is present and loaded.
    pub fn is_world_loaded(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("()Z");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "isWorldLoaded", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }
    /// Gets the world that this location resides in
    pub fn world(&self) -> Result<Option<crate::World<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/World;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getWorld", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(crate::World::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })?))
    }
    /// Gets the chunk at the represented location
    pub fn chunk(&self) -> Result<crate::Chunk<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Chunk;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getChunk", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Chunk::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the block at the represented location
    pub fn block(&self) -> Result<crate::block::Block<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/block/Block;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBlock", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::block::Block::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the x-coordinate of this location
    pub fn set_x(&self, x: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(x);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setX",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the x-coordinate of this location
    pub fn x(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getX", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Gets the floored value of the X component, indicating the block that
    /// this location is contained with.
    pub fn block_x(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBlockX", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the y-coordinate of this location
    pub fn set_y(&self, y: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(y);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setY",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the y-coordinate of this location
    pub fn y(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getY", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Gets the floored value of the Y component, indicating the block that
    /// this location is contained with.
    pub fn block_y(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBlockY", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the z-coordinate of this location
    pub fn set_z(&self, z: f64) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(D)V");
        let val_1 = jni::objects::JValueGen::Double(z);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setZ",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the z-coordinate of this location
    pub fn z(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getZ", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Gets the floored value of the Z component, indicating the block that
    /// this location is contained with.
    pub fn block_z(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getBlockZ", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }
    /// Sets the yaw of this location, measured in degrees.
    /// <ul>
    /// <li>A yaw of 0 or 360 represents the positive z direction.
    /// <li>A yaw of 180 represents the negative z direction.
    /// <li>A yaw of 90 represents the negative x direction.
    /// <li>A yaw of 270 represents the positive x direction.
    /// </ul>
    /// Increasing yaw values are the equivalent of turning to your
    /// right-facing, increasing the scale of the next respective axis, and
    /// decreasing the scale of the previous axis.
    pub fn set_yaw(&self, yaw: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(yaw);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setYaw",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the yaw of this location, measured in degrees.
    /// <ul>
    /// <li>A yaw of 0 or 360 represents the positive z direction.
    /// <li>A yaw of 180 represents the negative z direction.
    /// <li>A yaw of 90 represents the negative x direction.
    /// <li>A yaw of 270 represents the positive x direction.
    /// </ul>
    /// Increasing yaw values are the equivalent of turning to your
    /// right-facing, increasing the scale of the next respective axis, and
    /// decreasing the scale of the previous axis.
    pub fn yaw(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getYaw", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Sets the pitch of this location, measured in degrees.
    /// <ul>
    /// <li>A pitch of 0 represents level forward facing.
    /// <li>A pitch of 90 represents downward facing, or negative y
    /// direction.
    /// <li>A pitch of -90 represents upward facing, or positive y direction.
    /// </ul>
    /// Increasing pitch values the equivalent of looking down.
    pub fn set_pitch(&self, pitch: f32) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(F)V");
        let val_1 = jni::objects::JValueGen::Float(pitch);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setPitch",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the pitch of this location, measured in degrees.
    /// <ul>
    /// <li>A pitch of 0 represents level forward facing.
    /// <li>A pitch of 90 represents downward facing, or negative y
    /// direction.
    /// <li>A pitch of -90 represents upward facing, or positive y direction.
    /// </ul>
    /// Increasing pitch values the equivalent of looking down.
    pub fn pitch(&self) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("()F");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getPitch", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.f()?)
    }
    /// Gets a unit-vector pointing in the direction that this Location is
    /// facing.
    pub fn direction(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/Vector;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDirection", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::Vector::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the {@link #getYaw() yaw} and {@link #getPitch() pitch} to point
    /// in the direction of the vector.
    pub fn set_direction(
        &self,
        vector: impl Into<crate::util::Vector<'mc>>,
    ) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/util/Vector;)Lorg/bukkit/Location;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(vector.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setDirection",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Adds the location by another. Not world-aware.
    pub fn add(
        &self,
        x: f64,
        y: std::option::Option<f64>,
        z: std::option::Option<f64>,
    ) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "D";
        let val_1 = jni::objects::JValueGen::Double(x);
        args.push(val_1);
        if let Some(a) = y {
            sig += "D";
            let val_2 = jni::objects::JValueGen::Double(a);
            args.push(val_2);
        }
        if let Some(a) = z {
            sig += "D";
            let val_3 = jni::objects::JValueGen::Double(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/Location;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "add", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Subtracts the location by another. Not world-aware and
    /// orientation independent.
    pub fn subtract(
        &self,
        x: f64,
        y: std::option::Option<f64>,
        z: std::option::Option<f64>,
    ) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "D";
        let val_1 = jni::objects::JValueGen::Double(x);
        args.push(val_1);
        if let Some(a) = y {
            sig += "D";
            let val_2 = jni::objects::JValueGen::Double(a);
            args.push(val_2);
        }
        if let Some(a) = z {
            sig += "D";
            let val_3 = jni::objects::JValueGen::Double(a);
            args.push(val_3);
        }
        sig += ")Lorg/bukkit/Location;";
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "subtract", sig.as_str(), args);
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the magnitude of the location, defined as sqrt(x^2+y^2+z^2). The
    /// value of this method is not cached and uses a costly square-root
    /// function, so do not repeatedly call this method to get the location's
    /// magnitude. NaN will be returned if the inner result of the sqrt()
    /// function overflows, which will be caused if the length is too long. Not
    /// world-aware and orientation independent.
    pub fn length(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "length", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Gets the magnitude of the location squared. Not world-aware and
    /// orientation independent.
    pub fn length_squared(&self) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("()D");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "lengthSquared", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Get the distance between this location and another. The value of this
    /// method is not cached and uses a costly square-root function, so do not
    /// repeatedly call this method to get the location's magnitude. NaN will
    /// be returned if the inner result of the sqrt() function overflows, which
    /// will be caused if the distance is too long.
    pub fn distance(
        &self,
        o: impl Into<crate::Location<'mc>>,
    ) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)D");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(o.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "distance",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Get the squared distance between this location and another.
    pub fn distance_squared(
        &self,
        o: impl Into<crate::Location<'mc>>,
    ) -> Result<f64, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Location;)D");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(o.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "distanceSquared",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.d()?)
    }
    /// Performs scalar multiplication, multiplying all components with a
    /// scalar. Not world-aware.
    pub fn multiply(&self, m: f64) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(D)Lorg/bukkit/Location;");
        let val_1 = jni::objects::JValueGen::Double(m);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "multiply",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Zero this location's components. Not world-aware.
    pub fn zero(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "zero", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn equals(
        &self,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/Object;)Z");
        let val_1 = jni::objects::JValueGen::Object(obj);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "equals",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    pub fn hash_code(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hashCode", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    #[doc(hidden)]
    pub fn internal_to_string(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "toString", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Constructs a new {@link Vector} based on this Location
    pub fn to_vector(&self) -> Result<crate::util::Vector<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/util/Vector;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "toVector", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::util::Vector::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn clone(&self) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Location;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "clone", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Location::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Check if each component of this Location is finite.
    pub fn check_finite(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "checkFinite", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Safely converts a double (location coordinate) to an int (block
    /// coordinate)
    pub fn loc_to_block(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        loc: f64,
    ) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("(D)I");
        let val_1 = jni::objects::JValueGen::Double(loc);
        let cls = jni.find_class("org/bukkit/Location");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "locToBlock",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn serialize(
        &self,
    ) -> Result<blackboxmc_java::util::JavaMap<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Map;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "serialize", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaMap::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Required method for deserialization
    pub fn deserialize(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        val_args: impl Into<blackboxmc_java::util::JavaMap<'mc>>,
    ) -> Result<crate::Location<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/Map;)Lorg/bukkit/Location;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(val_args.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/Location");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "deserialize",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Location::from_raw(&jni, obj)
    }
    /// Normalizes the given yaw angle to a value between <code>+/-180</code>
    /// degrees.
    pub fn normalize_yaw(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        yaw: f32,
    ) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("(F)F");
        let val_1 = jni::objects::JValueGen::Float(yaw);
        let cls = jni.find_class("org/bukkit/Location");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "normalizeYaw",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        Ok(res.f()?)
    }
    /// Normalizes the given pitch angle to a value between <code>+/-90</code>
    /// degrees.
    pub fn normalize_pitch(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        pitch: f32,
    ) -> Result<f32, Box<dyn std::error::Error>> {
        let sig = String::from("(F)F");
        let val_1 = jni::objects::JValueGen::Float(pitch);
        let cls = jni.find_class("org/bukkit/Location");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "normalizePitch",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        Ok(res.f()?)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}

impl<'mc> std::string::ToString for Location<'mc> {
    fn to_string(&self) -> String {
        match &self.internal_to_string() {
            Ok(a) => a.clone(),
            Err(err) => format!("Error calling Location.toString: {}", err),
        }
    }
}

impl<'mc> Into<crate::configuration::serialization::ConfigurationSerializable<'mc>>
    for Location<'mc>
{
    fn into(self) -> crate::configuration::serialization::ConfigurationSerializable<'mc> {
        crate::configuration::serialization::ConfigurationSerializable::from_raw(&self.jni_ref(), self.1).expect("Error converting Location into crate::configuration::serialization::ConfigurationSerializable")
    }
}
pub enum Fluid<'mc> {}
impl<'mc> std::fmt::Display for Fluid<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> Fluid<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Fluid<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Fluid");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Fluid;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct FluidStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Fluid<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for Fluid<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Fluid from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Fluid")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Fluid object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for FluidStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FluidStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate FluidStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Fluid")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FluidStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> FluidStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::Fluid<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Fluid;");
        let cls = jni.find_class("org/bukkit/Fluid");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Fluid::from_raw(&jni, obj)
    }

    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum TreeType<'mc> {}
impl<'mc> std::fmt::Display for TreeType<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> TreeType<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<TreeType<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/TreeType");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/TreeType;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct TreeTypeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for TreeType<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for TreeType<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate TreeType from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/TreeType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TreeType object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for TreeTypeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for TreeTypeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate TreeTypeStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/TreeType")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a TreeTypeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> TreeTypeStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::TreeType<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/TreeType;");
        let cls = jni.find_class("org/bukkit/TreeType");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::TreeType::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum DyeColor<'mc> {}
impl<'mc> std::fmt::Display for DyeColor<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> DyeColor<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<DyeColor<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/DyeColor");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/DyeColor;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct DyeColorStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for DyeColor<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for DyeColor<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate DyeColor from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/DyeColor")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a DyeColor object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for DyeColorStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for DyeColorStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate DyeColorStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/DyeColor")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a DyeColorStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> DyeColorStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::DyeColor<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/DyeColor;");
        let cls = jni.find_class("org/bukkit/DyeColor");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::DyeColor::from_raw(&jni, obj)
    }
    #[deprecated]
    /// Gets the associated wool data value representing this color.
    pub fn wool_data(&self) -> Result<i8, Box<dyn std::error::Error>> {
        let sig = String::from("()B");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getWoolData", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.b()?)
    }
    #[deprecated]
    /// Gets the associated dye data value representing this color.
    pub fn dye_data(&self) -> Result<i8, Box<dyn std::error::Error>> {
        let sig = String::from("()B");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getDyeData", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.b()?)
    }
    /// Gets the color that this dye represents.
    pub fn color(&self) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Color;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getColor", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Gets the firework color that this dye represents.
    pub fn firework_color(&self) -> Result<crate::Color<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Color;");
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "getFireworkColor",
            sig.as_str(),
            vec![],
        );
        let res = self.jni_ref().translate_error(res)?;
        crate::Color::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    #[deprecated]
    /// Gets the DyeColor with the given wool data value.
    pub fn get_by_wool_data(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        data: i8,
    ) -> Result<Option<crate::DyeColor<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(B)Lorg/bukkit/DyeColor;");
        let val_1 = jni::objects::JValueGen::Byte(data);
        let cls = jni.find_class("org/bukkit/DyeColor");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByWoolData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::DyeColor::from_raw(&jni, obj)?))
    }
    #[deprecated]
    /// Gets the DyeColor with the given dye data value.
    pub fn get_by_dye_data(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        data: i8,
    ) -> Result<Option<crate::DyeColor<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(B)Lorg/bukkit/DyeColor;");
        let val_1 = jni::objects::JValueGen::Byte(data);
        let cls = jni.find_class("org/bukkit/DyeColor");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByDyeData",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::DyeColor::from_raw(&jni, obj)?))
    }
    /// Gets the DyeColor with the given color value.
    pub fn get_by_color(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        color: impl Into<crate::Color<'mc>>,
    ) -> Result<Option<crate::DyeColor<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Color;)Lorg/bukkit/DyeColor;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(color.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/DyeColor");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByColor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::DyeColor::from_raw(&jni, obj)?))
    }
    /// Gets the DyeColor with the given firework color value.
    pub fn get_by_firework_color(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        color: impl Into<crate::Color<'mc>>,
    ) -> Result<Option<crate::DyeColor<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/Color;)Lorg/bukkit/DyeColor;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(color.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/DyeColor");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByFireworkColor",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::DyeColor::from_raw(&jni, obj)?))
    }
    #[deprecated]
    /// Gets the DyeColor for the given name, possibly doing legacy transformations.
    pub fn legacy_value_of(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        name: impl Into<String>,
    ) -> Result<crate::DyeColor<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/DyeColor;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(name.into())?,
        ));
        let cls = jni.find_class("org/bukkit/DyeColor");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "legacyValueOf",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::DyeColor::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum FluidCollisionMode<'mc> {}
impl<'mc> std::fmt::Display for FluidCollisionMode<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> FluidCollisionMode<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<FluidCollisionMode<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/FluidCollisionMode");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/FluidCollisionMode;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct FluidCollisionModeStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for FluidCollisionMode<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for FluidCollisionMode<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate FluidCollisionMode from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/FluidCollisionMode")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FluidCollisionMode object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for FluidCollisionModeStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for FluidCollisionModeStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!(
                "Tried to instantiate FluidCollisionModeStruct from null object."
            )
            .into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/FluidCollisionMode")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a FluidCollisionModeStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> FluidCollisionModeStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::FluidCollisionMode<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/FluidCollisionMode;");
        let cls = jni.find_class("org/bukkit/FluidCollisionMode");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::FluidCollisionMode::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct NamespacedKey<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for NamespacedKey<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for NamespacedKey<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate NamespacedKey from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/NamespacedKey")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a NamespacedKey object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> NamespacedKey<'mc> {
    /// Create a key in the plugin's namespace.
    ///
    /// Namespaces may only contain lowercase alphanumeric characters, periods,
    /// underscores, and hyphens.
    ///
    /// Keys may only contain lowercase alphanumeric characters, periods,
    /// underscores, hyphens, and forward slashes.
    pub fn new(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        plugin: impl Into<crate::plugin::Plugin<'mc>>,
        key: impl Into<String>,
    ) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Lorg/bukkit/plugin/Plugin;";
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(plugin.into().jni_object().clone())
        });
        args.push(val_1);
        sig += "Ljava/lang/String;";
        let val_2 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(key.into())?,
        ));
        args.push(val_2);
        sig += ")V";
        let cls = jni.find_class("org/bukkit/NamespacedKey");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.new_object(cls, sig.as_str(), args);
        let res = jni.translate_error_no_gen(res)?;
        crate::NamespacedKey::from_raw(&jni, res)
    }

    pub fn namespace(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getNamespace", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn key(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }

    pub fn hash_code(&self) -> Result<i32, Box<dyn std::error::Error>> {
        let sig = String::from("()I");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "hashCode", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.i()?)
    }

    pub fn equals(
        &self,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/Object;)Z");
        let val_1 = jni::objects::JValueGen::Object(obj);
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "equals",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.z()?)
    }

    #[doc(hidden)]
    pub fn internal_to_string(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "toString", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    #[deprecated]
    /// Return a new random key in the {@link #BUKKIT} namespace.
    pub fn random_key(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let cls = jni.find_class("org/bukkit/NamespacedKey");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "randomKey", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::NamespacedKey::from_raw(&jni, obj)
    }
    /// Get a key in the Minecraft namespace.
    pub fn minecraft(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        key: impl Into<String>,
    ) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)Lorg/bukkit/NamespacedKey;");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(key.into())?,
        ));
        let cls = jni.find_class("org/bukkit/NamespacedKey");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "minecraft",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::NamespacedKey::from_raw(&jni, obj)
    }
    /// Get a NamespacedKey from the supplied string with a default namespace if
    /// a namespace is not defined. This is a utility method meant to fetch a
    /// NamespacedKey from user input. Please note that casing does matter and
    /// any instance of uppercase characters will be considered invalid. The
    /// input contract is as follows:
    /// <pre>
    /// fromString("foo", plugin) -{@literal >} "plugin:foo"
    /// fromString("foo:bar", plugin) -{@literal >} "foo:bar"
    /// fromString(":foo", null) -{@literal >} "minecraft:foo"
    /// fromString("foo", null) -{@literal >} "minecraft:foo"
    /// fromString("Foo", plugin) -{@literal >} null
    /// fromString(":Foo", plugin) -{@literal >} null
    /// fromString("foo:bar:bazz", plugin) -{@literal >} null
    /// fromString("", plugin) -{@literal >} null
    /// </pre>
    pub fn from_string(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        string: impl Into<String>,
        default_namespace: std::option::Option<impl Into<crate::plugin::Plugin<'mc>>>,
    ) -> Result<Option<crate::NamespacedKey<'mc>>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        let mut sig = String::from("(");
        sig += "Ljava/lang/String;";
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            jni.new_string(string.into())?,
        ));
        args.push(val_1);
        if let Some(a) = default_namespace {
            sig += "Lorg/bukkit/plugin/Plugin;";
            let val_2 = jni::objects::JValueGen::Object(unsafe {
                jni::objects::JObject::from_raw(a.into().jni_object().clone())
            });
            args.push(val_2);
        }
        sig += ")Lorg/bukkit/NamespacedKey;";
        let cls = jni.find_class("org/bukkit/NamespacedKey");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "fromString", sig.as_str(), args);
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::NamespacedKey::from_raw(&jni, obj)?))
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}

impl<'mc> std::string::ToString for NamespacedKey<'mc> {
    fn to_string(&self) -> String {
        match &self.internal_to_string() {
            Ok(a) => a.clone(),
            Err(err) => format!("Error calling NamespacedKey.toString: {}", err),
        }
    }
}

pub enum GameEvent<'mc> {
    BlockActivate { inner: GameEventStruct<'mc> },
    BlockAttach { inner: GameEventStruct<'mc> },
    BlockChange { inner: GameEventStruct<'mc> },
    BlockClose { inner: GameEventStruct<'mc> },
    BlockDeactivate { inner: GameEventStruct<'mc> },
    BlockDestroy { inner: GameEventStruct<'mc> },
    BlockDetach { inner: GameEventStruct<'mc> },
    BlockOpen { inner: GameEventStruct<'mc> },
    BlockPlace { inner: GameEventStruct<'mc> },
    BlockPress { inner: GameEventStruct<'mc> },
    BlockSwitch { inner: GameEventStruct<'mc> },
    BlockUnpress { inner: GameEventStruct<'mc> },
    BlockUnswitch { inner: GameEventStruct<'mc> },
    ContainerClose { inner: GameEventStruct<'mc> },
    ContainerOpen { inner: GameEventStruct<'mc> },
    DispenseFail { inner: GameEventStruct<'mc> },
    Drink { inner: GameEventStruct<'mc> },
    DrinkingFinish { inner: GameEventStruct<'mc> },
    Eat { inner: GameEventStruct<'mc> },
    ElytraFreeFall { inner: GameEventStruct<'mc> },
    ElytraGlide { inner: GameEventStruct<'mc> },
    EntityDamage { inner: GameEventStruct<'mc> },
    EntityDamaged { inner: GameEventStruct<'mc> },
    EntityDie { inner: GameEventStruct<'mc> },
    EntityDismount { inner: GameEventStruct<'mc> },
    EntityDying { inner: GameEventStruct<'mc> },
    EntityInteract { inner: GameEventStruct<'mc> },
    EntityMount { inner: GameEventStruct<'mc> },
    EntityKilled { inner: GameEventStruct<'mc> },
    EntityPlace { inner: GameEventStruct<'mc> },
    EntityAction { inner: GameEventStruct<'mc> },
    EntityRoar { inner: GameEventStruct<'mc> },
    EntityShake { inner: GameEventStruct<'mc> },
    Equip { inner: GameEventStruct<'mc> },
    Explode { inner: GameEventStruct<'mc> },
    Flap { inner: GameEventStruct<'mc> },
    FluidPickup { inner: GameEventStruct<'mc> },
    FluidPlace { inner: GameEventStruct<'mc> },
    HitGround { inner: GameEventStruct<'mc> },
    InstrumentPlay { inner: GameEventStruct<'mc> },
    ItemInteractFinish { inner: GameEventStruct<'mc> },
    ItemInteractStart { inner: GameEventStruct<'mc> },
    JukeboxPlay { inner: GameEventStruct<'mc> },
    JukeboxStopPlay { inner: GameEventStruct<'mc> },
    LightningStrike { inner: GameEventStruct<'mc> },
    MobInteract { inner: GameEventStruct<'mc> },
    NoteBlockPlay { inner: GameEventStruct<'mc> },
    PistonContract { inner: GameEventStruct<'mc> },
    PistonExtend { inner: GameEventStruct<'mc> },
    PrimeFuse { inner: GameEventStruct<'mc> },
    ProjectileLand { inner: GameEventStruct<'mc> },
    ProjectileShoot { inner: GameEventStruct<'mc> },
    RavagerRoar { inner: GameEventStruct<'mc> },
    RingBell { inner: GameEventStruct<'mc> },
    SculkSensorTendrilsClicking { inner: GameEventStruct<'mc> },
    Shear { inner: GameEventStruct<'mc> },
    Shriek { inner: GameEventStruct<'mc> },
    ShulkerClose { inner: GameEventStruct<'mc> },
    ShulkerOpen { inner: GameEventStruct<'mc> },
    Splash { inner: GameEventStruct<'mc> },
    Step { inner: GameEventStruct<'mc> },
    Swim { inner: GameEventStruct<'mc> },
    Teleport { inner: GameEventStruct<'mc> },
    Unequip { inner: GameEventStruct<'mc> },
    WolfShaking { inner: GameEventStruct<'mc> },
    Resonate1 { inner: GameEventStruct<'mc> },
    Resonate2 { inner: GameEventStruct<'mc> },
    Resonate3 { inner: GameEventStruct<'mc> },
    Resonate4 { inner: GameEventStruct<'mc> },
    Resonate5 { inner: GameEventStruct<'mc> },
    Resonate6 { inner: GameEventStruct<'mc> },
    Resonate7 { inner: GameEventStruct<'mc> },
    Resonate8 { inner: GameEventStruct<'mc> },
    Resonate9 { inner: GameEventStruct<'mc> },
    Resonate10 { inner: GameEventStruct<'mc> },
    Resonate11 { inner: GameEventStruct<'mc> },
    Resonate12 { inner: GameEventStruct<'mc> },
    Resonate13 { inner: GameEventStruct<'mc> },
    Resonate14 { inner: GameEventStruct<'mc> },
    Resonate15 { inner: GameEventStruct<'mc> },
}
impl<'mc> std::fmt::Display for GameEvent<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GameEvent::BlockActivate { .. } => f.write_str("BLOCK_ACTIVATE"),
            GameEvent::BlockAttach { .. } => f.write_str("BLOCK_ATTACH"),
            GameEvent::BlockChange { .. } => f.write_str("BLOCK_CHANGE"),
            GameEvent::BlockClose { .. } => f.write_str("BLOCK_CLOSE"),
            GameEvent::BlockDeactivate { .. } => f.write_str("BLOCK_DEACTIVATE"),
            GameEvent::BlockDestroy { .. } => f.write_str("BLOCK_DESTROY"),
            GameEvent::BlockDetach { .. } => f.write_str("BLOCK_DETACH"),
            GameEvent::BlockOpen { .. } => f.write_str("BLOCK_OPEN"),
            GameEvent::BlockPlace { .. } => f.write_str("BLOCK_PLACE"),
            GameEvent::BlockPress { .. } => f.write_str("BLOCK_PRESS"),
            GameEvent::BlockSwitch { .. } => f.write_str("BLOCK_SWITCH"),
            GameEvent::BlockUnpress { .. } => f.write_str("BLOCK_UNPRESS"),
            GameEvent::BlockUnswitch { .. } => f.write_str("BLOCK_UNSWITCH"),
            GameEvent::ContainerClose { .. } => f.write_str("CONTAINER_CLOSE"),
            GameEvent::ContainerOpen { .. } => f.write_str("CONTAINER_OPEN"),
            GameEvent::DispenseFail { .. } => f.write_str("DISPENSE_FAIL"),
            GameEvent::Drink { .. } => f.write_str("DRINK"),
            GameEvent::DrinkingFinish { .. } => f.write_str("DRINKING_FINISH"),
            GameEvent::Eat { .. } => f.write_str("EAT"),
            GameEvent::ElytraFreeFall { .. } => f.write_str("ELYTRA_FREE_FALL"),
            GameEvent::ElytraGlide { .. } => f.write_str("ELYTRA_GLIDE"),
            GameEvent::EntityDamage { .. } => f.write_str("ENTITY_DAMAGE"),
            GameEvent::EntityDamaged { .. } => f.write_str("ENTITY_DAMAGED"),
            GameEvent::EntityDie { .. } => f.write_str("ENTITY_DIE"),
            GameEvent::EntityDismount { .. } => f.write_str("ENTITY_DISMOUNT"),
            GameEvent::EntityDying { .. } => f.write_str("ENTITY_DYING"),
            GameEvent::EntityInteract { .. } => f.write_str("ENTITY_INTERACT"),
            GameEvent::EntityMount { .. } => f.write_str("ENTITY_MOUNT"),
            GameEvent::EntityKilled { .. } => f.write_str("ENTITY_KILLED"),
            GameEvent::EntityPlace { .. } => f.write_str("ENTITY_PLACE"),
            GameEvent::EntityAction { .. } => f.write_str("ENTITY_ACTION"),
            GameEvent::EntityRoar { .. } => f.write_str("ENTITY_ROAR"),
            GameEvent::EntityShake { .. } => f.write_str("ENTITY_SHAKE"),
            GameEvent::Equip { .. } => f.write_str("EQUIP"),
            GameEvent::Explode { .. } => f.write_str("EXPLODE"),
            GameEvent::Flap { .. } => f.write_str("FLAP"),
            GameEvent::FluidPickup { .. } => f.write_str("FLUID_PICKUP"),
            GameEvent::FluidPlace { .. } => f.write_str("FLUID_PLACE"),
            GameEvent::HitGround { .. } => f.write_str("HIT_GROUND"),
            GameEvent::InstrumentPlay { .. } => f.write_str("INSTRUMENT_PLAY"),
            GameEvent::ItemInteractFinish { .. } => f.write_str("ITEM_INTERACT_FINISH"),
            GameEvent::ItemInteractStart { .. } => f.write_str("ITEM_INTERACT_START"),
            GameEvent::JukeboxPlay { .. } => f.write_str("JUKEBOX_PLAY"),
            GameEvent::JukeboxStopPlay { .. } => f.write_str("JUKEBOX_STOP_PLAY"),
            GameEvent::LightningStrike { .. } => f.write_str("LIGHTNING_STRIKE"),
            GameEvent::MobInteract { .. } => f.write_str("MOB_INTERACT"),
            GameEvent::NoteBlockPlay { .. } => f.write_str("NOTE_BLOCK_PLAY"),
            GameEvent::PistonContract { .. } => f.write_str("PISTON_CONTRACT"),
            GameEvent::PistonExtend { .. } => f.write_str("PISTON_EXTEND"),
            GameEvent::PrimeFuse { .. } => f.write_str("PRIME_FUSE"),
            GameEvent::ProjectileLand { .. } => f.write_str("PROJECTILE_LAND"),
            GameEvent::ProjectileShoot { .. } => f.write_str("PROJECTILE_SHOOT"),
            GameEvent::RavagerRoar { .. } => f.write_str("RAVAGER_ROAR"),
            GameEvent::RingBell { .. } => f.write_str("RING_BELL"),
            GameEvent::SculkSensorTendrilsClicking { .. } => {
                f.write_str("SCULK_SENSOR_TENDRILS_CLICKING")
            }
            GameEvent::Shear { .. } => f.write_str("SHEAR"),
            GameEvent::Shriek { .. } => f.write_str("SHRIEK"),
            GameEvent::ShulkerClose { .. } => f.write_str("SHULKER_CLOSE"),
            GameEvent::ShulkerOpen { .. } => f.write_str("SHULKER_OPEN"),
            GameEvent::Splash { .. } => f.write_str("SPLASH"),
            GameEvent::Step { .. } => f.write_str("STEP"),
            GameEvent::Swim { .. } => f.write_str("SWIM"),
            GameEvent::Teleport { .. } => f.write_str("TELEPORT"),
            GameEvent::Unequip { .. } => f.write_str("UNEQUIP"),
            GameEvent::WolfShaking { .. } => f.write_str("WOLF_SHAKING"),
            GameEvent::Resonate1 { .. } => f.write_str("RESONATE_1"),
            GameEvent::Resonate2 { .. } => f.write_str("RESONATE_2"),
            GameEvent::Resonate3 { .. } => f.write_str("RESONATE_3"),
            GameEvent::Resonate4 { .. } => f.write_str("RESONATE_4"),
            GameEvent::Resonate5 { .. } => f.write_str("RESONATE_5"),
            GameEvent::Resonate6 { .. } => f.write_str("RESONATE_6"),
            GameEvent::Resonate7 { .. } => f.write_str("RESONATE_7"),
            GameEvent::Resonate8 { .. } => f.write_str("RESONATE_8"),
            GameEvent::Resonate9 { .. } => f.write_str("RESONATE_9"),
            GameEvent::Resonate10 { .. } => f.write_str("RESONATE_10"),
            GameEvent::Resonate11 { .. } => f.write_str("RESONATE_11"),
            GameEvent::Resonate12 { .. } => f.write_str("RESONATE_12"),
            GameEvent::Resonate13 { .. } => f.write_str("RESONATE_13"),
            GameEvent::Resonate14 { .. } => f.write_str("RESONATE_14"),
            GameEvent::Resonate15 { .. } => f.write_str("RESONATE_15"),
        }
    }
}

impl<'mc> GameEvent<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<GameEvent<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/GameEvent");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/GameEvent;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            "BLOCK_ACTIVATE" => Ok(GameEvent::BlockActivate {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "BLOCK_ATTACH" => Ok(GameEvent::BlockAttach {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "BLOCK_CHANGE" => Ok(GameEvent::BlockChange {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "BLOCK_CLOSE" => Ok(GameEvent::BlockClose {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "BLOCK_DEACTIVATE" => Ok(GameEvent::BlockDeactivate {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "BLOCK_DESTROY" => Ok(GameEvent::BlockDestroy {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "BLOCK_DETACH" => Ok(GameEvent::BlockDetach {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "BLOCK_OPEN" => Ok(GameEvent::BlockOpen {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "BLOCK_PLACE" => Ok(GameEvent::BlockPlace {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "BLOCK_PRESS" => Ok(GameEvent::BlockPress {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "BLOCK_SWITCH" => Ok(GameEvent::BlockSwitch {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "BLOCK_UNPRESS" => Ok(GameEvent::BlockUnpress {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "BLOCK_UNSWITCH" => Ok(GameEvent::BlockUnswitch {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "CONTAINER_CLOSE" => Ok(GameEvent::ContainerClose {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "CONTAINER_OPEN" => Ok(GameEvent::ContainerOpen {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "DISPENSE_FAIL" => Ok(GameEvent::DispenseFail {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "DRINK" => Ok(GameEvent::Drink {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "DRINKING_FINISH" => Ok(GameEvent::DrinkingFinish {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "EAT" => Ok(GameEvent::Eat {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ELYTRA_FREE_FALL" => Ok(GameEvent::ElytraFreeFall {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ELYTRA_GLIDE" => Ok(GameEvent::ElytraGlide {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ENTITY_DAMAGE" => Ok(GameEvent::EntityDamage {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ENTITY_DAMAGED" => Ok(GameEvent::EntityDamaged {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ENTITY_DIE" => Ok(GameEvent::EntityDie {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ENTITY_DISMOUNT" => Ok(GameEvent::EntityDismount {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ENTITY_DYING" => Ok(GameEvent::EntityDying {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ENTITY_INTERACT" => Ok(GameEvent::EntityInteract {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ENTITY_MOUNT" => Ok(GameEvent::EntityMount {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ENTITY_KILLED" => Ok(GameEvent::EntityKilled {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ENTITY_PLACE" => Ok(GameEvent::EntityPlace {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ENTITY_ACTION" => Ok(GameEvent::EntityAction {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ENTITY_ROAR" => Ok(GameEvent::EntityRoar {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ENTITY_SHAKE" => Ok(GameEvent::EntityShake {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "EQUIP" => Ok(GameEvent::Equip {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "EXPLODE" => Ok(GameEvent::Explode {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "FLAP" => Ok(GameEvent::Flap {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "FLUID_PICKUP" => Ok(GameEvent::FluidPickup {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "FLUID_PLACE" => Ok(GameEvent::FluidPlace {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "HIT_GROUND" => Ok(GameEvent::HitGround {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "INSTRUMENT_PLAY" => Ok(GameEvent::InstrumentPlay {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ITEM_INTERACT_FINISH" => Ok(GameEvent::ItemInteractFinish {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "ITEM_INTERACT_START" => Ok(GameEvent::ItemInteractStart {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "JUKEBOX_PLAY" => Ok(GameEvent::JukeboxPlay {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "JUKEBOX_STOP_PLAY" => Ok(GameEvent::JukeboxStopPlay {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "LIGHTNING_STRIKE" => Ok(GameEvent::LightningStrike {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "MOB_INTERACT" => Ok(GameEvent::MobInteract {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "NOTE_BLOCK_PLAY" => Ok(GameEvent::NoteBlockPlay {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "PISTON_CONTRACT" => Ok(GameEvent::PistonContract {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "PISTON_EXTEND" => Ok(GameEvent::PistonExtend {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "PRIME_FUSE" => Ok(GameEvent::PrimeFuse {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "PROJECTILE_LAND" => Ok(GameEvent::ProjectileLand {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "PROJECTILE_SHOOT" => Ok(GameEvent::ProjectileShoot {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RAVAGER_ROAR" => Ok(GameEvent::RavagerRoar {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RING_BELL" => Ok(GameEvent::RingBell {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "SCULK_SENSOR_TENDRILS_CLICKING" => Ok(GameEvent::SculkSensorTendrilsClicking {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "SHEAR" => Ok(GameEvent::Shear {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "SHRIEK" => Ok(GameEvent::Shriek {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "SHULKER_CLOSE" => Ok(GameEvent::ShulkerClose {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "SHULKER_OPEN" => Ok(GameEvent::ShulkerOpen {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "SPLASH" => Ok(GameEvent::Splash {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "STEP" => Ok(GameEvent::Step {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "SWIM" => Ok(GameEvent::Swim {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "TELEPORT" => Ok(GameEvent::Teleport {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "UNEQUIP" => Ok(GameEvent::Unequip {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "WOLF_SHAKING" => Ok(GameEvent::WolfShaking {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_1" => Ok(GameEvent::Resonate1 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_2" => Ok(GameEvent::Resonate2 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_3" => Ok(GameEvent::Resonate3 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_4" => Ok(GameEvent::Resonate4 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_5" => Ok(GameEvent::Resonate5 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_6" => Ok(GameEvent::Resonate6 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_7" => Ok(GameEvent::Resonate7 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_8" => Ok(GameEvent::Resonate8 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_9" => Ok(GameEvent::Resonate9 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_10" => Ok(GameEvent::Resonate10 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_11" => Ok(GameEvent::Resonate11 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_12" => Ok(GameEvent::Resonate12 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_13" => Ok(GameEvent::Resonate13 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_14" => Ok(GameEvent::Resonate14 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),
            "RESONATE_15" => Ok(GameEvent::Resonate15 {
                inner: GameEventStruct::from_raw(env, obj)?,
            }),

            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct GameEventStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for GameEvent<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {
            Self::BlockActivate { inner } => inner.0.clone(),
            Self::BlockAttach { inner } => inner.0.clone(),
            Self::BlockChange { inner } => inner.0.clone(),
            Self::BlockClose { inner } => inner.0.clone(),
            Self::BlockDeactivate { inner } => inner.0.clone(),
            Self::BlockDestroy { inner } => inner.0.clone(),
            Self::BlockDetach { inner } => inner.0.clone(),
            Self::BlockOpen { inner } => inner.0.clone(),
            Self::BlockPlace { inner } => inner.0.clone(),
            Self::BlockPress { inner } => inner.0.clone(),
            Self::BlockSwitch { inner } => inner.0.clone(),
            Self::BlockUnpress { inner } => inner.0.clone(),
            Self::BlockUnswitch { inner } => inner.0.clone(),
            Self::ContainerClose { inner } => inner.0.clone(),
            Self::ContainerOpen { inner } => inner.0.clone(),
            Self::DispenseFail { inner } => inner.0.clone(),
            Self::Drink { inner } => inner.0.clone(),
            Self::DrinkingFinish { inner } => inner.0.clone(),
            Self::Eat { inner } => inner.0.clone(),
            Self::ElytraFreeFall { inner } => inner.0.clone(),
            Self::ElytraGlide { inner } => inner.0.clone(),
            Self::EntityDamage { inner } => inner.0.clone(),
            Self::EntityDamaged { inner } => inner.0.clone(),
            Self::EntityDie { inner } => inner.0.clone(),
            Self::EntityDismount { inner } => inner.0.clone(),
            Self::EntityDying { inner } => inner.0.clone(),
            Self::EntityInteract { inner } => inner.0.clone(),
            Self::EntityMount { inner } => inner.0.clone(),
            Self::EntityKilled { inner } => inner.0.clone(),
            Self::EntityPlace { inner } => inner.0.clone(),
            Self::EntityAction { inner } => inner.0.clone(),
            Self::EntityRoar { inner } => inner.0.clone(),
            Self::EntityShake { inner } => inner.0.clone(),
            Self::Equip { inner } => inner.0.clone(),
            Self::Explode { inner } => inner.0.clone(),
            Self::Flap { inner } => inner.0.clone(),
            Self::FluidPickup { inner } => inner.0.clone(),
            Self::FluidPlace { inner } => inner.0.clone(),
            Self::HitGround { inner } => inner.0.clone(),
            Self::InstrumentPlay { inner } => inner.0.clone(),
            Self::ItemInteractFinish { inner } => inner.0.clone(),
            Self::ItemInteractStart { inner } => inner.0.clone(),
            Self::JukeboxPlay { inner } => inner.0.clone(),
            Self::JukeboxStopPlay { inner } => inner.0.clone(),
            Self::LightningStrike { inner } => inner.0.clone(),
            Self::MobInteract { inner } => inner.0.clone(),
            Self::NoteBlockPlay { inner } => inner.0.clone(),
            Self::PistonContract { inner } => inner.0.clone(),
            Self::PistonExtend { inner } => inner.0.clone(),
            Self::PrimeFuse { inner } => inner.0.clone(),
            Self::ProjectileLand { inner } => inner.0.clone(),
            Self::ProjectileShoot { inner } => inner.0.clone(),
            Self::RavagerRoar { inner } => inner.0.clone(),
            Self::RingBell { inner } => inner.0.clone(),
            Self::SculkSensorTendrilsClicking { inner } => inner.0.clone(),
            Self::Shear { inner } => inner.0.clone(),
            Self::Shriek { inner } => inner.0.clone(),
            Self::ShulkerClose { inner } => inner.0.clone(),
            Self::ShulkerOpen { inner } => inner.0.clone(),
            Self::Splash { inner } => inner.0.clone(),
            Self::Step { inner } => inner.0.clone(),
            Self::Swim { inner } => inner.0.clone(),
            Self::Teleport { inner } => inner.0.clone(),
            Self::Unequip { inner } => inner.0.clone(),
            Self::WolfShaking { inner } => inner.0.clone(),
            Self::Resonate1 { inner } => inner.0.clone(),
            Self::Resonate2 { inner } => inner.0.clone(),
            Self::Resonate3 { inner } => inner.0.clone(),
            Self::Resonate4 { inner } => inner.0.clone(),
            Self::Resonate5 { inner } => inner.0.clone(),
            Self::Resonate6 { inner } => inner.0.clone(),
            Self::Resonate7 { inner } => inner.0.clone(),
            Self::Resonate8 { inner } => inner.0.clone(),
            Self::Resonate9 { inner } => inner.0.clone(),
            Self::Resonate10 { inner } => inner.0.clone(),
            Self::Resonate11 { inner } => inner.0.clone(),
            Self::Resonate12 { inner } => inner.0.clone(),
            Self::Resonate13 { inner } => inner.0.clone(),
            Self::Resonate14 { inner } => inner.0.clone(),
            Self::Resonate15 { inner } => inner.0.clone(),
        }
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {
            Self::BlockActivate { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlockAttach { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlockChange { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlockClose { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlockDeactivate { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlockDestroy { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlockDetach { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlockOpen { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlockPlace { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlockPress { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlockSwitch { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlockUnpress { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::BlockUnswitch { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ContainerClose { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ContainerOpen { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::DispenseFail { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Drink { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::DrinkingFinish { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Eat { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::ElytraFreeFall { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ElytraGlide { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EntityDamage { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EntityDamaged { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EntityDie { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EntityDismount { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EntityDying { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EntityInteract { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EntityMount { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EntityKilled { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EntityPlace { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EntityAction { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EntityRoar { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::EntityShake { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Equip { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Explode { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Flap { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::FluidPickup { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::FluidPlace { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::HitGround { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::InstrumentPlay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ItemInteractFinish { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ItemInteractStart { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::JukeboxPlay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::JukeboxStopPlay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::LightningStrike { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::MobInteract { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::NoteBlockPlay { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::PistonContract { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::PistonExtend { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::PrimeFuse { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ProjectileLand { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ProjectileShoot { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::RavagerRoar { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::RingBell { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::SculkSensorTendrilsClicking { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Shear { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Shriek { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::ShulkerClose { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::ShulkerOpen { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Splash { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Step { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Swim { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Teleport { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::Unequip { inner } => unsafe { jni::objects::JObject::from_raw(inner.1.clone()) },
            Self::WolfShaking { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate1 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate2 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate3 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate4 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate5 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate6 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate7 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate8 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate9 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate10 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate11 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate12 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate13 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate14 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
            Self::Resonate15 { inner } => unsafe {
                jni::objects::JObject::from_raw(inner.1.clone())
            },
        }
    }
}
impl<'mc> JNIInstantiatable<'mc> for GameEvent<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate GameEvent from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/GameEvent")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a GameEvent object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                "BLOCK_ACTIVATE" => Ok(GameEvent::BlockActivate {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "BLOCK_ATTACH" => Ok(GameEvent::BlockAttach {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "BLOCK_CHANGE" => Ok(GameEvent::BlockChange {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "BLOCK_CLOSE" => Ok(GameEvent::BlockClose {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "BLOCK_DEACTIVATE" => Ok(GameEvent::BlockDeactivate {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "BLOCK_DESTROY" => Ok(GameEvent::BlockDestroy {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "BLOCK_DETACH" => Ok(GameEvent::BlockDetach {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "BLOCK_OPEN" => Ok(GameEvent::BlockOpen {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "BLOCK_PLACE" => Ok(GameEvent::BlockPlace {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "BLOCK_PRESS" => Ok(GameEvent::BlockPress {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "BLOCK_SWITCH" => Ok(GameEvent::BlockSwitch {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "BLOCK_UNPRESS" => Ok(GameEvent::BlockUnpress {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "BLOCK_UNSWITCH" => Ok(GameEvent::BlockUnswitch {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "CONTAINER_CLOSE" => Ok(GameEvent::ContainerClose {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "CONTAINER_OPEN" => Ok(GameEvent::ContainerOpen {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "DISPENSE_FAIL" => Ok(GameEvent::DispenseFail {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "DRINK" => Ok(GameEvent::Drink {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "DRINKING_FINISH" => Ok(GameEvent::DrinkingFinish {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "EAT" => Ok(GameEvent::Eat {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ELYTRA_FREE_FALL" => Ok(GameEvent::ElytraFreeFall {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ELYTRA_GLIDE" => Ok(GameEvent::ElytraGlide {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ENTITY_DAMAGE" => Ok(GameEvent::EntityDamage {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ENTITY_DAMAGED" => Ok(GameEvent::EntityDamaged {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ENTITY_DIE" => Ok(GameEvent::EntityDie {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ENTITY_DISMOUNT" => Ok(GameEvent::EntityDismount {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ENTITY_DYING" => Ok(GameEvent::EntityDying {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ENTITY_INTERACT" => Ok(GameEvent::EntityInteract {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ENTITY_MOUNT" => Ok(GameEvent::EntityMount {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ENTITY_KILLED" => Ok(GameEvent::EntityKilled {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ENTITY_PLACE" => Ok(GameEvent::EntityPlace {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ENTITY_ACTION" => Ok(GameEvent::EntityAction {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ENTITY_ROAR" => Ok(GameEvent::EntityRoar {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ENTITY_SHAKE" => Ok(GameEvent::EntityShake {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "EQUIP" => Ok(GameEvent::Equip {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "EXPLODE" => Ok(GameEvent::Explode {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "FLAP" => Ok(GameEvent::Flap {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "FLUID_PICKUP" => Ok(GameEvent::FluidPickup {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "FLUID_PLACE" => Ok(GameEvent::FluidPlace {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "HIT_GROUND" => Ok(GameEvent::HitGround {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "INSTRUMENT_PLAY" => Ok(GameEvent::InstrumentPlay {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ITEM_INTERACT_FINISH" => Ok(GameEvent::ItemInteractFinish {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "ITEM_INTERACT_START" => Ok(GameEvent::ItemInteractStart {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "JUKEBOX_PLAY" => Ok(GameEvent::JukeboxPlay {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "JUKEBOX_STOP_PLAY" => Ok(GameEvent::JukeboxStopPlay {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "LIGHTNING_STRIKE" => Ok(GameEvent::LightningStrike {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "MOB_INTERACT" => Ok(GameEvent::MobInteract {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "NOTE_BLOCK_PLAY" => Ok(GameEvent::NoteBlockPlay {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "PISTON_CONTRACT" => Ok(GameEvent::PistonContract {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "PISTON_EXTEND" => Ok(GameEvent::PistonExtend {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "PRIME_FUSE" => Ok(GameEvent::PrimeFuse {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "PROJECTILE_LAND" => Ok(GameEvent::ProjectileLand {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "PROJECTILE_SHOOT" => Ok(GameEvent::ProjectileShoot {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RAVAGER_ROAR" => Ok(GameEvent::RavagerRoar {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RING_BELL" => Ok(GameEvent::RingBell {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "SCULK_SENSOR_TENDRILS_CLICKING" => Ok(GameEvent::SculkSensorTendrilsClicking {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "SHEAR" => Ok(GameEvent::Shear {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "SHRIEK" => Ok(GameEvent::Shriek {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "SHULKER_CLOSE" => Ok(GameEvent::ShulkerClose {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "SHULKER_OPEN" => Ok(GameEvent::ShulkerOpen {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "SPLASH" => Ok(GameEvent::Splash {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "STEP" => Ok(GameEvent::Step {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "SWIM" => Ok(GameEvent::Swim {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "TELEPORT" => Ok(GameEvent::Teleport {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "UNEQUIP" => Ok(GameEvent::Unequip {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "WOLF_SHAKING" => Ok(GameEvent::WolfShaking {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_1" => Ok(GameEvent::Resonate1 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_2" => Ok(GameEvent::Resonate2 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_3" => Ok(GameEvent::Resonate3 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_4" => Ok(GameEvent::Resonate4 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_5" => Ok(GameEvent::Resonate5 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_6" => Ok(GameEvent::Resonate6 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_7" => Ok(GameEvent::Resonate7 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_8" => Ok(GameEvent::Resonate8 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_9" => Ok(GameEvent::Resonate9 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_10" => Ok(GameEvent::Resonate10 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_11" => Ok(GameEvent::Resonate11 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_12" => Ok(GameEvent::Resonate12 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_13" => Ok(GameEvent::Resonate13 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_14" => Ok(GameEvent::Resonate14 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                "RESONATE_15" => Ok(GameEvent::Resonate15 {
                    inner: GameEventStruct::from_raw(env, obj)?,
                }),
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for GameEventStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for GameEventStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(
                eyre::eyre!("Tried to instantiate GameEventStruct from null object.").into(),
            );
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/GameEvent")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a GameEventStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> GameEventStruct<'mc> {
    #[deprecated]
    /// Returns a {@link GameEvent} by a {@link NamespacedKey}.
    pub fn get_by_key(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
        namespaced_key: impl Into<crate::NamespacedKey<'mc>>,
    ) -> Result<Option<crate::GameEvent<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("(Lorg/bukkit/NamespacedKey;)Lorg/bukkit/GameEvent;");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(namespaced_key.into().jni_object().clone())
        });
        let cls = jni.find_class("org/bukkit/GameEvent");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(
            cls,
            "getByKey",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = jni.translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        let obj = res.l()?;
        Ok(Some(crate::GameEvent::from_raw(&jni, obj)?))
    }
    #[deprecated]
    /// Returns the set of all GameEvents.
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<Vec<crate::GameEvent<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Collection;");
        let cls = jni.find_class("org/bukkit/GameEvent");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let mut new_vec = Vec::new();
        let col = blackboxmc_java::util::JavaCollection::from_raw(&jni, res.l()?)?;
        let iter = col.iterator()?;
        while iter.has_next()? {
            let obj = iter.next()?;
            new_vec.push(crate::GameEvent::from_raw(&jni, obj)?);
        }
        Ok(new_vec)
    }
    /// Return the namespaced identifier for this object.
    pub fn key(&self) -> Result<crate::NamespacedKey<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/NamespacedKey;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getKey", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        crate::NamespacedKey::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
#[repr(C)]
pub struct BanEntry<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for BanEntry<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for BanEntry<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate BanEntry from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/BanEntry")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a BanEntry object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> BanEntry<'mc> {
    #[deprecated]
    /// Gets the target involved. This may be in the form of an IP or a player name.
    pub fn target(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getTarget", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Gets the target involved.
    pub fn ban_target(&self) -> Result<jni::objects::JObject<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()LT;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getBanTarget", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(res.l()?)
    }
    /// Gets the date this ban entry was created.
    pub fn created(
        &self,
    ) -> Result<blackboxmc_java::util::JavaDate<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Date;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getCreated", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        blackboxmc_java::util::JavaDate::from_raw(&self.jni_ref(), unsafe {
            jni::objects::JObject::from_raw(res.l()?.clone())
        })
    }
    /// Sets the date this ban entry was created.
    pub fn set_created(
        &self,
        created: impl Into<blackboxmc_java::util::JavaDate<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/Date;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(created.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setCreated",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the source of this ban.
    ///
    /// Note: A source is considered any String, although this is generally a
    /// player name.
    pub fn source(&self) -> Result<String, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getSource", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        Ok(self
            .jni_ref()
            .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
            .to_string_lossy()
            .to_string())
    }
    /// Sets the source of this ban.
    ///
    /// Note: A source is considered any String, although this is generally a
    /// player name.
    pub fn set_source(&self, source: impl Into<String>) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(source.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setSource",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the date this ban expires on, or null for no defined end date.
    pub fn expiration(
        &self,
    ) -> Result<Option<blackboxmc_java::util::JavaDate<'mc>>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/util/Date;");
        let res =
            self.jni_ref()
                .call_method(&self.jni_object(), "getExpiration", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(blackboxmc_java::util::JavaDate::from_raw(
            &self.jni_ref(),
            unsafe { jni::objects::JObject::from_raw(res.l()?.clone()) },
        )?))
    }
    /// Sets the date this ban expires on. Null values are considered
    /// "infinite" bans.
    pub fn set_expiration(
        &self,
        expiration: impl Into<blackboxmc_java::util::JavaDate<'mc>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/util/Date;)V");
        let val_1 = jni::objects::JValueGen::Object(unsafe {
            jni::objects::JObject::from_raw(expiration.into().jni_object().clone())
        });
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setExpiration",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Gets the reason for this ban.
    pub fn reason(&self) -> Result<Option<String>, Box<dyn std::error::Error>> {
        let sig = String::from("()Ljava/lang/String;");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "getReason", sig.as_str(), vec![]);
        let res = self.jni_ref().translate_error(res)?;
        if unsafe { jni::objects::JObject::from_raw(res.as_jni().l) }.is_null() {
            return Ok(None);
        }
        Ok(Some(
            self.jni_ref()
                .get_string(unsafe { &jni::objects::JString::from_raw(res.as_jni().l) })?
                .to_string_lossy()
                .to_string(),
        ))
    }
    /// Sets the reason for this ban. Reasons must not be null.
    pub fn set_reason(&self, reason: impl Into<String>) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("(Ljava/lang/String;)V");
        let val_1 = jni::objects::JValueGen::Object(jni::objects::JObject::from(
            self.jni_ref().new_string(reason.into())?,
        ));
        let res = self.jni_ref().call_method(
            &self.jni_object(),
            "setReason",
            sig.as_str(),
            vec![jni::objects::JValueGen::from(val_1)],
        );
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Saves the ban entry, overwriting any previous data in the ban list.
    ///
    /// Saving the ban entry of an unbanned player will cause the player to be
    /// banned once again.
    pub fn save(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "save", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }
    /// Removes this ban entry from the appropriate ban list.
    pub fn remove(&self) -> Result<(), Box<dyn std::error::Error>> {
        let sig = String::from("()V");
        let res = self
            .jni_ref()
            .call_method(&self.jni_object(), "remove", sig.as_str(), vec![]);
        self.jni_ref().translate_error(res)?;
        Ok(())
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub enum Axis<'mc> {}
impl<'mc> std::fmt::Display for Axis<'mc> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {}
    }
}

impl<'mc> Axis<'mc> {
    pub fn value_of(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        arg0: impl Into<String>,
    ) -> Result<Axis<'mc>, Box<dyn std::error::Error>> {
        let val_1 = jni::objects::JObject::from(env.new_string(arg0.into())?);
        let cls = env.find_class("org/bukkit/Axis");
        let cls = env.translate_error_with_class(cls)?;
        let res = env.call_static_method(
            cls,
            "valueOf",
            "(Ljava/lang/String;)Lorg/bukkit/Axis;",
            vec![jni::objects::JValueGen::from(val_1)],
        );
        let res = env.translate_error(res)?;
        let obj = res.l()?;
        let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
        let variant = env.translate_error(variant)?;
        let variant_str = env
            .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
            .to_string_lossy()
            .to_string();
        match variant_str.as_str() {
            _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
        }
    }
}

#[repr(C)]
pub struct AxisStruct<'mc>(
    pub(crate) blackboxmc_general::SharedJNIEnv<'mc>,
    pub(crate) jni::objects::JObject<'mc>,
);

impl<'mc> JNIRaw<'mc> for Axis<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        match self {}
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        match self {}
    }
}
impl<'mc> JNIInstantiatable<'mc> for Axis<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate Axis from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Axis")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a Axis object, got {}",
                name
            )
            .into())
        } else {
            let variant = env.call_method(&obj, "toString", "()Ljava/lang/String;", vec![]);
            let variant = env.translate_error(variant)?;
            let variant_str = env
                .get_string(unsafe { &jni::objects::JString::from_raw(variant.as_jni().l) })?
                .to_string_lossy()
                .to_string();
            match variant_str.as_str() {
                _ => Err(eyre::eyre!("String gaven for variant was invalid").into()),
            }
        }
    }
}

impl<'mc> JNIRaw<'mc> for AxisStruct<'mc> {
    fn jni_ref(&self) -> blackboxmc_general::SharedJNIEnv<'mc> {
        self.0.clone()
    }
    fn jni_object(&self) -> jni::objects::JObject<'mc> {
        unsafe { jni::objects::JObject::from_raw(self.1.clone()) }
    }
}
impl<'mc> JNIInstantiatable<'mc> for AxisStruct<'mc> {
    fn from_raw(
        env: &blackboxmc_general::SharedJNIEnv<'mc>,
        obj: jni::objects::JObject<'mc>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        if obj.is_null() {
            return Err(eyre::eyre!("Tried to instantiate AxisStruct from null object.").into());
        }
        let (valid, name) = env.validate_name(&obj, "org/bukkit/Axis")?;
        if !valid {
            Err(eyre::eyre!(
                "Invalid argument passed. Expected a AxisStruct object, got {}",
                name
            )
            .into())
        } else {
            Ok(Self(env.clone(), obj))
        }
    }
}

impl<'mc> AxisStruct<'mc> {
    pub fn values(
        jni: &blackboxmc_general::SharedJNIEnv<'mc>,
    ) -> Result<crate::Axis<'mc>, Box<dyn std::error::Error>> {
        let sig = String::from("()Lorg/bukkit/Axis;");
        let cls = jni.find_class("org/bukkit/Axis");
        let cls = jni.translate_error_with_class(cls)?;
        let res = jni.call_static_method(cls, "values", sig.as_str(), vec![]);
        let res = jni.translate_error(res)?;
        let obj = res.l()?;
        crate::Axis::from_raw(&jni, obj)
    }

    pub fn instance_of(&self, other: impl Into<String>) -> Result<bool, jni::errors::Error> {
        let cls = &self.jni_ref().find_class(other.into().as_str())?;
        self.jni_ref().is_instance_of(&self.jni_object(), cls)
    }
}
pub mod advancement;
pub mod attribute;
pub mod ban;
pub mod block;
pub mod boss;
pub mod command;
pub mod configuration;
pub mod conversations;
pub mod damage;
pub mod enchantments;
pub mod entity;
pub mod event;
pub mod generator;
pub mod help;
pub mod inventory;
pub mod loot;
pub mod map;
pub mod material;
pub mod metadata;
pub mod packs;
pub mod permissions;
pub mod persistence;
pub mod plugin;
pub mod potion;
pub mod profile;
pub mod projectiles;
pub mod scheduler;
pub mod scoreboard;
pub mod structure;
pub mod util;
